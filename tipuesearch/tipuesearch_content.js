var tipuesearch = {"pages":[{"title":" MCTC-library ","text":"MCTC-library Common tool chain to molecular structure data in various applications.\nThis library provides a unified way to perform operations on molecular structure data, like reading and writing to common geometry file formats. Input and Output Standard environment Light testing framework Getting Started Meson Fortran Package Manager (fpm) Input and Output The IO module ( mctc_io ) provides access to a common type to declare molecular structure data ( structure_type ).\nAlso, reader routines ( mctc_io_read ) to obtain structure_type objects from input files are available.\nTo write a structure_type object a set of writer routines are available as well ( mctc_io_write ). Standard environment The tool chain library provides an environment module ( mctc_env ) to allow the usage of common constants across different users.\nFor a minimal error handling the error_type is available and should be passed as allocatable type to the library procedures.\nThe allocation status of the error_type is used to determine failed executions and the respective error message is stored transparently in the error_type . Light testing framework Additionally, the environment module provides a testsuite implementation to setup a slim and light testing framework in dependent applications.\nThe test framework can be easily setup by the mctc_env_testing module. Getting Started Meson Create a new meson project and include mctc-lib either as git-submodule in your subprojects directory or create a wrap file to fetch it from upstream: [wrap-git] directory = mctc-lib url = https://github.com/grimme-lab/mctc-lib revision = head To load the project the necessary boilerplate code for subprojects is just mctc_prj = subproject ( 'mctc-lib' , version : '>=0.1' , default_options : [ 'default_library=static' , ], ) mctc_dep = mctc_prj . get_variable ( 'mctc_dep' ) Now you can add mctc_dep to your dependencies and access the public API by the mctc module. We recommend to set the default library type of mctc-lib to static when linking your applications or library against it.\nNote for library type both and shared mctc-lib will install itself along with your project. For more fine-tuned control you can access: the library target with mctc_lib the private include dir of this target, containing the Fortran module files, with mctc_inc the license files of mctc-lib with mctc_lic If you are linking your application statically against mctc-lib and still want to distribute the license files of mctc-lib (thank you), just use install_data ( mctc_prj . get_variable ( 'mctc_lic' ), install_dir : get_option ( 'datadir' ) / 'licenses' / meson . project_name () / 'mctc-lib' , ) Fortran Package Manager (fpm) This project supports fpm as build system as well.\nJust add it to the dependencies in your fpm.toml file: [dependencies] [dependencies.mctc-lib] git = \"https://github.com/grimme-lab/mctc-lib\" Developer Info Grimme group, Bonn","tags":"home","loc":"index.html"},{"title":"env.f90 – MCTC-library","text":"Contents Modules mctc_env Source Code env.f90 Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Public API reexport of environment library module mctc_env use mctc_env_accuracy , only : sp , dp , wp , i1 , i2 , i4 , i8 use mctc_env_error , only : error_type , fatal_error , mctc_stat use mctc_env_system , only : get_argument , get_variable , & & is_unix , is_windows implicit none public end module mctc_env","tags":"","loc":"sourcefile/env.f90.html"},{"title":"io.f90 – MCTC-library","text":"Contents Modules mctc_io Source Code io.f90 Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Input and output module of the tool chain library. !> !> This module exports the basic [[structure_type]] as well as routines !> to read it from a file or formatted unit ([[read_structure]]) or write !> it to a formatted unit ([[write_structure]]). !> !> Both [[read_structure]] and [[write_structure]] take format hints from !> the filetype enumerator. File names can be translated to the respective !> enumerator by using the [[get_filetype]] function. This can be useful in !> case the caller routine wants to open the formatted unit itself or uses !> a non-standard file extension. module mctc_io use mctc_io_filetype , only : filetype , get_filetype use mctc_io_read , only : read_structure use mctc_io_structure , only : structure_type , new_structure , new use mctc_io_symbols , only : to_symbol , to_number use mctc_io_write , only : write_structure implicit none private public :: filetype , get_filetype public :: read_structure , write_structure public :: structure_type , new_structure , new public :: to_symbol , to_number contains end module mctc_io","tags":"","loc":"sourcefile/io.f90.html"},{"title":"version.f90 – MCTC-library","text":"Contents Modules mctc_version Source Code version.f90 Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. module mctc_version implicit none private public :: mctc_version_string , mctc_version_compact public :: get_mctc_version !> String representation of the mctc-lib version character ( len =* ), parameter :: mctc_version_string = \"0.2.1\" !> Numeric representation of the mctc-lib version integer , parameter :: mctc_version_compact ( 3 ) = [ 0 , 2 , 1 ] contains !> Getter function to retrieve mctc-lib version subroutine get_mctc_version ( major , minor , patch , string ) !> Major version number of the mctc-lib version integer , intent ( out ), optional :: major !> Minor version number of the mctc-lib version integer , intent ( out ), optional :: minor !> Patch version number of the mctc-lib version integer , intent ( out ), optional :: patch !> String representation of the mctc-lib version character ( len = :), allocatable , intent ( out ), optional :: string if ( present ( major )) then major = mctc_version_compact ( 1 ) end if if ( present ( minor )) then minor = mctc_version_compact ( 2 ) end if if ( present ( patch )) then patch = mctc_version_compact ( 3 ) end if if ( present ( string )) then string = mctc_version_string end if end subroutine get_mctc_version end module mctc_version","tags":"","loc":"sourcefile/version.f90.html"},{"title":"testing.f90 – MCTC-library","text":"Contents Modules mctc_env_testing Source Code testing.f90 Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Provides a light-weight testing framework for usage in projects depending on !> the tool chain library. !> !> Testsuites are defined by a [[collect_interface]] returning a set of !> [[unittest_type]] objects. To create a new test use the [[new_unittest]] !> constructor, which requires a test identifier and a procedure with a !> [[test_interface]] compatible signature. The error status is communicated !> by the allocation status of an [[error_type]]. !> !> The necessary boilerplate code to setup the test entry point is just !> !>```fortran !>program tester !>   use, intrinsic :: iso_fortran_env, only : error_unit !>   use mctc_env_testing, only : run_testsuite, new_testsuite, testsuite_type !>   use test_suite1, only : collect_suite1 !>   use test_suite2, only : collect_suite2 !>   implicit none !>   integer :: stat, ii !>   type(testsuite_type), allocatable :: testsuites(:) !>   character(len=*), parameter :: fmt = '(\"#\", *(1x, a))' !> !>   stat = 0 !> !>   testsuites = [ & !>      & new_testsuite(\"suite1\", collect_suite1), & !>      & new_testsuite(\"suite2\", collect_suite2) & !>      & ] !> !>   do ii = 1, size(testsuites) !>      write(error_unit, fmt) \"Testing:\", testsuites(ii)%name !>      call run_testsuite(testsuites(ii)%collect, error_unit, stat) !>   end do !> !>   if (stat > 0) then !>      write(error_unit, '(i0, 1x, a)') stat, \"test(s) failed!\" !>      error stop !>   end if !> !>end program tester !>``` !> !> Every test is defined in a separate module using a ``collect`` function, which !> is exported and added to the ``testsuites`` array in the test runner. !> All test have a simple interface with just an allocatable [[error_type]] as !> output to provide the test results. !> !>```fortran !>module test_suite1 !>   use mctc_env_testing, only : new_unittest, unittest_type, error_type, check !>   implicit none !>   private !> !>   public :: collect_suite1 !> !>contains !> !>!> Collect all exported unit tests !>subroutine collect_suite1(testsuite) !>   !> Collection of tests !>   type(unittest_type), allocatable, intent(out) :: testsuite(:) !> !>   testsuite = [ & !>      & new_unittest(\"valid\", test_valid), & !>      & new_unittest(\"invalid\", test_invalid, should_fail=.true.) & !>      & ] !> !>end subroutine collect_suite1 !> !>subroutine test_valid(error) !>   type(error_type), allocatable, intent(out) :: error !>   ! ... !>end subroutine test_valid !> !>subroutine test_invalid(error) !>   type(error_type), allocatable, intent(out) :: error !>   ! ... !>end subroutine test_invalid !> !>end module test_suite1 !>``` !> !> For an example setup checkout the ``test/`` directory in this project. module mctc_env_testing use mctc_env_error , only : error_type , mctc_stat use mctc_env_accuracy , only : sp , dp , i1 , i2 , i4 , i8 implicit none private public :: run_testsuite , run_selected , new_unittest , new_testsuite public :: select_test , select_suite public :: unittest_type , testsuite_type , error_type public :: check , test_failed public :: test_interface , collect_interface interface check module procedure :: check_stat module procedure :: check_logical module procedure :: check_float_sp module procedure :: check_float_dp module procedure :: check_int_i1 module procedure :: check_int_i2 module procedure :: check_int_i4 module procedure :: check_int_i8 module procedure :: check_bool module procedure :: check_string end interface check abstract interface !> Entry point for tests subroutine test_interface ( error ) import :: error_type !> Error handling type ( error_type ), allocatable , intent ( out ) :: error end subroutine test_interface end interface !> Declaration of a unit test type :: unittest_type !> Name of the test character ( len = :), allocatable :: name !> Entry point of the test procedure ( test_interface ), pointer , nopass :: test => null () !> Whether test is supposed to fail logical :: should_fail = . false . end type unittest_type abstract interface !> Collect all tests subroutine collect_interface ( testsuite ) import :: unittest_type !> Collection of tests type ( unittest_type ), allocatable , intent ( out ) :: testsuite (:) end subroutine collect_interface end interface !> Collection of unit tests type :: testsuite_type !> Name of the testsuite character ( len = :), allocatable :: name !> Entry point of the test procedure ( collect_interface ), pointer , nopass :: collect => null () end type testsuite_type character ( len =* ), parameter :: fmt = '(1x, *(1x, a))' character ( len =* ), parameter :: indent = repeat ( \" \" , 5 ) // repeat ( \".\" , 3 ) contains !> Driver for testsuite subroutine run_testsuite ( collect , unit , stat ) !> Collect tests procedure ( collect_interface ) :: collect !> Unit for IO integer , intent ( in ) :: unit !> Number of failed tests integer , intent ( inout ) :: stat type ( unittest_type ), allocatable :: testsuite (:) integer :: ii call collect ( testsuite ) !$omp parallel do shared(testsuite, unit) reduction(+:stat) do ii = 1 , size ( testsuite ) !$omp critical(mctc_env_testsuite) write ( unit , '(1x, 3(1x, a), 1x, \"(\", i0, \"/\", i0, \")\")' ) & & \"Starting\" , testsuite ( ii )% name , \"...\" , ii , size ( testsuite ) !$omp end critical(mctc_env_testsuite) call run_unittest ( testsuite ( ii ), unit , stat ) end do end subroutine run_testsuite !> Driver for selective testing subroutine run_selected ( collect , name , unit , stat ) !> Collect tests procedure ( collect_interface ) :: collect !> Name of the selected test character ( len =* ), intent ( in ) :: name !> Unit for IO integer , intent ( in ) :: unit !> Number of failed tests integer , intent ( inout ) :: stat type ( unittest_type ), allocatable :: testsuite (:) integer :: ii call collect ( testsuite ) ii = select_test ( testsuite , name ) if ( ii > 0 . and . ii <= size ( testsuite )) then call run_unittest ( testsuite ( ii ), unit , stat ) else write ( unit , fmt ) \"Available tests:\" do ii = 1 , size ( testsuite ) write ( unit , fmt ) \"-\" , testsuite ( ii )% name end do stat = - huge ( ii ) end if end subroutine run_selected !> Run a selected unit test subroutine run_unittest ( test , unit , stat ) !> Unit test type ( unittest_type ), intent ( in ) :: test !> Unit for IO integer , intent ( in ) :: unit !> Number of failed tests integer , intent ( inout ) :: stat type ( error_type ), allocatable :: error call test % test ( error ) !$omp critical(mctc_env_testsuite) if ( allocated ( error ) . neqv . test % should_fail ) then if ( test % should_fail ) then write ( unit , fmt ) indent , test % name , \"[UNEXPECTED PASS]\" else write ( unit , fmt ) indent , test % name , \"[FAILED]\" end if stat = stat + 1 else if ( test % should_fail ) then write ( unit , fmt ) indent , test % name , \"[EXPECTED FAIL]\" else write ( unit , fmt ) indent , test % name , \"[PASSED]\" end if end if if ( allocated ( error )) then write ( unit , fmt ) \"Message:\" , error % message end if !$omp end critical(mctc_env_testsuite) end subroutine run_unittest !> Select a unit test from all available tests function select_test ( tests , name ) result ( pos ) !> Name identifying the test suite character ( len =* ), intent ( in ) :: name !> Available unit tests type ( unittest_type ) :: tests (:) !> Selected test suite integer :: pos integer :: it pos = 0 do it = 1 , size ( tests ) if ( name == tests ( it )% name ) then pos = it exit end if end do end function select_test !> Select a test suite from all available suites function select_suite ( suites , name ) result ( pos ) !> Name identifying the test suite character ( len =* ), intent ( in ) :: name !> Available test suites type ( testsuite_type ) :: suites (:) !> Selected test suite integer :: pos integer :: it pos = 0 do it = 1 , size ( suites ) if ( name == suites ( it )% name ) then pos = it exit end if end do end function select_suite !> Register a new unit test function new_unittest ( name , test , should_fail ) result ( self ) !> Name of the test character ( len =* ), intent ( in ) :: name !> Entry point for the test procedure ( test_interface ) :: test !> Whether test is supposed to error or not logical , intent ( in ), optional :: should_fail !> Newly registered test type ( unittest_type ) :: self self % name = name self % test => test if ( present ( should_fail )) self % should_fail = should_fail end function new_unittest !> Register a new testsuite function new_testsuite ( name , collect ) result ( self ) !> Name of the testsuite character ( len =* ), intent ( in ) :: name !> Entry point to collect tests procedure ( collect_interface ) :: collect !> Newly registered testsuite type ( testsuite_type ) :: self self % name = name self % collect => collect end function new_testsuite subroutine check_stat ( error , stat , message , more ) !> Error handling type ( error_type ), allocatable , intent ( out ) :: error !> Status of operation integer , intent ( in ) :: stat !> A detailed message describing the error character ( len =* ), intent ( in ), optional :: message !> Another line of error message character ( len =* ), intent ( in ), optional :: more if ( stat /= mctc_stat % success ) then if ( present ( message )) then call test_failed ( error , message , more ) else call test_failed ( error , \"Non-zero exit code encountered\" , more ) end if end if end subroutine check_stat subroutine check_logical ( error , expression , message , more ) !> Error handling type ( error_type ), allocatable , intent ( out ) :: error !> Result of logical operator logical , intent ( in ) :: expression !> A detailed message describing the error character ( len =* ), intent ( in ), optional :: message !> Another line of error message character ( len =* ), intent ( in ), optional :: more if (. not . expression ) then if ( present ( message )) then call test_failed ( error , message , more ) else call test_failed ( error , \"Condition not fullfilled\" , more ) end if end if end subroutine check_logical subroutine check_float_dp ( error , actual , expected , message , more , thr , rel ) !> Error handling type ( error_type ), allocatable , intent ( out ) :: error !> Found floating point value real ( dp ), intent ( in ) :: actual !> Expected floating point value real ( dp ), intent ( in ) :: expected !> A detailed message describing the error character ( len =* ), intent ( in ), optional :: message !> Another line of error message character ( len =* ), intent ( in ), optional :: more !> Allowed threshold for matching floating point values real ( dp ), intent ( in ), optional :: thr !> Check for relative errors instead logical , intent ( in ), optional :: rel logical :: relative real ( dp ) :: diff , threshold if ( present ( thr )) then threshold = thr else threshold = epsilon ( expected ) end if if ( present ( rel )) then relative = rel else relative = . false . end if if ( relative ) then diff = abs ( actual - expected ) / expected else diff = abs ( actual - expected ) end if if ( diff > threshold ) then if ( present ( message )) then call test_failed ( error , message , more ) else call test_failed ( error , \"Floating point value missmatch\" , more ) end if end if end subroutine check_float_dp subroutine check_float_sp ( error , actual , expected , message , more , thr , rel ) !> Error handling type ( error_type ), allocatable , intent ( out ) :: error !> Found floating point value real ( sp ), intent ( in ) :: actual !> Expected floating point value real ( sp ), intent ( in ) :: expected !> A detailed message describing the error character ( len =* ), intent ( in ), optional :: message !> Another line of error message character ( len =* ), intent ( in ), optional :: more !> Allowed threshold for matching floating point values real ( sp ), intent ( in ), optional :: thr !> Check for relative errors instead logical , intent ( in ), optional :: rel logical :: relative real ( sp ) :: diff , threshold if ( present ( thr )) then threshold = thr else threshold = epsilon ( expected ) end if if ( present ( rel )) then relative = rel else relative = . false . end if if ( relative ) then diff = abs ( actual - expected ) / expected else diff = abs ( actual - expected ) end if if ( diff > threshold ) then if ( present ( message )) then call test_failed ( error , message , more ) else call test_failed ( error , \"Floating point value missmatch\" , more ) end if end if end subroutine check_float_sp subroutine check_int_i1 ( error , actual , expected , message , more ) !> Error handling type ( error_type ), allocatable , intent ( out ) :: error !> Found integer value integer ( i1 ), intent ( in ) :: actual !> Expected integer value integer ( i1 ), intent ( in ) :: expected !> A detailed message describing the error character ( len =* ), intent ( in ), optional :: message !> Another line of error message character ( len =* ), intent ( in ), optional :: more if ( expected /= actual ) then if ( present ( message )) then call test_failed ( error , message , more ) else call test_failed ( error , \"Integer value missmatch\" , more ) end if end if end subroutine check_int_i1 subroutine check_int_i2 ( error , actual , expected , message , more ) !> Error handling type ( error_type ), allocatable , intent ( out ) :: error !> Found integer value integer ( i2 ), intent ( in ) :: actual !> Expected integer value integer ( i2 ), intent ( in ) :: expected !> A detailed message describing the error character ( len =* ), intent ( in ), optional :: message !> Another line of error message character ( len =* ), intent ( in ), optional :: more if ( expected /= actual ) then if ( present ( message )) then call test_failed ( error , message , more ) else call test_failed ( error , \"Integer value missmatch\" , more ) end if end if end subroutine check_int_i2 subroutine check_int_i4 ( error , actual , expected , message , more ) !> Error handling type ( error_type ), allocatable , intent ( out ) :: error !> Found integer value integer ( i4 ), intent ( in ) :: actual !> Expected integer value integer ( i4 ), intent ( in ) :: expected !> A detailed message describing the error character ( len =* ), intent ( in ), optional :: message !> Another line of error message character ( len =* ), intent ( in ), optional :: more if ( expected /= actual ) then if ( present ( message )) then call test_failed ( error , message , more ) else call test_failed ( error , \"Integer value missmatch\" , more ) end if end if end subroutine check_int_i4 subroutine check_int_i8 ( error , actual , expected , message , more ) !> Error handling type ( error_type ), allocatable , intent ( out ) :: error !> Found integer value integer ( i8 ), intent ( in ) :: actual !> Expected integer value integer ( i8 ), intent ( in ) :: expected !> A detailed message describing the error character ( len =* ), intent ( in ), optional :: message !> Another line of error message character ( len =* ), intent ( in ), optional :: more if ( expected /= actual ) then if ( present ( message )) then call test_failed ( error , message , more ) else call test_failed ( error , \"Integer value missmatch\" , more ) end if end if end subroutine check_int_i8 subroutine check_bool ( error , actual , expected , message , more ) !> Error handling type ( error_type ), allocatable , intent ( out ) :: error !> Found boolean value logical , intent ( in ) :: actual !> Expected boolean value logical , intent ( in ) :: expected !> A detailed message describing the error character ( len =* ), intent ( in ), optional :: message !> Another line of error message character ( len =* ), intent ( in ), optional :: more if ( expected . neqv . actual ) then if ( present ( message )) then call test_failed ( error , message , more ) else call test_failed ( error , \"Logical value missmatch\" , more ) end if end if end subroutine check_bool subroutine check_string ( error , actual , expected , message , more ) !> Error handling type ( error_type ), allocatable , intent ( out ) :: error !> Found boolean value character ( len =* ), intent ( in ) :: actual !> Expected boolean value character ( len =* ), intent ( in ) :: expected !> A detailed message describing the error character ( len =* ), intent ( in ), optional :: message !> Another line of error message character ( len =* ), intent ( in ), optional :: more if ( expected /= actual ) then if ( present ( message )) then call test_failed ( error , message , more ) else call test_failed ( error , \"Character value missmatch\" , more ) end if end if end subroutine check_string subroutine test_failed ( error , message , more ) !> Error handling type ( error_type ), allocatable , intent ( out ) :: error !> A detailed message describing the error character ( len =* ), intent ( in ) :: message !> Another line of error message character ( len =* ), intent ( in ), optional :: more allocate ( error ) error % stat = mctc_stat % fatal if ( present ( more )) then error % message = message // new_line ( 'a' ) // more else error % message = message end if end subroutine test_failed end module mctc_env_testing","tags":"","loc":"sourcefile/testing.f90.html"},{"title":"system.f90 – MCTC-library","text":"Contents Modules mctc_env_system Source Code system.f90 Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Module collecting commands to conveniently interface with system commands module mctc_env_system implicit none private public :: get_argument , get_variable public :: is_windows , is_unix contains !> Obtain the command line argument at a given index subroutine get_argument ( idx , arg ) !> Index of command line argument, range [0:command_argument_count()] integer , intent ( in ) :: idx !> Command line argument character ( len = :), allocatable , intent ( out ) :: arg integer :: length , stat call get_command_argument ( idx , length = length , status = stat ) if ( stat /= 0 ) then return endif allocate ( character ( len = length ) :: arg , stat = stat ) if ( stat /= 0 ) then return endif if ( length > 0 ) then call get_command_argument ( idx , arg , status = stat ) if ( stat /= 0 ) then deallocate ( arg ) return end if end if end subroutine get_argument !> Obtain the value of an environment variable subroutine get_variable ( var , val ) !> Name of variable character ( len =* ), intent ( in ) :: var !> Value of variable character ( len = :), allocatable , intent ( out ) :: val integer :: length , stat call get_environment_variable ( var , length = length , status = stat ) if ( stat /= 0 ) then return endif allocate ( character ( len = length ) :: val , stat = stat ) if ( stat /= 0 ) then return endif if ( length > 0 ) then call get_environment_variable ( var , val , status = stat ) if ( stat /= 0 ) then deallocate ( val ) return end if end if end subroutine get_variable !> Try to determine if we run on Windows and don't have POSIX compliance around function is_windows () !> Operating system seems to be Windows logical :: is_windows character ( len = :), allocatable :: tmp is_windows = . false . call get_variable ( 'OS' , tmp ) if ( allocated ( tmp )) then is_windows = index ( tmp , 'Windows_NT' ) > 0 end if if (. not . is_windows ) then call get_variable ( 'OSTYPE' , tmp ) if ( allocated ( tmp )) then is_windows = index ( tmp , 'win' ) > 0 . or . index ( tmp , 'msys' ) > 0 end if end if end function is_windows !> Try to determine if we run on Unix and probably can rely on POSIX compliance function is_unix () !> Operating system seems to be Unix logical :: is_unix character ( len = :), allocatable :: tmp is_unix = . not . is_windows () end function is_unix end module mctc_env_system","tags":"","loc":"sourcefile/system.f90.html"},{"title":"error.f90 – MCTC-library","text":"Contents Modules mctc_env_error Source Code error.f90 Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Central registry for error codes module mctc_env_error implicit none private public :: mctc_stat , error_type public :: fatal_error !> Possible error codes type :: enum_stat !> Successful run integer :: success = 0 !> Internal error: integer :: fatal = 1 end type enum_stat !> Actual enumerator for return states type ( enum_stat ), parameter :: mctc_stat = enum_stat () !> Error message type :: error_type !> Error code integer :: stat !> Payload of the error character ( len = :), allocatable :: message end type error_type contains !> A fatal error is encountered subroutine fatal_error ( error , message , stat ) !> Instance of the error type ( error_type ), allocatable , intent ( out ) :: error !> A detailed message describing the error and (optionally) offering advice character ( len =* ), intent ( in ), optional :: message !> Overwrite of the error code integer , intent ( in ), optional :: stat allocate ( error ) if ( present ( stat )) then error % stat = stat else error % stat = mctc_stat % fatal end if if ( present ( message )) then error % message = message else error % message = \"Fatal error\" end if end subroutine fatal_error end module mctc_env_error","tags":"","loc":"sourcefile/error.f90.html"},{"title":"accuracy.f90 – MCTC-library","text":"Contents Modules mctc_env_accuracy Source Code accuracy.f90 Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Numerical storage size parameters for real and integer values module mctc_env_accuracy implicit none public !> Single precision real numbers integer , parameter :: sp = selected_real_kind ( 6 ) !> Double precision real numbers integer , parameter :: dp = selected_real_kind ( 15 ) !> Wanted precision integer , parameter :: wp = dp !> Char length for integers integer , parameter :: i1 = selected_int_kind ( 2 ) !> Short length for integers integer , parameter :: i2 = selected_int_kind ( 4 ) !> Length of default integers integer , parameter :: i4 = selected_int_kind ( 9 ) !> Long length for integers integer , parameter :: i8 = selected_int_kind ( 18 ) end module mctc_env_accuracy","tags":"","loc":"sourcefile/accuracy.f90.html"},{"title":"symbols.f90 – MCTC-library","text":"Contents Modules mctc_io_symbols Source Code symbols.f90 Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Handle conversion between element symbols and atomic numbers module mctc_io_symbols use mctc_io_resize , only : resize implicit none private public :: symbol_length public :: symbol_to_number , number_to_symbol , number_to_lcsymbol public :: to_number , to_symbol , to_lcsymbol public :: get_identity , collect_identical !> Get chemical identity interface get_identity module procedure :: get_identity_number module procedure :: get_identity_symbol end interface get_identity !> Maximum allowed length of element symbols integer , parameter :: symbol_length = 4 !> Periodic system of elements character ( len = 2 ), parameter :: pse ( 118 ) = [ & & 'H ' , 'He' , & & 'Li' , 'Be' , 'B ' , 'C ' , 'N ' , 'O ' , 'F ' , 'Ne' , & & 'Na' , 'Mg' , 'Al' , 'Si' , 'P ' , 'S ' , 'Cl' , 'Ar' , & & 'K ' , 'Ca' , & & 'Sc' , 'Ti' , 'V ' , 'Cr' , 'Mn' , 'Fe' , 'Co' , 'Ni' , 'Cu' , 'Zn' , & & 'Ga' , 'Ge' , 'As' , 'Se' , 'Br' , 'Kr' , & & 'Rb' , 'Sr' , & & 'Y ' , 'Zr' , 'Nb' , 'Mo' , 'Tc' , 'Ru' , 'Rh' , 'Pd' , 'Ag' , 'Cd' , & & 'In' , 'Sn' , 'Sb' , 'Te' , 'I ' , 'Xe' , & & 'Cs' , 'Ba' , & & 'La' , 'Ce' , 'Pr' , 'Nd' , 'Pm' , 'Sm' , 'Eu' , 'Gd' , 'Tb' , 'Dy' , 'Ho' , 'Er' , 'Tm' , 'Yb' , & & 'Lu' , 'Hf' , 'Ta' , 'W ' , 'Re' , 'Os' , 'Ir' , 'Pt' , 'Au' , 'Hg' , & & 'Tl' , 'Pb' , 'Bi' , 'Po' , 'At' , 'Rn' , & & 'Fr' , 'Ra' , & & 'Ac' , 'Th' , 'Pa' , 'U ' , 'Np' , 'Pu' , 'Am' , 'Cm' , 'Bk' , 'Cf' , 'Es' , 'Fm' , 'Md' , 'No' , & & 'Lr' , 'Rf' , 'Db' , 'Sg' , 'Bh' , 'Hs' , 'Mt' , 'Ds' , 'Rg' , 'Cn' , & & 'Nh' , 'Fl' , 'Mc' , 'Lv' , 'Ts' , 'Og' ] !> Lower case version of the periodic system of elements character ( len = 2 ), parameter :: lcpse ( 118 ) = [ & & 'h ' , 'he' , & & 'li' , 'be' , 'b ' , 'c ' , 'n ' , 'o ' , 'f ' , 'ne' , & & 'na' , 'mg' , 'al' , 'si' , 'p ' , 's ' , 'cl' , 'ar' , & & 'k ' , 'ca' , & & 'sc' , 'ti' , 'v ' , 'cr' , 'mn' , 'fe' , 'co' , 'ni' , 'cu' , 'zn' , & & 'ga' , 'ge' , 'as' , 'se' , 'br' , 'kr' , & & 'rb' , 'sr' , & & 'y ' , 'zr' , 'nb' , 'mo' , 'tc' , 'ru' , 'rh' , 'pd' , 'ag' , 'cd' , & & 'in' , 'sn' , 'sb' , 'te' , 'i ' , 'xe' , & & 'cs' , 'ba' , 'la' , & & 'ce' , 'pr' , 'nd' , 'pm' , 'sm' , 'eu' , 'gd' , 'tb' , 'dy' , 'ho' , 'er' , 'tm' , 'yb' , & & 'lu' , 'hf' , 'ta' , 'w ' , 're' , 'os' , 'ir' , 'pt' , 'au' , 'hg' , & & 'tl' , 'pb' , 'bi' , 'po' , 'at' , 'rn' , & & 'fr' , 'ra' , 'ac' , & & 'th' , 'pa' , 'u ' , 'np' , 'pu' , 'am' , 'cm' , 'bk' , 'cf' , 'es' , 'fm' , 'md' , 'no' , & & 'lr' , 'rf' , 'db' , 'sg' , 'bh' , 'hs' , 'mt' , 'ds' , 'rg' , 'cn' , & & 'nh' , 'fl' , 'mc' , 'lv' , 'ts' , 'og' ] !> ASCII offset between lowercase and uppercase letters integer , parameter :: offset = iachar ( 'a' ) - iachar ( 'A' ) contains !> Convert element symbol to atomic number elemental subroutine symbol_to_number ( number , symbol ) !> Element symbol character ( len =* ), intent ( in ) :: symbol !> Atomic number integer , intent ( out ) :: number character ( len = 2 ) :: lcsymbol integer :: i , j , k , l number = 0 lcsymbol = '  ' k = 0 do j = 1 , len_trim ( symbol ) if ( k > 2 ) exit l = iachar ( symbol ( j : j )) if ( k >= 1 . and . l == iachar ( ' ' )) exit if ( k >= 1 . and . l == 9 ) exit if ( l >= iachar ( 'A' ) . and . l <= iachar ( 'Z' )) l = l + offset if ( l >= iachar ( 'a' ) . and . l <= iachar ( 'z' )) then k = k + 1 if ( k > 2 ) exit lcsymbol ( k : k ) = achar ( l ) endif enddo do i = 1 , size ( lcpse ) if ( lcsymbol == lcpse ( i )) then number = i exit endif enddo if ( number == 0 ) then select case ( lcsymbol ) case ( 'd ' , 't ' ) number = 1 end select end if end subroutine symbol_to_number !> Convert atomic number to element symbol elemental subroutine number_to_symbol ( symbol , number ) !> Atomic number integer , intent ( in ) :: number !> Element symbol character ( len = 2 ), intent ( out ) :: symbol if ( number <= 0 . or . number > size ( pse )) then symbol = '--' else symbol = pse ( number ) endif end subroutine number_to_symbol !> Convert atomic number to element symbol elemental subroutine number_to_lcsymbol ( symbol , number ) !> Atomic number integer , intent ( in ) :: number !> Element symbol character ( len = 2 ), intent ( out ) :: symbol if ( number <= 0 . or . number > size ( lcpse )) then symbol = '--' else symbol = lcpse ( number ) endif end subroutine number_to_lcsymbol !> Convert element symbol to atomic number elemental function to_number ( symbol ) result ( number ) !> Element symbol character ( len =* ), intent ( in ) :: symbol !> Atomic number integer :: number call symbol_to_number ( number , symbol ) end function to_number !> Convert atomic number to element symbol elemental function to_symbol ( number ) result ( symbol ) !> Atomic number integer , intent ( in ) :: number !> Element symbol character ( len = 2 ) :: symbol call number_to_symbol ( symbol , number ) end function to_symbol !> Convert atomic number to element symbol elemental function to_lcsymbol ( number ) result ( symbol ) !> Atomic number integer , intent ( in ) :: number !> Element symbol character ( len = 2 ) :: symbol call number_to_lcsymbol ( symbol , number ) end function to_lcsymbol !> Get chemical identity from a list of atomic numbers pure subroutine get_identity_number ( nid , identity , number ) !> Number of unique species integer , intent ( out ) :: nid !> Ordinal numbers integer , intent ( in ) :: number (:) !> Chemical identity integer , intent ( out ) :: identity (:) integer , allocatable :: itmp (:) integer :: nat , iat , iid nat = size ( identity ) allocate ( itmp ( nat )) nid = 0 do iat = 1 , nat iid = find_number ( itmp (: nid ), number ( iat )) if ( iid == 0 ) then call append_number ( itmp , nid , number ( iat )) iid = nid end if identity ( iat ) = iid end do end subroutine get_identity_number !> Get chemical identity from a list of element symbols pure subroutine get_identity_symbol ( nid , identity , symbol ) !> Number of unique species integer , intent ( out ) :: nid !> Element symbols character ( len = symbol_length ), intent ( in ) :: symbol (:) !> Chemical identity integer , intent ( out ) :: identity (:) character ( len = symbol_length ), allocatable :: stmp (:) integer :: nat , iat , iid nat = size ( identity ) allocate ( stmp ( nat )) nid = 0 do iat = 1 , nat iid = find_symbol ( stmp (: nid ), symbol ( iat )) if ( iid == 0 ) then call append_symbol ( stmp , nid , symbol ( iat )) iid = nid end if identity ( iat ) = iid end do end subroutine get_identity_symbol !> Establish a mapping between unique atom types and species pure subroutine collect_identical ( identity , mapping ) !> Chemical identity integer , intent ( in ) :: identity (:) !> Mapping from unique atoms integer , intent ( out ) :: mapping (:) integer :: iid , iat do iid = 1 , size ( mapping ) do iat = 1 , size ( identity ) if ( identity ( iat ) == iid ) then mapping ( iid ) = iat exit end if end do end do end subroutine collect_identical !> Find element symbol in an unordered list, all entries are required to be unique pure function find_symbol ( list , symbol ) result ( position ) !> List of element symbols character ( len =* ), intent ( in ) :: list (:) !> Element symbol character ( len =* ), intent ( in ) :: symbol !> Position of the symbol in list if found, otherwise zero integer :: position integer :: isym position = 0 do isym = 1 , size ( list ) if ( symbol == list ( isym )) then position = isym exit end if end do end function find_symbol !> Find atomic number in an unordered list, all entries are required to be unique pure function find_number ( list , number ) result ( position ) !> List of atomic numbers integer , intent ( in ) :: list (:) !> Atomic number integer , intent ( in ) :: number !> Position of the number in list if found, otherwise zero integer :: position integer :: inum position = 0 do inum = 1 , size ( list ) if ( number == list ( inum )) then position = inum exit end if end do end function find_number !> Append an element symbol to an unsorted list, to ensure no dublicates search !> for the element symbol first pure subroutine append_symbol ( list , nlist , symbol ) !> List of element symbols character ( len =* ), allocatable , intent ( inout ) :: list (:) !> Current occupied size of list integer , intent ( inout ) :: nlist !> Elements symbol character ( len =* ), intent ( in ) :: symbol if ( nlist >= size ( list )) then call resize ( list ) end if nlist = nlist + 1 list ( nlist ) = symbol end subroutine append_symbol !> Append an atomic number to an unsorted list, to ensure no dublicates search !> for the atomic number first pure subroutine append_number ( list , nlist , number ) !> List of atomic number integer , allocatable , intent ( inout ) :: list (:) !> Current occupied size of list integer , intent ( inout ) :: nlist !> Atomic number integer , intent ( in ) :: number if ( nlist >= size ( list )) then call resize ( list ) end if nlist = nlist + 1 list ( nlist ) = number end subroutine append_number end module mctc_io_symbols","tags":"","loc":"sourcefile/symbols.f90.html"},{"title":"filetype.f90 – MCTC-library","text":"Contents Modules mctc_io_filetype Source Code filetype.f90 Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> File type support module mctc_io_filetype implicit none private public :: filetype , get_filetype !> Possible file types type :: enum_filetype !> Unknown file type integer :: unknown = 0 !> xyz-format integer :: xyz = 1 !> Turbomole coordinate format integer :: tmol = 2 !> mol-format integer :: molfile = 3 !> Vasp coordinate input integer :: vasp = 4 !> Protein database format integer :: pdb = 5 !> Structure data format integer :: sdf = 6 !> GenFormat of DFTB+ integer :: gen = 7 !> Gaussian external format integer :: gaussian = 8 end type enum_filetype !> File type enumerator type ( enum_filetype ), parameter :: filetype = enum_filetype () contains elemental function get_filetype ( file ) result ( ftype ) !> Name of the file character ( len =* ), intent ( in ) :: file !> File type from extension integer :: ftype integer :: iext , isep ftype = filetype % unknown iext = index ( file , '.' , back = . true .) isep = scan ( file , '\\/' , back = . true .) if ( iext > isep . and . iext > 0 ) then select case ( to_lower ( file ( iext + 1 :))) case ( 'coord' , 'tmol' ) ftype = filetype % tmol case ( 'xyz' , 'log' ) ftype = filetype % xyz case ( 'mol' ) ftype = filetype % molfile case ( 'sdf' ) ftype = filetype % sdf case ( 'poscar' , 'contcar' , 'vasp' ) ftype = filetype % vasp case ( 'pdb' ) ftype = filetype % pdb case ( 'gen' ) ftype = filetype % gen case ( 'ein' ) ftype = filetype % gaussian end select if ( ftype /= filetype % unknown ) return else iext = len ( file ) + 1 end if if ( iext > isep ) then select case ( to_lower ( file ( isep + 1 : iext - 1 ))) case ( 'coord' ) ftype = filetype % tmol case ( 'poscar' , 'contcar' ) ftype = filetype % vasp end select end if end function get_filetype !> Convert input string to lowercase elemental function to_lower ( str ) result ( lcstr ) !> Input string character ( len =* ), intent ( in ) :: str !> Lowercase version of string character ( len = len ( str )) :: lcstr integer :: ilen , iquote , i , iav , iqc integer , parameter :: offset = iachar ( 'A' ) - iachar ( 'a' ) ilen = len ( str ) iquote = 0 lcstr = str do i = 1 , ilen iav = iachar ( str ( i : i )) if ( iquote == 0 . and . ( iav == 34 . or . iav == 39 )) then iquote = 1 iqc = iav cycle end if if ( iquote == 1 . and . iav == iqc ) then iquote = 0 cycle end if if ( iquote == 1 ) cycle if ( iav >= iachar ( 'A' ) . and . iav <= iachar ( 'Z' )) then lcstr ( i : i ) = achar ( iav - offset ) else lcstr ( i : i ) = str ( i : i ) end if end do end function to_lower end module mctc_io_filetype","tags":"","loc":"sourcefile/filetype.f90.html"},{"title":"convert.f90 – MCTC-library","text":"Contents Modules mctc_io_convert Source Code convert.f90 Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Conversion factors module mctc_io_convert use mctc_env_accuracy , only : wp use mctc_io_constants , only : pi , codata implicit none private !> Reducted Planck's constant real ( wp ), parameter :: hbar = codata % h / ( 2.0_wp * pi ) ! J·s = kg·m²·s⁻¹ !> Bohr radius real ( wp ), parameter :: bohr = hbar / ( codata % me * codata % c * codata % alpha ) ! m !> Hartree energy real ( wp ), parameter :: hartree = codata % me * codata % c ** 2 * codata % alpha ** 2 ! J = kg·m²·s⁻² !> Conversion factor from bohr to Ångström real ( wp ), public , parameter :: autoaa = bohr * 1e10_wp !> Conversion factor from Ångström to bohr real ( wp ), public , parameter :: aatoau = 1.0_wp / autoaa !> Conversion factor from hartree to electron volts real ( wp ), public , parameter :: autoeV = hartree / codata % e !> Conversion factor from electron volts to hartree real ( wp ), public , parameter :: evtoau = 1.0_wp / autoev !> Coversion factor between calorine and joule real ( wp ), public , parameter :: caltoj = 4.184_wp !> Coversion factor between joule and calorine real ( wp ), public , parameter :: jtocal = 1.0_wp / caltoj !> Conversion from hartree to kJ/mol real ( wp ), public , parameter :: autokj = hartree * codata % na * 1e-3_wp !> Conversion from kJ/mol to hartree real ( wp ), public , parameter :: kjtoau = 1.0_wp / autokj !> Conversion from hartree to kcal/mol real ( wp ), public , parameter :: autokcal = autokJ * Jtocal !> Conversion from kcal/mol to hartree real ( wp ), public , parameter :: kcaltoau = 1.0_wp / autokcal !> Conversion from hartree to reciprocal centimeters real ( wp ), public , parameter :: autorcm = hartree / ( codata % h * codata % c ) * 1e-2_wp !> Conversion from reciprocal centimeters to hartree real ( wp ), public , parameter :: rcmtoau = 1.0_wp / autorcm !> Conversion from hartree to nanometers (wavelength) real ( wp ), public , parameter :: autonm = codata % h * codata % c / hartree * 1e+9_wp !> Conversion from nanometers (wavelength) to hartree real ( wp ), public , parameter :: nmtoau = 1.0_wp / autonm !> Conversion from electron mass (a.u.) to kg real ( wp ), public , parameter :: autokg = codata % me !> Conversion from kg to electron mass (a.u.) real ( wp ), public , parameter :: kgtoau = 1.0_wp / autokg !> Molecular mass per mole (g/mol) to electron mass (a.u.) real ( wp ), public , parameter :: autogmol = codata % me * codata % na * 1e+3_wp !> Electron mass (a.u.) to molecular mass per mole (g/mol) real ( wp ), public , parameter :: gmoltoau = 1.0_wp / autogmol !> Molecular mass per mole (g/mol) to kg real ( wp ), public , parameter :: gmoltokg = gmoltoau * autokg !> kg to molecular mass per mole (g/mol) real ( wp ), public , parameter :: kgtogmol = 1.0_wp / gmoltokg !> Coulomb to atomic charge units real ( wp ), public , parameter :: autoc = codata % e !> Atomic charge units to Coulomb real ( wp ), public , parameter :: ctoau = 1.0_wp / autoc end module mctc_io_convert","tags":"","loc":"sourcefile/convert.f90.html"},{"title":"utils.f90 – MCTC-library","text":"Contents Modules mctc_io_utils Source Code utils.f90 Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. module mctc_io_utils implicit none private public :: getline contains subroutine getline ( unit , line , iostat , iomsg ) !> Formatted IO unit integer , intent ( in ) :: unit !> Line to read character ( len = :), allocatable , intent ( out ) :: line !> Status of operation integer , intent ( out ) :: iostat !> Error message character ( len = :), allocatable , optional :: iomsg integer , parameter :: bufsize = 512 character ( len = bufsize ) :: buffer character ( len = bufsize ) :: msg integer :: size integer :: stat allocate ( character ( len = 0 ) :: line ) do read ( unit , '(a)' , advance = 'no' , iostat = stat , iomsg = msg , size = size ) & & buffer if ( stat > 0 ) exit line = line // buffer (: size ) if ( stat < 0 ) then if ( is_iostat_eor ( stat )) then stat = 0 end if exit end if end do if ( stat /= 0 ) then if ( present ( iomsg )) iomsg = trim ( msg ) end if iostat = stat end subroutine getline end module mctc_io_utils","tags":"","loc":"sourcefile/utils.f90.html"},{"title":"structure.f90 – MCTC-library","text":"Contents Modules mctc_io_structure Source Code structure.f90 Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Basic structure representation of the system of interest module mctc_io_structure use mctc_env_accuracy , only : wp use mctc_io_symbols , only : to_number , to_symbol , symbol_length , get_identity , & & collect_identical use mctc_io_structure_info , only : structure_info , pdb_data , sdf_data implicit none private public :: structure_type , new_structure , new !> Structure representation type :: structure_type !> Number of atoms integer :: nat = 0 !> Number of unique species integer :: nid = 0 !> Number of bonds integer :: nbd = 0 !> Species identifier integer , allocatable :: id (:) !> Atomic number for each species integer , allocatable :: num (:) !> Element symbol for each species character ( len = symbol_length ), allocatable :: sym (:) !> Cartesian coordinates, in Bohr real ( wp ), allocatable :: xyz (:, :) !> Number of unpaired electrons integer :: uhf = 0 !> Total charge real ( wp ) :: charge = 0.0_wp !> Lattice parameters real ( wp ), allocatable :: lattice (:, :) !> Periodic directions logical , allocatable :: periodic (:) !> Bond indices integer , allocatable :: bond (:, :) !> Comment, name or identifier for this structure character ( len = :), allocatable :: comment !> Vendor specific structure annotations type ( structure_info ) :: info = structure_info () !> SDF atomic data annotations type ( sdf_data ), allocatable :: sdf (:) !> PDB atomic data annotations type ( pdb_data ), allocatable :: pdb (:) end type structure_type interface new module procedure :: new_structure module procedure :: new_structure_num module procedure :: new_structure_sym end interface contains !> Constructor for structure representations subroutine new_structure ( self , num , sym , xyz , charge , uhf , lattice , periodic , & & info , bond ) !> Instance of the structure representation type ( structure_type ), intent ( out ) :: self !> Atomic numbers integer , intent ( in ) :: num (:) !> Element symbols character ( len =* ), intent ( in ) :: sym (:) !> Cartesian coordinates real ( wp ), intent ( in ) :: xyz (:, :) !> Total charge real ( wp ), intent ( in ), optional :: charge !> Number of unpaired electrons integer , intent ( in ), optional :: uhf !> Lattice parameters real ( wp ), intent ( in ), optional :: lattice (:, :) !> Periodic directions logical , intent ( in ), optional :: periodic (:) !> Vendor specific structure information type ( structure_info ), intent ( in ), optional :: info !> Bond topology of the system integer , intent ( in ), optional :: bond (:, :) integer :: ndim , iid integer , allocatable :: map (:) ndim = min ( size ( num , 1 ), size ( xyz , 2 ), size ( sym , 1 )) self % nat = ndim allocate ( self % id ( ndim )) allocate ( self % xyz ( 3 , ndim )) if ( present ( lattice )) then self % lattice = lattice end if if ( present ( periodic )) then self % periodic = periodic else if ( present ( lattice )) then allocate ( self % periodic ( 3 )) self % periodic (:) = . true . else allocate ( self % periodic ( 1 )) self % periodic (:) = . false . end if end if call get_identity ( self % nid , self % id , sym ) allocate ( map ( self % nid )) call collect_identical ( self % id , map ) allocate ( self % num ( self % nid )) allocate ( self % sym ( self % nid )) do iid = 1 , self % nid self % num ( iid ) = num ( map ( iid )) self % sym ( iid ) = sym ( map ( iid )) end do self % xyz (:, :) = xyz (:, : ndim ) if ( present ( charge )) then self % charge = charge else self % charge = 0.0_wp end if if ( present ( uhf )) then self % uhf = uhf else self % uhf = 0 end if if ( present ( info )) then self % info = info else self % info = structure_info () end if if ( present ( bond )) then self % nbd = size ( bond , 2 ) self % bond = bond end if end subroutine new_structure !> Simplified constructor for structure representations subroutine new_structure_num ( self , num , xyz , charge , uhf , lattice , periodic , & & info , bond ) !> Instance of the structure representation type ( structure_type ), intent ( out ) :: self !> Atomic numbers integer , intent ( in ) :: num (:) !> Cartesian coordinates real ( wp ), intent ( in ) :: xyz (:, :) !> Total charge real ( wp ), intent ( in ), optional :: charge !> Number of unpaired electrons integer , intent ( in ), optional :: uhf !> Lattice parameters real ( wp ), intent ( in ), optional :: lattice (:, :) !> Periodic directions logical , intent ( in ), optional :: periodic (:) !> Vendor specific structure information type ( structure_info ), intent ( in ), optional :: info !> Bond topology of the system integer , intent ( in ), optional :: bond (:, :) integer :: ndim , iat character ( len = symbol_length ), allocatable :: sym (:) ndim = min ( size ( num , 1 ), size ( xyz , 2 )) allocate ( sym ( ndim )) do iat = 1 , ndim sym ( iat ) = to_symbol ( num ( iat )) end do call new_structure ( self , num , sym , xyz , charge , uhf , lattice , periodic , & & info , bond ) end subroutine new_structure_num !> Simplified constructor for structure representations subroutine new_structure_sym ( self , sym , xyz , charge , uhf , lattice , periodic , & & info , bond ) !> Instance of the structure representation type ( structure_type ), intent ( out ) :: self !> Element symbols character ( len =* ), intent ( in ) :: sym (:) !> Cartesian coordinates real ( wp ), intent ( in ) :: xyz (:, :) !> Total charge real ( wp ), intent ( in ), optional :: charge !> Number of unpaired electrons integer , intent ( in ), optional :: uhf !> Lattice parameters real ( wp ), intent ( in ), optional :: lattice (:, :) !> Periodic directions logical , intent ( in ), optional :: periodic (:) !> Vendor specific structure information type ( structure_info ), intent ( in ), optional :: info !> Bond topology of the system integer , intent ( in ), optional :: bond (:, :) integer :: ndim , iat integer , allocatable :: num (:) ndim = min ( size ( sym , 1 ), size ( xyz , 2 )) allocate ( num ( ndim )) do iat = 1 , ndim num ( iat ) = to_number ( sym ( iat )) end do call new_structure ( self , num , sym , xyz , charge , uhf , lattice , periodic , & & info , bond ) end subroutine new_structure_sym end module mctc_io_structure","tags":"","loc":"sourcefile/structure.f90.html"},{"title":"constants.f90 – MCTC-library","text":"Contents Modules mctc_io_constants Source Code constants.f90 Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Numerical constants module mctc_io_constants use mctc_env_accuracy , only : wp implicit none private public :: pi , codata !> Ratio between a circles diameter and its circumfence real ( wp ), parameter :: pi = 3.1415926535897932384626433832795029_wp !> Natural constants defining the SI unit base type :: enum_codata !> Planck's constant real ( wp ) :: h = 6.6260715e-34_wp ! J·s = kg·m²·s⁻¹ !> Speed of light in vacuum real ( wp ) :: c = 29979245 8.0_wp ! m·s⁻¹ !> Boltzmann's constant real ( wp ) :: kb = 1.380649e-23_wp ! J·K⁻¹ = kg·m²·s⁻²·K⁻¹ !> Avogadro's number real ( wp ) :: NA = 6.02214076e23_wp ! mol⁻¹ !> Elementary charge real ( wp ) :: e = 1.602176634e-19_wp ! C !> fine structure constant (CODATA2018) real ( wp ) :: alpha = 1.0_wp / 13 7.035999046_wp ! dimensionless !> electron rest mass real ( wp ) :: me = 9.10938356e-31_wp ! kg end type enum_codata !> Actual collection of natural constants type ( enum_codata ), parameter :: codata = enum_codata () end module mctc_io_constants","tags":"","loc":"sourcefile/constants.f90.html"},{"title":"resize.f90 – MCTC-library","text":"Contents Modules mctc_io_resize Source Code resize.f90 Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Reallocation implementation for resizing arrays module mctc_io_resize use mctc_env_accuracy , only : wp implicit none private public :: resize !> Overloaded resize interface interface resize module procedure :: resize_char module procedure :: resize_int module procedure :: resize_real module procedure :: resize_real_2d end interface resize !> Initial size for dynamic sized arrays integer , parameter :: initial_size = 64 contains !> Reallocate list of integers pure subroutine resize_int ( var , n ) !> Instance of the array to be resized integer , allocatable , intent ( inout ) :: var (:) !> Dimension of the final array size integer , intent ( in ), optional :: n integer , allocatable :: tmp (:) integer :: this_size , new_size if ( allocated ( var )) then this_size = size ( var , 1 ) call move_alloc ( var , tmp ) else this_size = initial_size end if if ( present ( n )) then new_size = n else new_size = this_size + this_size / 2 + 1 end if allocate ( var ( new_size )) if ( allocated ( tmp )) then this_size = min ( size ( tmp , 1 ), size ( var , 1 )) var (: this_size ) = tmp (: this_size ) deallocate ( tmp ) end if end subroutine resize_int !> Reallocate list of characters pure subroutine resize_char ( var , n ) !> Instance of the array to be resized character ( len =* ), allocatable , intent ( inout ) :: var (:) !> Dimension of the final array size integer , intent ( in ), optional :: n character ( len = :), allocatable :: tmp (:) integer :: this_size , new_size if ( allocated ( var )) then this_size = size ( var , 1 ) call move_alloc ( var , tmp ) else this_size = initial_size end if if ( present ( n )) then new_size = n else new_size = this_size + this_size / 2 + 1 end if allocate ( var ( new_size )) if ( allocated ( tmp )) then this_size = min ( size ( tmp , 1 ), size ( var , 1 )) var (: this_size ) = tmp (: this_size ) deallocate ( tmp ) end if end subroutine resize_char !> Reallocate list of reals pure subroutine resize_real ( var , n ) !> Instance of the array to be resized real ( wp ), allocatable , intent ( inout ) :: var (:) !> Dimension of the final array size integer , intent ( in ), optional :: n real ( wp ), allocatable :: tmp (:) integer :: this_size , new_size if ( allocated ( var )) then this_size = size ( var , 1 ) call move_alloc ( var , tmp ) else this_size = initial_size end if if ( present ( n )) then new_size = n else new_size = this_size + this_size / 2 + 1 end if allocate ( var ( new_size )) if ( allocated ( tmp )) then this_size = min ( size ( tmp , 1 ), size ( var , 1 )) var (: this_size ) = tmp (: this_size ) deallocate ( tmp ) end if end subroutine resize_real !> Reallocate list of reals pure subroutine resize_real_2d ( var , n ) !> Instance of the array to be resized real ( wp ), allocatable , intent ( inout ) :: var (:,:) !> Dimension of the final array size integer , intent ( in ), optional :: n real ( wp ), allocatable :: tmp (:,:) integer :: order , this_size , new_size if ( allocated ( var )) then order = size ( var , 1 ) this_size = size ( var , 2 ) call move_alloc ( var , tmp ) else order = 3 this_size = initial_size end if if ( present ( n )) then new_size = n else new_size = this_size + this_size / 2 + 1 end if allocate ( var ( order , new_size )) if ( allocated ( tmp )) then this_size = min ( size ( tmp , 2 ), size ( var , 2 )) var (:, : this_size ) = tmp (:, : this_size ) deallocate ( tmp ) end if end subroutine resize_real_2d end module mctc_io_resize","tags":"","loc":"sourcefile/resize.f90.html"},{"title":"read.f90 – MCTC-library","text":"Contents Modules mctc_io_read Source Code read.f90 Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. module mctc_io_read use mctc_env_error , only : error_type , fatal_error use mctc_io_filetype , only : filetype , get_filetype use mctc_io_read_ctfile , only : read_molfile , read_sdf use mctc_io_read_gaussian , only : read_gaussian_external use mctc_io_read_genformat , only : read_genformat use mctc_io_read_pdb , only : read_pdb use mctc_io_read_turbomole , only : read_coord use mctc_io_read_vasp , only : read_vasp use mctc_io_read_xyz , only : read_xyz use mctc_io_structure , only : structure_type , new_structure implicit none private public :: read_structure public :: structure_reader , get_structure_reader interface read_structure module procedure :: read_structure_from_file module procedure :: read_structure_from_unit end interface read_structure abstract interface !> Read molecular structure data from formatted unit subroutine structure_reader ( self , unit , error ) import :: structure_type , error_type !> Instance of the molecular structure data type ( structure_type ), intent ( out ) :: self !> File handle integer , intent ( in ) :: unit !> Error handling type ( error_type ), allocatable , intent ( out ) :: error end subroutine structure_reader end interface contains subroutine read_structure_from_file ( self , file , error , format ) !> Instance of the molecular structure data type ( structure_type ), intent ( out ) :: self !> Name of the file to read character ( len =* ), intent ( in ) :: file !> Error handling type ( error_type ), allocatable , intent ( out ) :: error !> File type format hint integer , intent ( in ), optional :: format logical :: exist integer :: unit , stat , ftype inquire ( file = file , exist = exist ) if (. not . exist ) then call fatal_error ( error , \"File '\" // file // \"' cannot be found\" ) return end if open ( file = file , newunit = unit , status = 'old' , iostat = stat ) if ( stat /= 0 ) then call fatal_error ( error , \"Cannot open '\" // file // \"'\" ) return end if if ( present ( format )) then ftype = format else ftype = get_filetype ( file ) end if call read_structure ( self , unit , ftype , error ) close ( unit ) end subroutine read_structure_from_file subroutine read_structure_from_unit ( self , unit , ftype , error ) !> Instance of the molecular structure data type ( structure_type ), intent ( out ) :: self !> File handle integer , intent ( in ) :: unit !> File type to read integer , intent ( in ) :: ftype !> Error handling type ( error_type ), allocatable , intent ( out ) :: error procedure ( structure_reader ), pointer :: reader call get_structure_reader ( reader , ftype ) if (. not . associated ( reader )) then call fatal_error ( error , \"Cannot read structure from unknown file format\" ) return end if call reader ( self , unit , error ) end subroutine read_structure_from_unit !> Retrieve reader for corresponding file type subroutine get_structure_reader ( reader , ftype ) !> Reader for the specified file type procedure ( structure_reader ), pointer , intent ( out ) :: reader !> File type to read integer , intent ( in ) :: ftype nullify ( reader ) select case ( ftype ) case ( filetype % xyz ) reader => read_xyz case ( filetype % molfile ) reader => read_molfile case ( filetype % pdb ) reader => read_pdb case ( filetype % gen ) reader => read_genformat case ( filetype % sdf ) reader => read_sdf case ( filetype % vasp ) reader => read_vasp case ( filetype % tmol ) reader => read_coord case ( filetype % gaussian ) reader => read_gaussian_external end select end subroutine get_structure_reader end module mctc_io_read","tags":"","loc":"sourcefile/read.f90.html"},{"title":"write.f90 – MCTC-library","text":"Contents Modules mctc_io_write Source Code write.f90 Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. module mctc_io_write use mctc_env_error , only : error_type , fatal_error use mctc_io_filetype , only : filetype , get_filetype use mctc_io_write_ctfile , only : write_molfile , write_sdf use mctc_io_write_gaussian , only : write_gaussian_external use mctc_io_write_genformat , only : write_genformat use mctc_io_write_pdb , only : write_pdb use mctc_io_write_turbomole , only : write_coord use mctc_io_write_vasp , only : write_vasp use mctc_io_write_xyz , only : write_xyz use mctc_io_structure , only : structure_type , new_structure implicit none private public :: write_structure interface write_structure module procedure :: write_structure_to_file module procedure :: write_structure_to_unit end interface write_structure contains subroutine write_structure_to_file ( self , file , error , format ) !> Instance of the molecular structure data class ( structure_type ), intent ( in ) :: self !> Name of the file to read character ( len =* ), intent ( in ) :: file !> Error handling type ( error_type ), allocatable , intent ( out ) :: error !> File type format hint integer , intent ( in ), optional :: format integer :: unit , ftype , stat open ( file = file , newunit = unit , iostat = stat ) if ( stat /= 0 ) then call fatal_error ( error , \"Cannot open '\" // file // \"'\" ) return end if if ( present ( format )) then ftype = format else ftype = get_filetype ( file ) end if ! Unknown file type is inacceptable in this situation, ! try to figure something at least something out if ( ftype == filetype % unknown ) then if ( any ( self % periodic )) then ftype = filetype % vasp else if ( allocated ( self % sdf )) then ftype = filetype % sdf else if ( allocated ( self % pdb )) then ftype = filetype % pdb else ftype = filetype % xyz end if end if call write_structure ( self , unit , ftype , error ) close ( unit ) end subroutine write_structure_to_file subroutine write_structure_to_unit ( self , unit , ftype , error ) !> Instance of the molecular structure data class ( structure_type ), intent ( in ) :: self !> File handle integer , intent ( in ) :: unit !> File type to read integer , intent ( in ) :: ftype !> Error handling type ( error_type ), allocatable , intent ( out ) :: error select case ( ftype ) case default call fatal_error ( error , \"Cannot write unknown file format\" ) case ( filetype % xyz ) call write_xyz ( self , unit ) case ( filetype % molfile ) call write_molfile ( self , unit ) case ( filetype % pdb ) call write_pdb ( self , unit ) case ( filetype % gen ) call write_genformat ( self , unit ) case ( filetype % sdf ) call write_sdf ( self , unit ) case ( filetype % vasp ) call write_vasp ( self , unit ) case ( filetype % tmol ) call write_coord ( self , unit ) case ( filetype % gaussian ) call write_gaussian_external ( self , unit ) end select end subroutine write_structure_to_unit end module mctc_io_write","tags":"","loc":"sourcefile/write.f90.html"},{"title":"math.f90 – MCTC-library","text":"Contents Modules mctc_io_math Source Code math.f90 Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Simple algebraic functions module mctc_io_math use mctc_env_accuracy , only : wp use mctc_io_constants , only : pi implicit none private public :: matdet_3x3 , matinv_3x3 , crossprod , eigval_3x3 , eigvec_3x3 real ( wp ), parameter :: twothirdpi = 2.0_wp * pi / 3.0_wp contains !> Performs a direct calculation of the inverse of a 3×3 matrix. ! !  reference: http://fortranwiki.org/fortran/show/Matrix+inversion pure function matinv_3x3 ( a ) result ( b ) !> Matrix real ( wp ), intent ( in ) :: a ( 3 , 3 ) !> Inverse matrix real ( wp ) :: b ( 3 , 3 ) real ( wp ) :: detinv ! Calculate the inverse determinant of the matrix detinv = 1.0_wp / matdet_3x3 ( a ) ! Calculate the inverse of the matrix b ( 1 , 1 ) = + detinv * ( a ( 2 , 2 ) * a ( 3 , 3 ) - a ( 2 , 3 ) * a ( 3 , 2 )) b ( 2 , 1 ) = - detinv * ( a ( 2 , 1 ) * a ( 3 , 3 ) - a ( 2 , 3 ) * a ( 3 , 1 )) b ( 3 , 1 ) = + detinv * ( a ( 2 , 1 ) * a ( 3 , 2 ) - a ( 2 , 2 ) * a ( 3 , 1 )) b ( 1 , 2 ) = - detinv * ( a ( 1 , 2 ) * a ( 3 , 3 ) - a ( 1 , 3 ) * a ( 3 , 2 )) b ( 2 , 2 ) = + detinv * ( a ( 1 , 1 ) * a ( 3 , 3 ) - a ( 1 , 3 ) * a ( 3 , 1 )) b ( 3 , 2 ) = - detinv * ( a ( 1 , 1 ) * a ( 3 , 2 ) - a ( 1 , 2 ) * a ( 3 , 1 )) b ( 1 , 3 ) = + detinv * ( a ( 1 , 2 ) * a ( 2 , 3 ) - a ( 1 , 3 ) * a ( 2 , 2 )) b ( 2 , 3 ) = - detinv * ( a ( 1 , 1 ) * a ( 2 , 3 ) - a ( 1 , 3 ) * a ( 2 , 1 )) b ( 3 , 3 ) = + detinv * ( a ( 1 , 1 ) * a ( 2 , 2 ) - a ( 1 , 2 ) * a ( 2 , 1 )) end function matinv_3x3 !> Determinat of 3×3 matrix pure function matdet_3x3 ( a ) result ( det ) !> Matrix real ( wp ), intent ( in ) :: a ( 3 , 3 ) !> Determinant real ( wp ) :: det det = a ( 1 , 1 ) * a ( 2 , 2 ) * a ( 3 , 3 ) & & - a ( 1 , 1 ) * a ( 2 , 3 ) * a ( 3 , 2 ) & & - a ( 1 , 2 ) * a ( 2 , 1 ) * a ( 3 , 3 ) & & + a ( 1 , 2 ) * a ( 2 , 3 ) * a ( 3 , 1 ) & & + a ( 1 , 3 ) * a ( 2 , 1 ) * a ( 3 , 2 ) & & - a ( 1 , 3 ) * a ( 2 , 2 ) * a ( 3 , 1 ) end function matdet_3x3 !> Implements the cross/vector product between two 3D vectors pure function crossprod ( a , b ) result ( c ) !> First vector real ( wp ), intent ( in ) :: a ( 3 ) !> Second vector real ( wp ), intent ( in ) :: b ( 3 ) !> Orthogonal vector real ( wp ) :: c ( 3 ) c ( 1 ) = a ( 2 ) * b ( 3 ) - b ( 2 ) * a ( 3 ) c ( 2 ) = a ( 3 ) * b ( 1 ) - b ( 3 ) * a ( 1 ) c ( 3 ) = a ( 1 ) * b ( 2 ) - b ( 1 ) * a ( 2 ) end function crossprod !> Calculates eigenvalues based on the trigonometric solution of A = pB + qI pure subroutine eigval_3x3 ( a , w ) !> The symmetric input matrix real ( wp ), intent ( in ) :: a ( 3 , 3 ) !> Contains eigenvalues on exit real ( wp ), intent ( out ) :: w ( 3 ) real ( wp ) :: q , p , r r = a ( 1 , 2 ) * a ( 1 , 2 ) + a ( 1 , 3 ) * a ( 1 , 3 ) + a ( 2 , 3 ) * a ( 2 , 3 ) q = ( a ( 1 , 1 ) + a ( 2 , 2 ) + a ( 3 , 3 )) / 3.0_wp w ( 1 ) = a ( 1 , 1 ) - q w ( 2 ) = a ( 2 , 2 ) - q w ( 3 ) = a ( 3 , 3 ) - q p = sqrt (( w ( 1 ) * w ( 1 ) + w ( 2 ) * w ( 2 ) + w ( 3 ) * w ( 3 ) + 2 * r ) / 6.0_wp ) r = ( w ( 1 ) * ( w ( 2 ) * w ( 3 ) - a ( 2 , 3 ) * a ( 2 , 3 )) & & - a ( 1 , 2 ) * ( a ( 1 , 2 ) * w ( 3 ) - a ( 2 , 3 ) * a ( 1 , 3 )) & & + a ( 1 , 3 ) * ( a ( 1 , 2 ) * a ( 2 , 3 ) - w ( 2 ) * a ( 1 , 3 ))) / ( p * p * p ) * 0.5_wp if ( r <= - 1.0_wp ) then r = 0.5_wp * twothirdpi else if ( r >= 1.0_wp ) then r = 0.0_wp else r = acos ( r ) / 3.0_wp end if w ( 3 ) = q + 2 * p * cos ( r ) w ( 1 ) = q + 2 * p * cos ( r + twothirdpi ) w ( 2 ) = 3 * q - w ( 1 ) - w ( 3 ) end subroutine eigval_3x3 !> Calculates eigenvector using an analytical method based on vector cross !  products. pure subroutine eigvec_3x3 ( a , w , q ) real ( wp ), intent ( inout ) :: a ( 3 , 3 ) real ( wp ), intent ( out ) :: w ( 3 ) real ( wp ), intent ( out ) :: q ( 3 , 3 ) real ( wp ), parameter :: eps = epsilon ( 1.0_wp ) real ( wp ) norm , n1 , n2 , n3 , precon integer :: i w ( 1 ) = max ( abs ( a ( 1 , 1 )), abs ( a ( 1 , 2 ))) w ( 2 ) = max ( abs ( a ( 1 , 3 )), abs ( a ( 2 , 2 ))) w ( 3 ) = max ( abs ( a ( 2 , 3 )), abs ( a ( 3 , 3 ))) precon = max ( w ( 1 ), max ( w ( 2 ), w ( 3 ))) ! null matrix if ( precon < eps ) then w ( 1 ) = 0.0_wp w ( 2 ) = 0.0_wp w ( 3 ) = 0.0_wp q ( 1 , 1 ) = 1.0_wp q ( 2 , 2 ) = 1.0_wp q ( 3 , 3 ) = 1.0_wp q ( 1 , 2 ) = 0.0_wp q ( 1 , 3 ) = 0.0_wp q ( 2 , 3 ) = 0.0_wp q ( 2 , 1 ) = 0.0_wp q ( 3 , 1 ) = 0.0_wp q ( 3 , 2 ) = 0.0_wp return end if norm = 1.0_wp / precon a ( 1 , 1 ) = a ( 1 , 1 ) * norm a ( 1 , 2 ) = a ( 1 , 2 ) * norm a ( 2 , 2 ) = a ( 2 , 2 ) * norm a ( 1 , 3 ) = a ( 1 , 3 ) * norm a ( 2 , 3 ) = a ( 2 , 3 ) * norm a ( 3 , 3 ) = a ( 3 , 3 ) * norm ! Calculate eigenvalues call eigval_3x3 ( a , w ) ! Compute first eigenvector a ( 1 , 1 ) = a ( 1 , 1 ) - w ( 1 ) a ( 2 , 2 ) = a ( 2 , 2 ) - w ( 1 ) a ( 3 , 3 ) = a ( 3 , 3 ) - w ( 1 ) q ( 1 , 1 ) = a ( 1 , 2 ) * a ( 2 , 3 ) - a ( 1 , 3 ) * a ( 2 , 2 ) q ( 2 , 1 ) = a ( 1 , 3 ) * a ( 1 , 2 ) - a ( 1 , 1 ) * a ( 2 , 3 ) q ( 3 , 1 ) = a ( 1 , 1 ) * a ( 2 , 2 ) - a ( 1 , 2 ) * a ( 1 , 2 ) q ( 1 , 2 ) = a ( 1 , 2 ) * a ( 3 , 3 ) - a ( 1 , 3 ) * a ( 2 , 3 ) q ( 2 , 2 ) = a ( 1 , 3 ) * a ( 1 , 3 ) - a ( 1 , 1 ) * a ( 3 , 3 ) q ( 3 , 2 ) = a ( 1 , 1 ) * a ( 2 , 3 ) - a ( 1 , 2 ) * a ( 1 , 3 ) q ( 1 , 3 ) = a ( 2 , 2 ) * a ( 3 , 3 ) - a ( 2 , 3 ) * a ( 2 , 3 ) q ( 2 , 3 ) = a ( 2 , 3 ) * a ( 1 , 3 ) - a ( 1 , 2 ) * a ( 3 , 3 ) q ( 3 , 3 ) = a ( 1 , 2 ) * a ( 2 , 3 ) - a ( 2 , 2 ) * a ( 1 , 3 ) n1 = q ( 1 , 1 ) * q ( 1 , 1 ) + q ( 2 , 1 ) * q ( 2 , 1 ) + q ( 3 , 1 ) * q ( 3 , 1 ) n2 = q ( 1 , 2 ) * q ( 1 , 2 ) + q ( 2 , 2 ) * q ( 2 , 2 ) + q ( 3 , 2 ) * q ( 3 , 2 ) n3 = q ( 1 , 3 ) * q ( 1 , 3 ) + q ( 2 , 3 ) * q ( 2 , 3 ) + q ( 3 , 3 ) * q ( 3 , 3 ) norm = n1 i = 1 if ( n2 > norm ) then i = 2 norm = n1 end if if ( n3 > norm ) then i = 3 end if if ( i == 1 ) then norm = sqrt ( 1.0_wp / n1 ) q ( 1 , 1 ) = q ( 1 , 1 ) * norm q ( 2 , 1 ) = q ( 2 , 1 ) * norm q ( 3 , 1 ) = q ( 3 , 1 ) * norm else if ( i == 2 ) then norm = sqrt ( 1.0_wp / n2 ) q ( 1 , 1 ) = q ( 1 , 2 ) * norm q ( 2 , 1 ) = q ( 2 , 2 ) * norm q ( 3 , 1 ) = q ( 3 , 2 ) * norm else norm = sqrt ( 1.0_wp / n3 ) q ( 1 , 1 ) = q ( 1 , 3 ) * norm q ( 2 , 1 ) = q ( 2 , 3 ) * norm q ( 3 , 1 ) = q ( 3 , 3 ) * norm end if ! Robustly compute a right-hand orthonormal set (ev1, u, v) if ( abs ( q ( 1 , 1 )) > abs ( q ( 2 , 1 ))) then norm = sqrt ( 1.0_wp / ( q ( 1 , 1 ) * q ( 1 , 1 ) + q ( 3 , 1 ) * q ( 3 , 1 ))) q ( 1 , 2 ) = - q ( 3 , 1 ) * norm q ( 2 , 2 ) = 0.0_wp q ( 3 , 2 ) = + q ( 1 , 1 ) * norm else norm = sqrt ( 1.0_wp / ( q ( 2 , 1 ) * q ( 2 , 1 ) + q ( 3 , 1 ) * q ( 3 , 1 ))) q ( 1 , 2 ) = 0.0_wp q ( 2 , 2 ) = + q ( 3 , 1 ) * norm q ( 3 , 2 ) = - q ( 2 , 1 ) * norm end if q ( 1 , 3 ) = q ( 2 , 1 ) * q ( 3 , 2 ) - q ( 3 , 1 ) * q ( 2 , 2 ) q ( 2 , 3 ) = q ( 3 , 1 ) * q ( 1 , 2 ) - q ( 1 , 1 ) * q ( 3 , 2 ) q ( 3 , 3 ) = q ( 1 , 1 ) * q ( 2 , 2 ) - q ( 2 , 1 ) * q ( 1 , 2 ) ! Reset A a ( 1 , 1 ) = a ( 1 , 1 ) + w ( 1 ) a ( 2 , 2 ) = a ( 2 , 2 ) + w ( 1 ) a ( 3 , 3 ) = a ( 3 , 3 ) + w ( 1 ) ! A*U n1 = a ( 1 , 1 ) * q ( 1 , 2 ) + a ( 1 , 2 ) * q ( 2 , 2 ) + a ( 1 , 3 ) * q ( 3 , 2 ) n2 = a ( 1 , 2 ) * q ( 1 , 2 ) + a ( 2 , 2 ) * q ( 2 , 2 ) + a ( 2 , 3 ) * q ( 3 , 2 ) n3 = a ( 1 , 3 ) * q ( 1 , 2 ) + a ( 2 , 3 ) * q ( 2 , 2 ) + a ( 3 , 3 ) * q ( 3 , 2 ) ! A*V, note out of order computation a ( 3 , 3 ) = a ( 1 , 3 ) * q ( 1 , 3 ) + a ( 2 , 3 ) * q ( 2 , 3 ) + a ( 3 , 3 ) * q ( 3 , 3 ) a ( 1 , 3 ) = a ( 1 , 1 ) * q ( 1 , 3 ) + a ( 1 , 2 ) * q ( 2 , 3 ) + a ( 1 , 3 ) * q ( 3 , 3 ) a ( 2 , 3 ) = a ( 1 , 2 ) * q ( 1 , 3 ) + a ( 2 , 2 ) * q ( 2 , 3 ) + a ( 2 , 3 ) * q ( 3 , 3 ) ! UT*(A*U) - l2*E n1 = q ( 1 , 2 ) * n1 + q ( 2 , 2 ) * n2 + q ( 3 , 2 ) * n3 - w ( 2 ) ! UT*(A*V) n2 = q ( 1 , 2 ) * a ( 1 , 3 ) + q ( 2 , 2 ) * a ( 2 , 3 ) + q ( 3 , 2 ) * a ( 3 , 3 ) ! VT*(A*V) - l2*E n3 = q ( 1 , 3 ) * a ( 1 , 3 ) + q ( 2 , 3 ) * a ( 2 , 3 ) + q ( 3 , 3 ) * a ( 3 , 3 ) - w ( 2 ) if ( abs ( n1 ) >= abs ( n3 )) then norm = max ( abs ( n1 ), abs ( n2 )) if ( norm > eps ) then if ( abs ( n1 ) >= abs ( n2 )) then n2 = n2 / n1 n1 = sqrt ( 1.0_wp / ( 1.0_wp + n2 * n2 )) n2 = n2 * n1 else n1 = n1 / n2 n2 = sqrt ( 1.0_wp / ( 1.0_wp + n1 * n1 )) n1 = n1 * n2 end if q ( 1 , 2 ) = n2 * q ( 1 , 2 ) - n1 * q ( 1 , 3 ) q ( 2 , 2 ) = n2 * q ( 2 , 2 ) - n1 * q ( 2 , 3 ) q ( 3 , 2 ) = n2 * q ( 3 , 2 ) - n1 * q ( 3 , 3 ) end if else norm = max ( abs ( n3 ), abs ( n2 )) if ( norm > eps ) then if ( abs ( n3 ) >= abs ( n2 )) then n2 = n2 / n3 n3 = sqrt ( 1.0_wp / ( 1.0_wp + n2 * n2 )) n2 = n2 * n3 else n3 = n3 / n2 n2 = sqrt ( 1.0_wp / ( 1.0_wp + n3 * n3 )) n3 = n3 * n2 end if q ( 1 , 2 ) = n3 * q ( 1 , 2 ) - n2 * q ( 1 , 3 ) q ( 2 , 2 ) = n3 * q ( 2 , 2 ) - n2 * q ( 2 , 3 ) q ( 3 , 2 ) = n3 * q ( 3 , 2 ) - n2 * q ( 3 , 3 ) end if end if ! Calculate third eigenvector from cross product q ( 1 , 3 ) = q ( 2 , 1 ) * q ( 3 , 2 ) - q ( 3 , 1 ) * q ( 2 , 2 ) q ( 2 , 3 ) = q ( 3 , 1 ) * q ( 1 , 2 ) - q ( 1 , 1 ) * q ( 3 , 2 ) q ( 3 , 3 ) = q ( 1 , 1 ) * q ( 2 , 2 ) - q ( 2 , 1 ) * q ( 1 , 2 ) w ( 1 ) = w ( 1 ) * precon w ( 2 ) = w ( 2 ) * precon w ( 3 ) = w ( 3 ) * precon end subroutine eigvec_3x3 end module mctc_io_math","tags":"","loc":"sourcefile/math.f90.html"},{"title":"info.f90 – MCTC-library","text":"Contents Modules mctc_io_structure_info Source Code info.f90 Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. module mctc_io_structure_info use mctc_env_accuracy , only : wp implicit none private public :: pdb_data , sdf_data , structure_info public :: resize !> Atomic pdb data type. !> !> keeps information from PDB input that is currently not used by the !> caller program (like residues or chains) but is needed to write !> the PDB output eventually !> !>     ATOM   2461  HA3 GLY A 153     -10.977  -7.661   2.011  1.00  0.00           H !>     TER    2462      GLY A 153 !>     a6----i5---xa4--aa3-xai4--axxxf8.3----f8.3----f8.3----f6.2--f6.2--xxxxxxa4--a2a2 !>     HETATM 2463  CHA HEM A 154       9.596 -13.100  10.368  1.00  0.00           C type :: pdb_data logical :: het = . false . integer :: charge = 0 integer :: residue_number = 0 character ( len = 4 ) :: name = ' ' character ( len = 1 ) :: loc = ' ' character ( len = 3 ) :: residue = ' ' character ( len = 1 ) :: chains = ' ' character ( len = 1 ) :: code = ' ' character ( len = 4 ) :: segid = ' ' end type pdb_data !> SDF atomic data. !> !> We only support some entries, the rest is simply dropped. !> the format is: ddcccssshhhbbbvvvHHHrrriiimmmnnneee type :: sdf_data integer :: isotope = 0 !< d field integer :: charge = 0 !< c field integer :: hydrogens = 0 !< h field integer :: valence = 0 !< v field end type sdf_data !> structure input info !> !> contains informations from different input file formats type :: structure_info !> Vasp coordinate scaling information real ( wp ) :: scale = 1.0_wp !> Vasp selective dynamics keyword is present logical :: selective = . false . !> SDF 2D structure present logical :: two_dimensional = . false . !> SDF hydrogen query present or PDB without hydrogen atoms found logical :: missing_hydrogen = . false . !> Periodic coordinates should use preferrably cartesian coordinates logical :: cartesian = . true . !> Lattice information should use preferrably lattice vectors logical :: lattice = . true . !> Unit of the lattice vectors should be in Angstrom if possible logical :: angs_lattice = . false . !> Unit of the atomic coordinates should be in Angstrom if possible logical :: angs_coord = . false . end type structure_info interface resize module procedure resize_pdb_data end interface contains subroutine resize_pdb_data ( var , n ) type ( pdb_data ), allocatable , intent ( inout ) :: var (:) integer , intent ( in ), optional :: n type ( pdb_data ), allocatable :: tmp (:) integer :: length , current_length current_length = size ( var ) if ( current_length > 0 ) then if ( present ( n )) then if ( n <= current_length ) return length = n else length = current_length + current_length / 2 + 1 endif allocate ( tmp ( length ), source = pdb_data ()) tmp (: current_length ) = var (: current_length ) deallocate ( var ) call move_alloc ( tmp , var ) else if ( present ( n )) then length = n else length = 64 endif allocate ( var ( length ), source = pdb_data ()) endif end subroutine resize_pdb_data end module mctc_io_structure_info","tags":"","loc":"sourcefile/info.f90.html"},{"title":"genformat.f90 – MCTC-library","text":"Contents Modules mctc_io_write_genformat Source Code genformat.f90 Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. module mctc_io_write_genformat use mctc_env_accuracy , only : wp use mctc_io_convert , only : autoaa use mctc_io_math , only : matinv_3x3 use mctc_io_symbols , only : to_symbol use mctc_io_structure , only : structure_type implicit none private public :: write_genformat contains subroutine write_genformat ( mol , unit ) class ( structure_type ), intent ( in ) :: mol integer , intent ( in ) :: unit integer :: iat , izp real ( wp ), parameter :: zero3 ( 3 ) = 0.0_wp real ( wp ), allocatable :: inv_lat (:, :) real ( wp ), allocatable :: abc (:, :) write ( unit , '(i0, 1x)' , advance = 'no' ) mol % nat if (. not . any ( mol % periodic )) then write ( unit , '(\"C\")' ) ! cluster else if ( mol % info % cartesian ) then write ( unit , '(\"S\")' ) ! supercell else write ( unit , '(\"F\")' ) ! fractional endif endif do izp = 1 , mol % nid write ( unit , '(1x, a)' , advance = 'no' ) trim ( mol % sym ( izp )) enddo write ( unit , '(a)' ) if (. not . any ( mol % periodic ) . or . mol % info % cartesian ) then ! now write the cartesian coordinates do iat = 1 , mol % nat write ( unit , '(2i5, 3es24.14)' ) iat , mol % id ( iat ), mol % xyz (:, iat ) * autoaa enddo else inv_lat = matinv_3x3 ( mol % lattice ) abc = matmul ( inv_lat , mol % xyz ) ! now write the fractional coordinates do iat = 1 , mol % nat write ( unit , '(2i5, 3es24.15)' ) iat , mol % id ( iat ), abc (:, iat ) enddo endif if ( any ( mol % periodic )) then ! scaling factor for lattice parameters is always one write ( unit , '(3f20.14)' ) zero3 ! write the lattice parameters write ( unit , '(3f20.14)' ) mol % lattice (:, :) * autoaa endif end subroutine write_genformat end module mctc_io_write_genformat","tags":"","loc":"sourcefile/genformat.f90.html"},{"title":"pdb.f90 – MCTC-library","text":"Contents Modules mctc_io_write_pdb Source Code pdb.f90 Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. module mctc_io_write_pdb use mctc_env_accuracy , only : wp use mctc_io_convert , only : autoaa use mctc_io_structure , only : structure_type implicit none private public :: write_pdb contains subroutine write_pdb ( mol , unit , number ) type ( structure_type ), intent ( in ) :: mol integer , intent ( in ) :: unit integer , intent ( in ), optional :: number character ( len = 6 ) :: w1 character ( len = 4 ) :: sym character ( len = 2 ) :: a_charge character ( len = 1 ) :: last_chain logical :: last_het integer :: offset , iat , jat real ( wp ) :: xyz ( 3 ) character ( len =* ), parameter :: pdb_format = & & '(a6,i5,1x,a4,a1,a3,1x,a1,i4,a1,3x,3f8.3,2f6.2,6x,a4,a2,a2)' if ( present ( number )) write ( unit , '(\"MODEL \",4x,i4)' ) number if ( allocated ( mol % pdb )) then offset = 0 last_chain = mol % pdb ( 1 )% chains last_het = mol % pdb ( 1 )% het do iat = 1 , mol % nat ! handle the terminator if ( mol % pdb ( iat )% het . neqv . last_het ) then write ( unit , '(\"TER   \",i5,6x,a3,1x,a1,i4)' ) iat + offset , & & mol % pdb ( iat - 1 )% residue , last_chain , mol % pdb ( iat )% residue_number last_het = . not . last_het offset = offset + 1 else if ( mol % pdb ( iat )% chains /= last_chain ) then write ( unit , '(\"TER   \",i5,6x,a3,1x,a1,i4)' ) iat + offset , & & mol % pdb ( iat - 1 )% residue , last_chain , mol % pdb ( iat )% residue_number offset = offset + 1 endif jat = iat + offset if ( mol % pdb ( iat )% het ) then w1 = \"HETATM\" else w1 = \"ATOM  \" endif sym = adjustr ( mol % sym ( mol % id ( iat ))( 1 : 2 )) xyz = mol % xyz (:, iat ) * autoaa if ( mol % pdb ( iat )% charge < 0 ) then write ( a_charge , '(i1,\"-\")' ) abs ( mol % pdb ( iat )% charge ) else if ( mol % pdb ( iat )% charge > 0 ) then write ( a_charge , '(i1,\"+\")' ) abs ( mol % pdb ( iat )% charge ) else a_charge = '  ' endif write ( unit , pdb_format ) & & w1 , jat , mol % pdb ( iat )% name , mol % pdb ( iat )% loc , & & mol % pdb ( iat )% residue , mol % pdb ( iat )% chains , mol % pdb ( iat )% residue_number , & & mol % pdb ( iat )% code , xyz , 1.0_wp , 0.0_wp , mol % pdb ( iat )% segid , & & sym , a_charge enddo else do iat = 1 , mol % nat w1 = \"HETATM\" sym = adjustr ( mol % sym ( mol % id ( iat ))( 1 : 2 )) xyz = mol % xyz (:, iat ) * autoaa a_charge = '  ' write ( unit , pdb_format ) & & w1 , iat , sym , \" \" , & & \"UNK\" , \"A\" , 1 , \" \" , xyz , 1.0_wp , 0.0_wp , \"    \" , & & sym , \"  \" enddo end if if ( present ( number )) then write ( unit , '(\"ENDMDL\")' ) else write ( unit , '(\"END\")' ) endif end subroutine write_pdb end module mctc_io_write_pdb","tags":"","loc":"sourcefile/pdb.f90.html"},{"title":"ctfile.f90 – MCTC-library","text":"Contents Modules mctc_io_write_ctfile Source Code ctfile.f90 Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. module mctc_io_write_ctfile use mctc_env_accuracy , only : wp use mctc_io_convert , only : autoaa use mctc_io_structure , only : structure_type implicit none private public :: write_molfile , write_sdf contains subroutine write_sdf ( self , unit , energy , gnorm ) class ( structure_type ), intent ( in ) :: self integer , intent ( in ) :: unit real ( wp ), intent ( in ), optional :: energy real ( wp ), intent ( in ), optional :: gnorm !type(tb_buffer) :: sd_values character ( len = :), allocatable :: line character ( len =* ), parameter :: sd_format = & & '(\"> <\", a, \">\", /, f20.12, /)' call write_molfile ( self , unit ) !   sd_values = self%info !   call sd_values%reset !   do while(sd_values%next()) !      call sd_values%getline(line) !      write(unit, '(a)') line !   enddo if ( present ( energy )) then write ( unit , sd_format ) \"total energy / Eh\" , energy endif if ( present ( gnorm )) then write ( unit , sd_format ) \"gradient norm / Eh/a0\" , gnorm endif write ( unit , '(\"\")' ) end subroutine write_sdf subroutine write_molfile ( self , unit , comment_line ) class ( structure_type ), intent ( in ) :: self integer , intent ( in ) :: unit character ( len =* ), intent ( in ), optional :: comment_line integer , parameter :: list4 ( 4 ) = 0 integer :: iatom , ibond , iatoms ( 3 ), list12 ( 12 ) logical :: has_sdf_data integer , parameter :: charge_to_ccc ( - 3 : 3 ) = [ 7 , 6 , 5 , 0 , 3 , 2 , 1 ] character ( len = 8 ) :: date character ( len = 10 ) :: time call date_and_time ( date , time ) if ( present ( comment_line )) then write ( unit , '(a)' ) comment_line else if ( allocated ( self % comment )) then write ( unit , '(a)' ) self % comment else write ( unit , '(a)' ) end if end if write ( unit , '(2x, 3x, 5x, 3a2, a4, \"3D\")' ) & & date ( 5 : 6 ), date ( 7 : 8 ), date ( 3 : 4 ), time (: 4 ) write ( unit , '(a)' ) write ( unit , '(3i3, 3x, 2i3, 12x, i3, 1x, a5)' ) & & self % nat , self % nbd , 0 , 0 , 0 , 999 , 'V2000' has_sdf_data = allocated ( self % sdf ) do iatom = 1 , self % nat if ( has_sdf_data ) then list12 = [ self % sdf ( iatom )% isotope , 0 , 0 , 0 , 0 , self % sdf ( iatom )% valence , & & 0 , 0 , 0 , 0 , 0 , 0 ] else list12 = 0 endif write ( unit , '(3f10.4, 1x, a3, i2, 11i3)' ) & & self % xyz (:, iatom ) * autoaa , self % sym ( self % id ( iatom )), list12 enddo if ( self % nbd > 0 ) then if ( size ( self % bond , 1 ) > 2 ) then do ibond = 1 , self % nbd write ( unit , '(7i3)' ) self % bond (: 3 , ibond ), list4 end do else do ibond = 1 , self % nbd write ( unit , '(7i3)' ) self % bond (: 2 , ibond ), 1 , list4 end do end if end if if ( has_sdf_data ) then if ( sum ( self % sdf % charge ) /= nint ( self % charge )) then write ( unit , '(a, *(i3, 1x, i3, 1x, i3))' ) \"M  CHG\" , 1 , 1 , nint ( self % charge ) else do iatom = 1 , self % nat if ( self % sdf ( iatom )% charge /= 0 ) then write ( unit , '(a, *(i3, 1x, i3, 1x, i3))' ) & & \"M  CHG\" , 1 , iatom , self % sdf ( iatom )% charge end if end do end if else if ( nint ( self % charge ) /= 0 ) then write ( unit , '(a, *(i3, 1x, i3, 1x, i3))' ) \"M  CHG\" , 1 , 1 , nint ( self % charge ) end if end if write ( unit , '(a)' ) \"M  END\" end subroutine write_molfile end module mctc_io_write_ctfile","tags":"","loc":"sourcefile/ctfile.f90.html"},{"title":"turbomole.f90 – MCTC-library","text":"Contents Modules mctc_io_write_turbomole Source Code turbomole.f90 Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. module mctc_io_write_turbomole use mctc_env_accuracy , only : wp use mctc_io_structure , only : structure_type implicit none private public :: write_coord contains subroutine write_coord ( mol , unit ) class ( structure_type ), intent ( in ) :: mol integer , intent ( in ) :: unit integer :: iat write ( unit , '(a)' ) \"$coord\" do iat = 1 , mol % nat write ( unit , '(3es24.14, 6x, a)' ) mol % xyz (:, iat ), trim ( mol % sym ( mol % id ( iat ))) enddo write ( unit , '(a, 1x, i0)' ) \"$periodic\" , count ( mol % periodic ) if ( any ( mol % periodic )) then write ( unit , '(a)' ) \"$lattice bohr\" write ( unit , '(3f20.14)' ) mol % lattice endif write ( unit , '(a)' ) \"$end\" end subroutine write_coord end module mctc_io_write_turbomole","tags":"","loc":"sourcefile/turbomole.f90.html"},{"title":"gaussian.f90 – MCTC-library","text":"Contents Modules mctc_io_write_gaussian Source Code gaussian.f90 Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. module mctc_io_write_gaussian use mctc_env_accuracy , only : wp use mctc_io_structure , only : structure_type implicit none private public :: write_gaussian_external contains subroutine write_gaussian_external ( mol , unit ) type ( structure_type ), intent ( in ) :: mol integer , intent ( in ) :: unit integer :: iat write ( unit , '(4i10)' ) mol % nat , 1 , nint ( mol % charge ), mol % uhf do iat = 1 , mol % nat write ( unit , '(i10,4f20.12)' ) mol % num ( mol % id ( iat )), mol % xyz (:, iat ), 0.0_wp end do end subroutine write_gaussian_external end module mctc_io_write_gaussian","tags":"","loc":"sourcefile/gaussian.f90.html"},{"title":"vasp.f90 – MCTC-library","text":"Contents Modules mctc_io_write_vasp Source Code vasp.f90 Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. module mctc_io_write_vasp use mctc_env_accuracy , only : wp use mctc_io_convert , only : autoaa use mctc_io_math , only : matinv_3x3 use mctc_io_structure , only : structure_type implicit none private public :: write_vasp contains subroutine write_vasp ( self , unit , comment_line ) class ( structure_type ), intent ( in ) :: self integer , intent ( in ) :: unit character ( len =* ), intent ( in ), optional :: comment_line integer :: i , j , izp integer , allocatable :: kinds (:), species (:) real ( wp ), allocatable :: inv_lat (:, :) real ( wp ), allocatable :: abc (:, :) allocate ( species ( self % nat )) allocate ( kinds ( self % nat ), source = 1 ) j = 0 izp = 0 do i = 1 , self % nat if ( izp . eq . self % id ( i )) then kinds ( j ) = kinds ( j ) + 1 else j = j + 1 izp = self % id ( i ) species ( j ) = self % id ( i ) endif enddo ! use vasp 5.x format if ( present ( comment_line )) then write ( unit , '(a)' ) comment_line else if ( allocated ( self % comment )) then write ( unit , '(a)' ) self % comment else write ( unit , '(a)' ) end if end if ! scaling factor for lattice parameters is always one write ( unit , '(f20.14)' ) self % info % scale ! write the lattice parameters if ( allocated ( self % lattice )) then do i = 1 , 3 write ( unit , '(3f20.14)' ) self % lattice (:, i ) * autoaa / self % info % scale enddo else write ( unit , '(3f20.14)' ) spread ( 0.0_wp , 1 , 9 ) end if do i = 1 , j write ( unit , '(1x, a)' , advance = 'no' ) self % sym ( species ( i )) enddo write ( unit , '(a)' ) ! write the count of the consequtive atom types do i = 1 , j write ( unit , '(1x, i0)' , advance = 'no' ) kinds ( i ) enddo write ( unit , '(a)' ) deallocate ( kinds , species ) if ( self % info % selective ) write ( unit , '(\"Selective\")' ) ! we write cartesian coordinates if (. not . allocated ( self % lattice ) . or . self % info % cartesian ) then write ( unit , '(\"Cartesian\")' ) ! now write the cartesian coordinates do i = 1 , self % nat write ( unit , '(3f20.14)' ) self % xyz (:, i ) * autoaa / self % info % scale enddo else write ( unit , '(\"Direct\")' ) inv_lat = matinv_3x3 ( self % lattice ) abc = matmul ( inv_lat , self % xyz ) ! now write the fractional coordinates do i = 1 , self % nat write ( unit , '(3f20.14)' ) abc (:, i ) enddo endif end subroutine write_vasp end module mctc_io_write_vasp","tags":"","loc":"sourcefile/vasp.f90.html"},{"title":"xyz.f90 – MCTC-library","text":"Contents Modules mctc_io_write_xyz Source Code xyz.f90 Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. module mctc_io_write_xyz use mctc_io_convert , only : autoaa use mctc_io_structure , only : structure_type implicit none private public :: write_xyz contains subroutine write_xyz ( self , unit , comment_line ) class ( structure_type ), intent ( in ) :: self integer , intent ( in ) :: unit character ( len =* ), intent ( in ), optional :: comment_line integer :: iat logical :: expo write ( unit , '(i0)' ) self % nat if ( present ( comment_line )) then write ( unit , '(a)' ) comment_line else if ( allocated ( self % comment )) then write ( unit , '(a)' ) self % comment else write ( unit , '(a)' ) end if end if expo = maxval ( self % xyz ) > 1.0e+5 . or . minval ( self % xyz ) < - 1.0e+5 if ( expo ) then do iat = 1 , self % nat write ( unit , '(a4, 1x, 3es24.14)' ) & & self % sym ( self % id ( iat )), self % xyz (:, iat ) * autoaa enddo else do iat = 1 , self % nat write ( unit , '(a4, 1x, 3f24.14)' ) & & self % sym ( self % id ( iat )), self % xyz (:, iat ) * autoaa enddo end if end subroutine write_xyz end module mctc_io_write_xyz","tags":"","loc":"sourcefile/xyz.f90.html"},{"title":"genformat.f90 – MCTC-library","text":"Contents Modules mctc_io_read_genformat Source Code genformat.f90 Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. module mctc_io_read_genformat use mctc_env_accuracy , only : wp use mctc_env_error , only : error_type , fatal_error use mctc_io_convert , only : aatoau use mctc_io_structure , only : structure_type , new use mctc_io_structure_info , only : structure_info use mctc_io_symbols , only : to_number , symbol_length use mctc_io_utils , only : getline implicit none private public :: read_genformat contains subroutine read_genformat ( mol , unit , error ) !> Instance of the molecular structure data type ( structure_type ), intent ( out ) :: mol !> File handle integer , intent ( in ) :: unit !> Error handling type ( error_type ), allocatable , intent ( out ) :: error character ( len = :), allocatable :: line integer :: natoms , nspecies , iatom , dummy , isp , ilat , stat , istart , iend logical :: cartesian , periodic real ( wp ) :: coord ( 3 ), lattice ( 3 , 3 ) character ( len = 1 ) :: variant character ( len = symbol_length ), allocatable :: species (:), sym (:) real ( wp ), allocatable :: xyz (:, :), abc (:, :) type ( structure_info ) :: info call next_line ( unit , line , stat ) read ( line , * , iostat = stat ) natoms , variant if ( stat /= 0 . or . natoms < 1 ) then call fatal_error ( error , 'could not read number of atoms' ) return end if allocate ( species ( natoms )) allocate ( sym ( natoms )) allocate ( xyz ( 3 , natoms )) allocate ( abc ( 3 , natoms )) select case ( variant ) case ( 'c' , 'C' ) cartesian = . true . periodic = . false . case ( 's' , 'S' ) cartesian = . true . periodic = . true . case ( 'f' , 'F' ) cartesian = . false . periodic = . true . case default call fatal_error ( error , 'invalid input version' ) return endselect call next_line ( unit , line , stat ) istart = 1 iend = 1 isp = 0 do while ( iend < len_trim ( line )) istart = verify ( line ( iend :), ' ' ) - 1 + iend iend = scan ( line ( istart :), ' ' ) - 1 + istart if ( iend < istart ) iend = len_trim ( line ) isp = isp + 1 species ( isp ) = trim ( line ( istart : iend )) end do nspecies = isp if ( any ( to_number ( species (: nspecies )) == 0 )) then call fatal_error ( error , 'unknown atom type present' ) return end if do iatom = 1 , natoms call next_line ( unit , line , stat ) read ( line , * , iostat = stat ) dummy , isp , coord if ( stat /= 0 ) then call fatal_error ( error , 'could not read coordinates from file' ) return end if sym ( iatom ) = species ( isp ) if ( cartesian ) then xyz (:, iatom ) = coord * aatoau else abc (:, iatom ) = coord end if end do if ( periodic ) then call next_line ( unit , line , stat ) if ( stat /= 0 ) then call fatal_error ( error , 'missing lattice information' ) return end if do ilat = 1 , 3 call next_line ( unit , line , stat ) read ( line , * , iostat = stat ) coord if ( stat /= 0 ) then call fatal_error ( error , 'could not read lattice from file' ) return end if lattice (:, ilat ) = coord * aatoau end do if (. not . cartesian ) then xyz = matmul ( lattice , abc ) end if info = structure_info ( cartesian = cartesian ) call new ( mol , sym , xyz , lattice = lattice , info = info ) else call new ( mol , sym , xyz ) end if contains subroutine next_line ( unit , line , stat ) integer , intent ( in ) :: unit character ( len = :), allocatable , intent ( out ) :: line integer , intent ( out ) :: stat integer :: ihash stat = 0 do while ( stat == 0 ) call getline ( unit , line , stat ) ihash = index ( line , '#' ) if ( ihash > 0 ) line = line (: ihash - 1 ) if ( len_trim ( line ) > 0 ) exit end do line = trim ( adjustl ( line )) end subroutine next_line end subroutine read_genformat end module mctc_io_read_genformat","tags":"","loc":"sourcefile/genformat.f90~2.html"},{"title":"pdb.f90 – MCTC-library","text":"Contents Modules mctc_io_read_pdb Source Code pdb.f90 Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. module mctc_io_read_pdb use mctc_env_accuracy , only : wp use mctc_env_error , only : error_type , fatal_error use mctc_io_convert , only : aatoau use mctc_io_resize , only : resize use mctc_io_symbols , only : to_number , symbol_length use mctc_io_structure , only : structure_type , new use mctc_io_structure_info , only : pdb_data , resize use mctc_io_utils , only : getline implicit none private public :: read_pdb contains subroutine read_pdb ( self , unit , error ) !> Instance of the molecular structure data type ( structure_type ), intent ( out ) :: self !> File handle integer , intent ( in ) :: unit !> Error handling type ( error_type ), allocatable , intent ( out ) :: error character ( len =* ), parameter :: pdb_format = & & '(6x,i5,1x,a4,a1,a3,1x,a1,i4,a1,3x,3f8.3,2f6.2,6x,a4,a2,a2)' integer , parameter :: p_initial_size = 1000 ! this is going to be a proteine integer :: iatom , jatom , iresidue , try , stat , atom_type real ( wp ) :: occ , temp , coords ( 3 ) real ( wp ), allocatable :: xyz (:,:) character ( len = 4 ) :: a_charge character ( len = :), allocatable :: line character ( len = symbol_length ), allocatable :: sym (:) type ( pdb_data ), allocatable :: pdb (:) allocate ( sym ( p_initial_size ), source = repeat ( ' ' , symbol_length )) allocate ( xyz ( 3 , p_initial_size ), source = 0.0_wp ) allocate ( pdb ( p_initial_size ), source = pdb_data ()) iatom = 0 iresidue = 0 stat = 0 do while ( stat == 0 ) call getline ( unit , line , stat ) if ( index ( line , 'END' ) == 1 ) exit if ( index ( line , 'ATOM' ) == 1 . or . index ( line , 'HETATM' ) == 1 ) then if ( iatom >= size ( xyz , 2 )) call resize ( xyz ) if ( iatom >= size ( sym )) call resize ( sym ) if ( iatom >= size ( pdb )) call resize ( pdb ) iatom = iatom + 1 pdb ( iatom )% het = index ( line , 'HETATM' ) == 1 read ( line , pdb_format ) & & jatom , pdb ( iatom )% name , pdb ( iatom )% loc , pdb ( iatom )% residue , & & pdb ( iatom )% chains , pdb ( iatom )% residue_number , pdb ( iatom )% code , & & coords , occ , temp , pdb ( iatom )% segid , sym ( iatom ), a_charge xyz (:, iatom ) = coords * aatoau atom_type = to_number ( sym ( iatom )) if ( atom_type == 0 ) then try = scan ( pdb ( iatom )% name , 'HCNOSPF' ) if ( try > 0 ) sym ( iatom ) = pdb ( iatom )% name ( try : try ) // ' ' pdb ( iatom )% charge = 0 else read ( a_charge ( 1 : 1 ), * , iostat = stat ) pdb ( iatom )% charge if ( stat /= 0 ) then stat = 0 pdb ( iatom )% charge = 0 else if ( a_charge ( 2 : 2 ) == '-' ) pdb ( iatom )% charge = - pdb ( iatom )% charge end if end if end if end do if ( stat /= 0 ) then call fatal_error ( error , \"could not read in coordinates, last line was: '\" // line // \"'\" ) return end if call new ( self , sym (: iatom ), xyz (:, : iatom )) self % pdb = pdb (: iatom ) self % charge = sum ( pdb (: iatom )% charge ) if (. not . all ( self % num > 0 )) then call fatal_error ( error , \"invalid atom type found\" ) return end if ! since PDB is used for biomolecules, this is a sensible check (prevents GIGO) if (. not . any ( self % num == 1 )) then call fatal_error ( error , \"You get no calculation today, please add hydrogen atoms first\" ) return end if end subroutine read_pdb end module mctc_io_read_pdb","tags":"","loc":"sourcefile/pdb.f90~2.html"},{"title":"ctfile.f90 – MCTC-library","text":"Contents Modules mctc_io_read_ctfile Source Code ctfile.f90 Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. module mctc_io_read_ctfile use mctc_env_accuracy , only : wp use mctc_env_error , only : error_type , fatal_error use mctc_io_convert , only : aatoau use mctc_io_structure , only : structure_type , new use mctc_io_structure_info , only : sdf_data , structure_info use mctc_io_symbols , only : to_number , symbol_length use mctc_io_utils , only : getline implicit none private public :: read_sdf , read_molfile contains subroutine read_sdf ( self , unit , error ) !> Instance of the molecular structure data type ( structure_type ), intent ( out ) :: self !> File handle integer , intent ( in ) :: unit !> Error handling type ( error_type ), allocatable , intent ( out ) :: error character ( len = :), allocatable :: line integer :: stat call read_molfile ( self , unit , error ) if ( allocated ( error )) return stat = 0 do while ( stat == 0 ) call getline ( unit , line , stat ) if ( index ( line , '' ) == 1 ) exit end do if ( stat /= 0 ) then call fatal_error ( error , \"Failed while reading SDF key-value pairs\" ) return end if end subroutine read_sdf subroutine read_molfile ( self , unit , error ) !> Instance of the molecular structure data type ( structure_type ), intent ( out ) :: self !> File handle integer , intent ( in ) :: unit !> Error handling type ( error_type ), allocatable , intent ( out ) :: error character ( len = :), allocatable :: line character ( len = :), allocatable :: comment integer :: i , iatom , jatom , ibond , btype , atomtype integer :: stat , length , charge ( 2 , 15 ) integer :: number_of_atoms , number_of_bonds , number_of_atom_lists , & & chiral_flag , number_of_stext_entries , i999 integer :: list4 ( 4 ), list12 ( 12 ) real ( wp ) :: x , y , z character ( len = 2 ) :: sdf_dim character ( len = 3 ) :: symbol character ( len = 5 ) :: v2000 integer , parameter :: ccc_to_charge ( 0 : 7 ) = [ 0 , + 3 , + 2 , + 1 , 0 , - 1 , - 2 , - 3 ] logical :: two_dim character ( len = symbol_length ), allocatable :: sym (:) type ( sdf_data ), allocatable :: sdf (:) type ( structure_info ) :: info real ( wp ), allocatable :: xyz (:, :) integer , allocatable :: bond (:, :) two_dim = . false . call getline ( unit , comment , stat ) call getline ( unit , line , stat ) read ( line , '(20x, a2)' , iostat = stat ) sdf_dim if ( stat == 0 ) then two_dim = sdf_dim == '2D' . or . sdf_dim == '2d' end if call getline ( unit , line , stat ) call getline ( unit , line , stat ) read ( line , '(3i3, 3x, 2i3, 12x, i3, 1x, a5)' , iostat = stat ) & & number_of_atoms , number_of_bonds , number_of_atom_lists , & & chiral_flag , number_of_stext_entries , i999 , v2000 if ( stat /= 0 ) then call fatal_error ( error , \"Cannot read header of molfile\" ) return end if allocate ( sdf ( number_of_atoms )) allocate ( xyz ( 3 , number_of_atoms )) allocate ( sym ( number_of_atoms )) do iatom = 1 , number_of_atoms call getline ( unit , line , stat ) read ( line , '(3f10.4, 1x, a3, i2, 11i3)' , iostat = stat ) & & x , y , z , symbol , list12 if ( stat /= 0 ) then call fatal_error ( error , \"Cannot read coordinates from connection table\" ) return end if atomtype = to_number ( symbol ) if ( atomtype == 0 ) then call fatal_error ( error , \"Unknown atom type '\" // trim ( symbol ) // \"' in connection table\" ) return end if xyz (:, iatom ) = [ x , y , z ] * aatoau sym ( iatom ) = trim ( symbol ) sdf ( iatom )% isotope = list12 ( 1 ) sdf ( iatom )% charge = ccc_to_charge ( list12 ( 2 )) ! drop doublet radical sdf ( iatom )% hydrogens = list12 ( 4 ) sdf ( iatom )% valence = list12 ( 6 ) end do allocate ( bond ( 3 , number_of_bonds )) do ibond = 1 , number_of_bonds call getline ( unit , line , stat ) read ( line , '(7i3)' , iostat = stat ) & & iatom , jatom , btype , list4 if ( stat /= 0 ) then call fatal_error ( error , \"Cannot read topology from connection table\" ) return end if bond (:, ibond ) = [ ibond , jatom , btype ] end do do while ( stat == 0 ) call getline ( unit , line , stat ) if ( index ( line , 'M  END' ) == 1 ) exit if ( index ( line , 'M  CHG' ) == 1 ) then read ( line ( 7 : 9 ), * ) length read ( line ( 10 :), '(*(1x, i3, 1x, i3))' ) ( charge (:, i ), i = 1 , length ) do i = 1 , length sdf ( charge ( 1 , i ))% charge = charge ( 2 , i ) end do end if end do if ( stat /= 0 ) then call fatal_error ( error , \"Cannot read connection table\" ) return end if info = structure_info ( two_dimensional = two_dim , & & missing_hydrogen = any ( sdf % hydrogens > 1 )) call new ( self , sym , xyz , charge = real ( sum ( sdf % charge ), wp ), info = info , bond = bond ) call move_alloc ( sdf , self % sdf ) if ( len ( comment ) > 0 ) self % comment = comment end subroutine read_molfile end module mctc_io_read_ctfile","tags":"","loc":"sourcefile/ctfile.f90~2.html"},{"title":"turbomole.f90 – MCTC-library","text":"Contents Modules mctc_io_read_turbomole Source Code turbomole.f90 Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. module mctc_io_read_turbomole use mctc_env_accuracy , only : wp use mctc_env_error , only : error_type , fatal_error use mctc_io_constants , only : pi use mctc_io_convert , only : aatoau use mctc_io_resize , only : resize use mctc_io_structure , only : structure_type , new use mctc_io_structure_info , only : structure_info use mctc_io_symbols , only : to_number , symbol_length use mctc_io_utils , only : getline implicit none private public :: read_coord logical , parameter :: debug = . false . contains subroutine read_coord ( mol , unit , error ) !> Instance of the molecular structure data type ( structure_type ), intent ( out ) :: mol !> File handle integer , intent ( in ) :: unit !> Error handling type ( error_type ), allocatable , intent ( out ) :: error character , parameter :: flag = '$' integer , parameter :: p_initial_size = 100 integer , parameter :: p_nlv ( 3 ) = [ 1 , 4 , 9 ], p_ncp ( 3 ) = [ 1 , 3 , 6 ] logical :: has_coord , has_periodic , has_lattice , has_cell logical :: cartesian , coord_in_bohr , lattice_in_bohr , pbc ( 3 ) integer :: stat , iatom , i , j , natoms , periodic , cell_vectors real ( wp ) :: latvec ( 9 ), conv , cellpar ( 6 ), lattice ( 3 , 3 ) real ( wp ), allocatable :: coord (:, :), xyz (:, :) character ( len = :), allocatable :: line , cell_string , lattice_string character ( len = symbol_length ), allocatable :: sym (:) type ( structure_info ) :: info allocate ( sym ( p_initial_size ), source = repeat ( ' ' , symbol_length )) allocate ( coord ( 3 , p_initial_size ), source = 0.0_wp ) iatom = 0 periodic = 0 cell_vectors = 0 has_coord = . false . has_periodic = . false . has_lattice = . false . has_cell = . false . cartesian = . true . coord_in_bohr = . true . lattice_in_bohr = . true . lattice = 0.0_wp pbc = . false . stat = 0 do while ( stat == 0 ) call getline ( unit , line , stat ) if ( index ( line , flag ) == 1 ) then if ( index ( line , 'end' ) == 2 ) then exit else if (. not . has_coord . and . index ( line , 'coord' ) == 2 ) then has_coord = . true . ! $coord angs / $coord bohr / $coord frac call select_unit ( line , coord_in_bohr , cartesian ) coord_group : do while ( stat == 0 ) call getline ( unit , line , stat ) if ( index ( line , flag ) == 1 ) then backspace ( unit ) exit coord_group end if if ( iatom >= size ( coord , 2 )) call resize ( coord ) if ( iatom >= size ( sym )) call resize ( sym ) iatom = iatom + 1 read ( line , * , iostat = stat ) coord (:, iatom ), sym ( iatom ) end do coord_group else if (. not . has_periodic . and . index ( line , 'periodic' ) == 2 ) then has_periodic = . true . ! $periodic 0/1/2/3 read ( line ( 10 :), * , iostat = stat ) periodic else if (. not . has_lattice . and . index ( line , 'lattice' ) == 2 ) then has_lattice = . true . ! $lattice bohr / $lattice angs call select_unit ( line , lattice_in_bohr ) cell_vectors = 0 lattice_string = '' lattice_group : do while ( stat == 0 ) call getline ( unit , line , stat ) if ( index ( line , flag ) == 1 ) then backspace ( unit ) exit lattice_group end if cell_vectors = cell_vectors + 1 lattice_string = lattice_string // ' ' // line end do lattice_group else if (. not . has_cell . and . index ( line , 'cell' ) == 2 ) then has_cell = . true . ! $cell bohr / $cell angs call select_unit ( line , lattice_in_bohr ) call getline ( unit , cell_string , stat ) if ( debug ) print * , cell_string end if end if end do if (. not . has_coord . or . iatom == 0 ) then call fatal_error ( error , \"coordinates not present, cannot work without coordinates\" ) return end if if ( has_cell . and . has_lattice ) then call fatal_error ( error , \"both lattice and cell group are present\" ) return end if if (. not . has_periodic . and . ( has_cell . or . has_lattice )) then call fatal_error ( error , \"cell and lattice definition is present, but periodicity is not given\" ) return end if if ( periodic > 0 . and . . not .( has_cell . or . has_lattice )) then call fatal_error ( error , \"system is periodic but definition of lattice/cell is missing\" ) return end if if (. not . cartesian . and . periodic == 0 ) then call fatal_error ( error , \"fractional coordinates do not work for molecular systems\" ) return end if natoms = iatom allocate ( xyz ( 3 , natoms )) if ( any ( to_number ( sym (: natoms )) == 0 )) then call fatal_error ( error , \"unknown element present\" ) return end if if ( periodic > 0 ) pbc (: periodic ) = . true . if ( has_cell ) then read ( cell_string , * , iostat = stat ) latvec (: p_ncp ( periodic )) if ( debug ) print * , latvec (: p_ncp ( periodic )) if ( lattice_in_bohr ) then conv = 1.0_wp else conv = aatoau end if select case ( periodic ) case ( 1 ) cellpar = [ latvec ( 1 ) * conv , 1.0_wp , 1.0_wp , & & pi / 2 , pi / 2 , pi / 2 ] case ( 2 ) cellpar = [ latvec ( 1 ) * conv , latvec ( 2 ) * conv , 1.0_wp , & & pi / 2 , pi / 2 , latvec ( 3 ) * pi / 18 0.0_wp ] case ( 3 ) cellpar = [ latvec ( 1 : 3 ) * conv , latvec ( 4 : 6 ) * pi / 18 0.0_wp ] end select call cell_to_dlat ( cellpar , lattice ) end if if ( has_lattice ) then if ( cell_vectors /= periodic ) then call fatal_error ( error , \"number of cell vectors does not match periodicity\" ) return end if read ( lattice_string , * , iostat = stat ) latvec (: p_nlv ( periodic )) if ( lattice_in_bohr ) then conv = 1.0_wp else conv = aatoau end if j = 0 do i = 1 , periodic lattice (: periodic , i ) = latvec ( j + 1 : j + periodic ) * conv j = j + periodic end do end if if ( cartesian ) then if ( coord_in_bohr ) then conv = 1.0_wp else conv = aatoau end if xyz (:, :) = coord (:, : natoms ) * conv else xyz = matmul ( lattice , coord ) end if ! save data on input format info = structure_info ( cartesian = cartesian , lattice = has_lattice , & & angs_lattice = . not . lattice_in_bohr , angs_coord = . not . coord_in_bohr ) call new ( mol , sym (: natoms ), xyz , lattice = lattice , periodic = pbc , info = info ) contains subroutine select_unit ( line , in_bohr , cartesian ) character ( len =* ), intent ( in ) :: line logical , intent ( out ) :: in_bohr logical , intent ( out ), optional :: cartesian in_bohr = index ( line , ' angs' ) == 0 if ( present ( cartesian )) cartesian = index ( line , ' frac' ) == 0 end subroutine select_unit end subroutine read_coord !> Calculate the lattice vectors from a set of cell parameters pure subroutine cell_to_dlat ( cellpar , lattice ) !> Cell parameters real ( wp ), intent ( in ) :: cellpar ( 6 ) !> Direct lattice real ( wp ), intent ( out ) :: lattice ( 3 , 3 ) real ( wp ) :: dvol dvol = cell_to_dvol ( cellpar ) associate ( alen => cellpar ( 1 ), blen => cellpar ( 2 ), clen => cellpar ( 3 ), & & alp => cellpar ( 4 ), bet => cellpar ( 5 ), gam => cellpar ( 6 )) lattice ( 1 , 1 ) = alen lattice ( 2 , 1 ) = 0.0_wp lattice ( 3 , 1 ) = 0.0_wp lattice ( 3 , 2 ) = 0.0_wp lattice ( 1 , 2 ) = blen * cos ( gam ) lattice ( 2 , 2 ) = blen * sin ( gam ) lattice ( 1 , 3 ) = clen * cos ( bet ) lattice ( 2 , 3 ) = clen * ( cos ( alp ) - cos ( bet ) * cos ( gam )) / sin ( gam ); lattice ( 3 , 3 ) = dvol / ( alen * blen * sin ( gam )) end associate end subroutine cell_to_dlat !> Calculate the cell volume from a set of cell parameters pure function cell_to_dvol ( cellpar ) result ( dvol ) !> Cell parameters real ( wp ), intent ( in ) :: cellpar ( 6 ) !> Cell volume real ( wp ) :: dvol real ( wp ) :: vol2 associate ( alen => cellpar ( 1 ), blen => cellpar ( 2 ), clen => cellpar ( 3 ), & & alp => cellpar ( 4 ), bet => cellpar ( 5 ), gam => cellpar ( 6 ) ) vol2 = 1.0_wp - cos ( alp ) ** 2 - cos ( bet ) ** 2 - cos ( gam ) ** 2 & & + 2.0_wp * cos ( alp ) * cos ( bet ) * cos ( gam ) dvol = sqrt ( abs ( vol2 )) * alen * blen * clen ! return negative volume instead of imaginary one (means bad cell parameters) if ( vol2 < 0.0_wp ) dvol = - dvol ! this should not happen, but who knows... end associate end function cell_to_dvol end module mctc_io_read_turbomole","tags":"","loc":"sourcefile/turbomole.f90~2.html"},{"title":"gaussian.f90 – MCTC-library","text":"Contents Modules mctc_io_read_gaussian Source Code gaussian.f90 Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. module mctc_io_read_gaussian use mctc_env_accuracy , only : wp use mctc_env_error , only : error_type , fatal_error use mctc_io_structure , only : structure_type , new implicit none private public :: read_gaussian_external contains subroutine read_gaussian_external ( self , unit , error ) !> Instance of the molecular structure data type ( structure_type ), intent ( out ) :: self !> File handle integer , intent ( in ) :: unit !> Error handling type ( error_type ), allocatable , intent ( out ) :: error integer :: stat , n , mode , chrg , spin , iat , ii integer , allocatable :: at (:) real ( wp ), allocatable :: xyz (:,:) real ( wp ) :: coord ( 3 ), q read ( unit , '(4i10)' , iostat = stat ) n , mode , chrg , spin if ( stat . ne . 0 ) then call fatal_error ( error , \"Could not read number of atoms, check format!\" ) return end if if ( n <= 0 ) then call fatal_error ( error , \"Found no atoms, cannot work without atoms!\" ) return end if allocate ( xyz ( 3 , n )) allocate ( at ( n )) ii = 0 do while ( ii < n ) read ( unit , '(i10, 4f20.12)' , iostat = stat ) iat , coord , q if ( is_iostat_end ( stat )) exit if ( stat . ne . 0 ) then call fatal_error ( error , \"Could not read geometry from Gaussian file\" ) return end if if ( iat > 0 ) then ii = ii + 1 at ( ii ) = iat xyz (:, ii ) = coord else call fatal_error ( error , \"Invalid atomic number\" ) return end if end do call new ( self , at , xyz , charge = real ( chrg , wp ), uhf = spin ) if ( ii /= n ) then call fatal_error ( error , \"Atom number missmatch in Gaussian file\" ) return end if end subroutine read_gaussian_external end module mctc_io_read_gaussian","tags":"","loc":"sourcefile/gaussian.f90~2.html"},{"title":"vasp.f90 – MCTC-library","text":"Contents Modules mctc_io_read_vasp Source Code vasp.f90 Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. module mctc_io_read_vasp use mctc_env_accuracy , only : wp use mctc_env_error , only : error_type , fatal_error use mctc_io_convert , only : aatoau use mctc_io_resize , only : resize use mctc_io_structure , only : structure_type , new use mctc_io_structure_info , only : structure_info use mctc_io_symbols , only : to_number , symbol_length use mctc_io_utils , only : getline implicit none private public :: read_vasp logical , parameter :: debug = . false . contains subroutine read_vasp ( self , unit , error ) !> Instance of the molecular structure data type ( structure_type ), intent ( out ) :: self !> File handle integer , intent ( in ) :: unit !> Error handling type ( error_type ), allocatable , intent ( out ) :: error logical :: selective , cartesian integer :: i , j , k , nn , ntype , natoms , izp , stat integer , allocatable :: ncount (:) real ( wp ) :: ddum , latvec ( 3 ), scalar , coord ( 3 ), lattice ( 3 , 3 ) real ( wp ), allocatable :: xyz (:, :) character ( len = :), allocatable :: line , comment character ( len = 2 * symbol_length ), allocatable :: args (:), args2 (:) character ( len = symbol_length ), allocatable :: sym (:) type ( structure_info ) :: info selective = . false . ! Selective dynamics cartesian = . true . ! Cartesian or direct lattice = 0 stat = 0 ntype = 0 ! first line contains the symbols of different atom types call getline ( unit , line , stat ) if ( stat /= 0 ) then call fatal_error ( error , \"Unexpected end of input encountered\" ) return end if if ( debug ) print '(\">\", a)' , line call parse_line ( line , args , ntype ) call move_alloc ( line , comment ) ! this line contains the global scaling factor, call getline ( unit , line , stat ) if ( stat /= 0 ) then call fatal_error ( error , \"Unexpected end of input encountered\" ) return end if if ( debug ) print '(\">\", a)' , line read ( line , * , iostat = stat ) ddum if ( stat /= 0 ) then call fatal_error ( error , \"Cannot read scaling factor from input\" ) return end if ! the Ang->au conversion is included in the scaling factor if ( debug ) print '(\"->\", g0)' , ddum scalar = ddum * aatoau ! reading the lattice constants do i = 1 , 3 call getline ( unit , line , stat ) if ( stat /= 0 ) then call fatal_error ( error , \"Unexpected end of lattice vectors encountered\" ) return end if if ( debug ) print '(\"->\", a)' , line read ( line , * , iostat = stat ) latvec if ( stat /= 0 ) then call fatal_error ( error , \"Cannot read lattice vectors from input\" ) return end if lattice (:, i ) = latvec * scalar end do ! Either here are the numbers of each element, ! or (>vasp.5.1) here are the element symbols call getline ( unit , line , stat ) if ( stat /= 0 ) then call fatal_error ( error , \"Unexpected end of input encountered\" ) return end if if ( debug ) print '(\">\", a)' , line ! try to verify that first element is actually a number i = max ( verify ( line , ' ' ), 1 ) j = scan ( line ( i :), ' ' ) - 2 + i if ( j < i ) j = len_trim ( line ) ! CONTCAR files have additional Element line here since vasp.5.1 if ( verify ( line ( i : j ), '1234567890' ) /= 0 ) then call parse_line ( line , args , ntype ) call getline ( unit , line , stat ) if ( debug ) print '(\"->\", a)' , line if ( stat /= 0 ) then call fatal_error ( error , \"Unexpected end of input encountered\" ) return end if else deallocate ( comment ) end if call parse_line ( line , args2 , nn ) if ( nn /= ntype ) then call fatal_error ( error , 'Number of atom types mismatches the number of counts' ) return end if allocate ( ncount ( nn ), source = 0 ) do i = 1 , nn read ( args2 ( i ), * , iostat = stat ) ncount ( i ) izp = to_number ( args ( i )) if ( izp < 1 . or . ncount ( i ) < 1 ) then call fatal_error ( error , \"Unknown element '\" // trim ( args ( i )) // \"' encountered\" ) return end if end do natoms = sum ( ncount ) allocate ( sym ( natoms )) allocate ( xyz ( 3 , natoms )) k = 0 do i = 1 , nn do j = 1 , ncount ( i ) k = k + 1 sym ( k ) = trim ( args ( i )) end do end do call getline ( unit , line , stat ) if ( stat /= 0 ) then call fatal_error ( error , \"Could not read POSCAR\" ) return end if if ( debug ) print '(\">\", a)' , line line = adjustl ( line ) if ( line (: 1 ). eq . 's' . or . line (: 1 ). eq . 'S' ) then selective = . true . call getline ( unit , line , stat ) if ( debug ) print '(\"->\", a)' , line if ( stat /= 0 ) then call fatal_error ( error , \"Unexpected end of input encountered\" ) return end if line = adjustl ( line ) end if cartesian = ( line (: 1 ). eq . 'c' . or . line (: 1 ). eq . 'C' . or . & & line (: 1 ). eq . 'k' . or . line (: 1 ). eq . 'K' ) do i = 1 , natoms call getline ( unit , line , stat ) if ( stat /= 0 ) then call fatal_error ( error , \"Unexpected end of geometry encountered\" ) return end if if ( debug ) print '(\"-->\", a)' , line read ( line , * , iostat = stat ) coord if ( stat /= 0 ) then call fatal_error ( error , \"Cannot read geometry from input\" ) return end if if ( cartesian ) then xyz (:, i ) = coord * scalar else xyz (:, i ) = matmul ( lattice , coord ) end if end do ! save information about this POSCAR for later info = structure_info ( scale = ddum , selective = selective , cartesian = cartesian ) call new ( self , sym , xyz , lattice = lattice , info = info ) if ( allocated ( comment )) self % comment = comment end subroutine read_vasp subroutine parse_line ( line , args , nargs ) character ( len =* ), intent ( in ) :: line character ( len = 2 * symbol_length ), allocatable , intent ( out ) :: args (:) integer , intent ( out ) :: nargs integer , parameter :: p_initial_size = 50 integer :: istart , iend allocate ( args ( p_initial_size ), source = repeat ( ' ' , 2 * symbol_length )) istart = 1 iend = 1 nargs = 0 do while ( iend < len_trim ( line )) istart = verify ( line ( iend :), ' ' ) - 1 + iend iend = scan ( line ( istart :), ' ' ) - 1 + istart if ( iend < istart ) iend = len_trim ( line ) if ( nargs >= size ( args )) then call resize ( args ) end if nargs = nargs + 1 args ( nargs ) = trim ( line ( istart : iend )) end do end subroutine parse_line end module mctc_io_read_vasp","tags":"","loc":"sourcefile/vasp.f90~2.html"},{"title":"xyz.f90 – MCTC-library","text":"Contents Modules mctc_io_read_xyz Source Code xyz.f90 Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. module mctc_io_read_xyz use mctc_env_accuracy , only : wp use mctc_env_error , only : error_type , fatal_error use mctc_io_convert , only : aatoau use mctc_io_structure , only : structure_type , new use mctc_io_symbols , only : to_number , to_symbol , symbol_length use mctc_io_utils , only : getline implicit none private public :: read_xyz contains subroutine read_xyz ( self , unit , error ) !> Instance of the molecular structure data type ( structure_type ), intent ( out ) :: self !> File handle integer , intent ( in ) :: unit !> Error handling type ( error_type ), allocatable , intent ( out ) :: error integer :: ii , n , iat , stat real ( wp ) :: x , y , z , conv real ( wp ), allocatable :: xyz (:, :) character ( len = symbol_length ) :: chdum character ( len = symbol_length ), allocatable :: sym (:) character ( len = :), allocatable :: line , comment conv = aatoau read ( unit , * , iostat = stat ) n if ( stat /= 0 ) then call fatal_error ( error , \"Could not read number of atoms, check format!\" ) return end if if ( n . lt . 1 ) then call fatal_error ( error , \"Found no atoms, cannot work without atoms!\" ) return end if allocate ( sym ( n )) allocate ( xyz ( 3 , n )) ! next record is a comment call getline ( unit , comment , stat ) if ( stat /= 0 ) then call fatal_error ( error , \"Unexpected end of file\" ) return end if ii = 0 do while ( ii < n ) call getline ( unit , line , stat ) if ( is_iostat_end ( stat )) exit if ( stat /= 0 ) then call fatal_error ( error , \"Could not read geometry from xyz file\" ) return end if read ( line , * , iostat = stat ) chdum , x , y , z if ( stat /= 0 ) then call fatal_error ( error , \"Could not parse coordinates from xyz file\" ) return end if iat = to_number ( chdum ) if ( iat <= 0 ) then read ( chdum , * , iostat = stat ) iat if ( stat == 0 ) then chdum = to_symbol ( iat ) else iat = 0 end if end if if ( iat > 0 ) then ii = ii + 1 sym ( ii ) = trim ( chdum ) xyz (:, ii ) = [ x , y , z ] * conv else call fatal_error ( error , \"Unknown element symbol: '\" // trim ( chdum ) // \"'\" ) return end if end do if ( ii /= n ) then call fatal_error ( error , \"Atom number missmatch in xyz file\" ) return end if call new ( self , sym , xyz ) if ( len ( comment ) > 0 ) self % comment = comment end subroutine read_xyz end module mctc_io_read_xyz","tags":"","loc":"sourcefile/xyz.f90~2.html"},{"title":"main.f90 – MCTC-library","text":"Contents Programs main Source Code main.f90 Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Example application using tool chain library. !> !> This program uses the [[read_structure]] and [[write_structure]] procedures !> to implement a structure converter. !> Usually, the input structure can be inferred by the name of the input file. !> To allow formats with non-standard extensions (because most geometry formats !> are not really standardized) additional hints can be passed by the command !> line to determine the read/write formats. !> !> To add support for piping standard input and standard output reading and !> writing from units is combined with the additional format hints. !> !> Additional filters or modifications can also be implemented in an intermediary !> step, this program implements an element symbol normalization. Other filters !> like folding back to central cells or removing lattice vector could be added !> in a similar manner. program main use , intrinsic :: iso_fortran_env , only : output_unit , error_unit , input_unit use mctc_env , only : error_type , fatal_error , get_argument , wp use mctc_io , only : structure_type , read_structure , write_structure , & & filetype , get_filetype , to_symbol use mctc_version , only : get_mctc_version implicit none character ( len =* ), parameter :: prog_name = \"mctc-convert\" character ( len = :), allocatable :: input , output , template integer , allocatable :: input_format , output_format , template_format type ( structure_type ) :: mol type ( structure_type ), allocatable :: mol_template type ( error_type ), allocatable :: error logical :: normalize call get_arguments ( input , input_format , output , output_format , normalize , & & template , template_format , error ) if ( allocated ( error )) then write ( error_unit , '(a)' ) error % message error stop end if if ( allocated ( template )) then allocate ( mol_template ) if ( template == \"-\" ) then if (. not . allocated ( template_format )) then template_format = merge ( output_format , filetype % xyz , allocated ( output_format )) end if call read_structure ( mol_template , input_unit , template_format , error ) else call read_structure ( mol_template , template , error , template_format ) end if if ( allocated ( error )) then write ( error_unit , '(a)' ) error % message error stop end if end if if ( input == \"-\" ) then if (. not . allocated ( input_format )) input_format = filetype % xyz call read_structure ( mol , input_unit , input_format , error ) else call read_structure ( mol , input , error , input_format ) end if if ( allocated ( error )) then write ( error_unit , '(a)' ) error % message error stop end if if ( allocated ( mol_template )) then if ( mol % nat /= mol_template % nat ) then write ( error_unit , '(*(a, 1x))' ) & \"Number of atoms missmatch in\" , template , \"and\" , input error stop end if ! move_alloc can also move non-allocated objects call move_alloc ( mol_template % lattice , mol % lattice ) call move_alloc ( mol_template % periodic , mol % periodic ) call move_alloc ( mol_template % bond , mol % bond ) call move_alloc ( mol_template % comment , mol % comment ) call move_alloc ( mol_template % pdb , mol % pdb ) call move_alloc ( mol_template % sdf , mol % sdf ) end if if ( normalize ) then mol % sym = to_symbol ( mol % num ) end if if ( output == \"-\" ) then if (. not . allocated ( output_format )) output_format = filetype % xyz call write_structure ( mol , output_unit , output_format , error ) else call write_structure ( mol , output , error , output_format ) end if if ( allocated ( error )) then write ( error_unit , '(a)' ) error % message error stop end if contains subroutine help ( unit ) integer , intent ( in ) :: unit write ( unit , '(a, *(1x, a))' ) & \"Usage: \" // prog_name // \" [options] <input> <output>\" write ( unit , '(a)' ) & \"\" , & \"Read structure from input file and writes it to output file.\" , & \"The format is determined by the file extension or the format hint\" , & \"\" write ( unit , '(2x, a, t25, a)' ) & \"-i, --input <format>\" , \"Hint for the format of the input file\" , & \"-o, --output <format>\" , \"Hint for the format of the output file\" , & \"--normalize\" , \"Normalize all element symbols to capitalized format\" , & \"--template <file>\" , \"File to use as template to fill in meta data\" , & \"\" , \"(useful to add back SDF or PDB annotions)\" , & \"--template-format <format>\" , \"\" , \"\" , \"Hint for the format of the template file\" , & \"--version\" , \"Print program version and exit\" , & \"--help\" , \"Show this help message\" write ( unit , '(a)' ) end subroutine help subroutine version ( unit ) integer , intent ( in ) :: unit character ( len = :), allocatable :: version_string call get_mctc_version ( string = version_string ) write ( unit , '(a, *(1x, a))' ) & & prog_name , \"version\" , version_string end subroutine version subroutine get_arguments ( input , input_format , output , output_format , normalize , & & template , template_format , error ) !> Input file name character ( len = :), allocatable :: input !> Input file format integer , allocatable , intent ( out ) :: input_format !> Output file name character ( len = :), allocatable :: output !> Output file format integer , allocatable , intent ( out ) :: output_format !> Template file name character ( len = :), allocatable :: template !> Template file format integer , allocatable , intent ( out ) :: template_format !> Normalize element symbols logical , intent ( out ) :: normalize !> Error handling type ( error_type ), allocatable , intent ( out ) :: error integer :: iarg , narg character ( len = :), allocatable :: arg normalize = . false . iarg = 0 narg = command_argument_count () do while ( iarg < narg ) iarg = iarg + 1 call get_argument ( iarg , arg ) select case ( arg ) case ( \"--help\" ) call help ( output_unit ) stop case ( \"--version\" ) call version ( output_unit ) stop case default if (. not . allocated ( input )) then call move_alloc ( arg , input ) cycle end if if (. not . allocated ( output )) then call move_alloc ( arg , output ) cycle end if call fatal_error ( error , \"Too many positional arguments present\" ) exit case ( \"-i\" , \"--input\" ) iarg = iarg + 1 call get_argument ( iarg , arg ) if (. not . allocated ( arg )) then call fatal_error ( error , \"Missing argument for input format\" ) exit end if input_format = get_filetype ( \".\" // arg ) case ( \"-o\" , \"--output\" ) iarg = iarg + 1 call get_argument ( iarg , arg ) if (. not . allocated ( arg )) then call fatal_error ( error , \"Missing argument for output format\" ) exit end if output_format = get_filetype ( \".\" // arg ) case ( \"--normalize\" ) normalize = . true . case ( \"--template\" ) iarg = iarg + 1 call get_argument ( iarg , template ) if (. not . allocated ( template )) then call fatal_error ( error , \"Missing argument for template file\" ) exit end if case ( \"--template-format\" ) iarg = iarg + 1 call get_argument ( iarg , arg ) if (. not . allocated ( arg )) then call fatal_error ( error , \"Missing argument for template format\" ) exit end if template_format = get_filetype ( \".\" // arg ) end select end do if (. not .( allocated ( input ). and .( allocated ( output )))) then if (. not . allocated ( error )) then call help ( output_unit ) error stop end if end if end subroutine get_arguments end program main","tags":"","loc":"sourcefile/main.f90.html"},{"title":"testsuite_type – MCTC-library ","text":"type, public :: testsuite_type Collection of unit tests Contents Variables collect name Source Code testsuite_type Components Type Visibility Attributes Name Initial procedure( collect_interface ), public, pointer, nopass :: collect => null() Entry point of the test character(len=:), public, allocatable :: name Name of the testsuite Source Code type :: testsuite_type !> Name of the testsuite character ( len = :), allocatable :: name !> Entry point of the test procedure ( collect_interface ), pointer , nopass :: collect => null () end type testsuite_type","tags":"","loc":"type/testsuite_type.html"},{"title":"unittest_type – MCTC-library ","text":"type, public :: unittest_type Declaration of a unit test Contents Variables name should_fail test Source Code unittest_type Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: name Name of the test logical, public :: should_fail = .false. Whether test is supposed to fail procedure( test_interface ), public, pointer, nopass :: test => null() Entry point of the test Source Code type :: unittest_type !> Name of the test character ( len = :), allocatable :: name !> Entry point of the test procedure ( test_interface ), pointer , nopass :: test => null () !> Whether test is supposed to fail logical :: should_fail = . false . end type unittest_type","tags":"","loc":"type/unittest_type.html"},{"title":"error_type – MCTC-library ","text":"type, public :: error_type Error message Contents Variables message stat Source Code error_type Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: message Payload of the error integer, public :: stat Error code Source Code type :: error_type !> Error code integer :: stat !> Payload of the error character ( len = :), allocatable :: message end type error_type","tags":"","loc":"type/error_type.html"},{"title":"structure_type – MCTC-library ","text":"type, public :: structure_type Structure representation Contents Variables bond charge comment id info lattice nat nbd nid num pdb periodic sdf sym uhf xyz Source Code structure_type Components Type Visibility Attributes Name Initial integer, public, allocatable :: bond (:,:) Bond indices real(kind=wp), public :: charge = 0.0_wp Total charge character(len=:), public, allocatable :: comment Comment, name or identifier for this structure integer, public, allocatable :: id (:) Species identifier type( structure_info ), public :: info = structure_info() Vendor specific structure annotations real(kind=wp), public, allocatable :: lattice (:,:) Lattice parameters integer, public :: nat = 0 Number of atoms integer, public :: nbd = 0 Number of bonds integer, public :: nid = 0 Number of unique species integer, public, allocatable :: num (:) Atomic number for each species type( pdb_data ), public, allocatable :: pdb (:) PDB atomic data annotations logical, public, allocatable :: periodic (:) Periodic directions type( sdf_data ), public, allocatable :: sdf (:) SDF atomic data annotations character(len=symbol_length), public, allocatable :: sym (:) Element symbol for each species integer, public :: uhf = 0 Number of unpaired electrons real(kind=wp), public, allocatable :: xyz (:,:) Cartesian coordinates, in Bohr Source Code type :: structure_type !> Number of atoms integer :: nat = 0 !> Number of unique species integer :: nid = 0 !> Number of bonds integer :: nbd = 0 !> Species identifier integer , allocatable :: id (:) !> Atomic number for each species integer , allocatable :: num (:) !> Element symbol for each species character ( len = symbol_length ), allocatable :: sym (:) !> Cartesian coordinates, in Bohr real ( wp ), allocatable :: xyz (:, :) !> Number of unpaired electrons integer :: uhf = 0 !> Total charge real ( wp ) :: charge = 0.0_wp !> Lattice parameters real ( wp ), allocatable :: lattice (:, :) !> Periodic directions logical , allocatable :: periodic (:) !> Bond indices integer , allocatable :: bond (:, :) !> Comment, name or identifier for this structure character ( len = :), allocatable :: comment !> Vendor specific structure annotations type ( structure_info ) :: info = structure_info () !> SDF atomic data annotations type ( sdf_data ), allocatable :: sdf (:) !> PDB atomic data annotations type ( pdb_data ), allocatable :: pdb (:) end type structure_type","tags":"","loc":"type/structure_type.html"},{"title":"pdb_data – MCTC-library ","text":"type, public :: pdb_data Atomic pdb data type. keeps information from PDB input that is currently not used by the\n caller program (like residues or chains) but is needed to write\n the PDB output eventually ATOM   2461  HA3 GLY A 153     -10.977  -7.661   2.011  1.00  0.00           H TER    2462      GLY A 153 a6----i5---xa4--aa3-xai4--axxxf8.3----f8.3----f8.3----f6.2--f6.2--xxxxxxa4--a2a2 HETATM 2463  CHA HEM A 154       9.596 -13.100  10.368  1.00  0.00           C Contents Variables chains charge code het loc name residue residue_number segid Source Code pdb_data Components Type Visibility Attributes Name Initial character(len=1), public :: chains = ' ' integer, public :: charge = 0 character(len=1), public :: code = ' ' logical, public :: het = .false. character(len=1), public :: loc = ' ' character(len=4), public :: name = ' ' character(len=3), public :: residue = ' ' integer, public :: residue_number = 0 character(len=4), public :: segid = ' ' Source Code type :: pdb_data logical :: het = . false . integer :: charge = 0 integer :: residue_number = 0 character ( len = 4 ) :: name = ' ' character ( len = 1 ) :: loc = ' ' character ( len = 3 ) :: residue = ' ' character ( len = 1 ) :: chains = ' ' character ( len = 1 ) :: code = ' ' character ( len = 4 ) :: segid = ' ' end type pdb_data","tags":"","loc":"type/pdb_data.html"},{"title":"sdf_data – MCTC-library ","text":"type, public :: sdf_data SDF atomic data. We only support some entries, the rest is simply dropped.\n the format is: ddcccssshhhbbbvvvHHHrrriiimmmnnneee Contents Variables charge hydrogens isotope valence Source Code sdf_data Components Type Visibility Attributes Name Initial integer, public :: charge = 0 c field integer, public :: hydrogens = 0 h field integer, public :: isotope = 0 d field integer, public :: valence = 0 v field Source Code type :: sdf_data integer :: isotope = 0 !< d field integer :: charge = 0 !< c field integer :: hydrogens = 0 !< h field integer :: valence = 0 !< v field end type sdf_data","tags":"","loc":"type/sdf_data.html"},{"title":"structure_info – MCTC-library ","text":"type, public :: structure_info structure input info contains informations from different input file formats Contents Variables angs_coord angs_lattice cartesian lattice missing_hydrogen scale selective two_dimensional Source Code structure_info Components Type Visibility Attributes Name Initial logical, public :: angs_coord = .false. Unit of the atomic coordinates should be in Angstrom if possible logical, public :: angs_lattice = .false. Unit of the lattice vectors should be in Angstrom if possible logical, public :: cartesian = .true. Periodic coordinates should use preferrably cartesian coordinates logical, public :: lattice = .true. Lattice information should use preferrably lattice vectors logical, public :: missing_hydrogen = .false. SDF hydrogen query present or PDB without hydrogen atoms found real(kind=wp), public :: scale = 1.0_wp Vasp coordinate scaling information logical, public :: selective = .false. Vasp selective dynamics keyword is present logical, public :: two_dimensional = .false. SDF 2D structure present Source Code type :: structure_info !> Vasp coordinate scaling information real ( wp ) :: scale = 1.0_wp !> Vasp selective dynamics keyword is present logical :: selective = . false . !> SDF 2D structure present logical :: two_dimensional = . false . !> SDF hydrogen query present or PDB without hydrogen atoms found logical :: missing_hydrogen = . false . !> Periodic coordinates should use preferrably cartesian coordinates logical :: cartesian = . true . !> Lattice information should use preferrably lattice vectors logical :: lattice = . true . !> Unit of the lattice vectors should be in Angstrom if possible logical :: angs_lattice = . false . !> Unit of the atomic coordinates should be in Angstrom if possible logical :: angs_coord = . false . end type structure_info","tags":"","loc":"type/structure_info.html"},{"title":"collect_interface – MCTC-library","text":"abstract interface public subroutine collect_interface(testsuite) Arguments Type Intent Optional Attributes Name type( unittest_type ), intent(out), allocatable :: testsuite (:) Collection of tests Description Collect all tests","tags":"","loc":"interface/collect_interface.html"},{"title":"test_interface – MCTC-library","text":"abstract interface public subroutine test_interface(error) Arguments Type Intent Optional Attributes Name type( error_type ), intent(out), allocatable :: error Error handling Description Entry point for tests","tags":"","loc":"interface/test_interface.html"},{"title":"structure_reader – MCTC-library","text":"abstract interface public subroutine structure_reader(self, unit, error) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: self Instance of the molecular structure data integer, intent(in) :: unit File handle type( error_type ), intent(out), allocatable :: error Error handling Description Read molecular structure data from formatted unit","tags":"","loc":"interface/structure_reader.html"},{"title":"get_mctc_version – MCTC-library","text":"public subroutine get_mctc_version(major, minor, patch, string) Getter function to retrieve mctc-lib version Arguments Type Intent Optional Attributes Name integer, intent(out), optional :: major Major version number of the mctc-lib version integer, intent(out), optional :: minor Minor version number of the mctc-lib version integer, intent(out), optional :: patch Patch version number of the mctc-lib version character(len=:), intent(out), optional allocatable :: string String representation of the mctc-lib version Contents Source Code get_mctc_version Source Code subroutine get_mctc_version ( major , minor , patch , string ) !> Major version number of the mctc-lib version integer , intent ( out ), optional :: major !> Minor version number of the mctc-lib version integer , intent ( out ), optional :: minor !> Patch version number of the mctc-lib version integer , intent ( out ), optional :: patch !> String representation of the mctc-lib version character ( len = :), allocatable , intent ( out ), optional :: string if ( present ( major )) then major = mctc_version_compact ( 1 ) end if if ( present ( minor )) then minor = mctc_version_compact ( 2 ) end if if ( present ( patch )) then patch = mctc_version_compact ( 3 ) end if if ( present ( string )) then string = mctc_version_string end if end subroutine get_mctc_version","tags":"","loc":"proc/get_mctc_version.html"},{"title":"new_testsuite – MCTC-library","text":"public function new_testsuite(name, collect) result(self) Register a new testsuite Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Name of the testsuite procedure( collect_interface ) :: collect Entry point to collect tests Return Value type( testsuite_type ) Newly registered testsuite Contents Source Code new_testsuite Source Code function new_testsuite ( name , collect ) result ( self ) !> Name of the testsuite character ( len =* ), intent ( in ) :: name !> Entry point to collect tests procedure ( collect_interface ) :: collect !> Newly registered testsuite type ( testsuite_type ) :: self self % name = name self % collect => collect end function new_testsuite","tags":"","loc":"proc/new_testsuite.html"},{"title":"new_unittest – MCTC-library","text":"public function new_unittest(name, test, should_fail) result(self) Register a new unit test Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Name of the test procedure( test_interface ) :: test Entry point for the test logical, intent(in), optional :: should_fail Whether test is supposed to error or not Return Value type( unittest_type ) Newly registered test Contents Source Code new_unittest Source Code function new_unittest ( name , test , should_fail ) result ( self ) !> Name of the test character ( len =* ), intent ( in ) :: name !> Entry point for the test procedure ( test_interface ) :: test !> Whether test is supposed to error or not logical , intent ( in ), optional :: should_fail !> Newly registered test type ( unittest_type ) :: self self % name = name self % test => test if ( present ( should_fail )) self % should_fail = should_fail end function new_unittest","tags":"","loc":"proc/new_unittest.html"},{"title":"select_suite – MCTC-library","text":"public function select_suite(suites, name) result(pos) Select a test suite from all available suites Arguments Type Intent Optional Attributes Name type( testsuite_type ) :: suites (:) Available test suites character(len=*), intent(in) :: name Name identifying the test suite Return Value integer Selected test suite Contents Source Code select_suite Source Code function select_suite ( suites , name ) result ( pos ) !> Name identifying the test suite character ( len =* ), intent ( in ) :: name !> Available test suites type ( testsuite_type ) :: suites (:) !> Selected test suite integer :: pos integer :: it pos = 0 do it = 1 , size ( suites ) if ( name == suites ( it )% name ) then pos = it exit end if end do end function select_suite","tags":"","loc":"proc/select_suite.html"},{"title":"select_test – MCTC-library","text":"public function select_test(tests, name) result(pos) Select a unit test from all available tests Arguments Type Intent Optional Attributes Name type( unittest_type ) :: tests (:) Available unit tests character(len=*), intent(in) :: name Name identifying the test suite Return Value integer Selected test suite Contents Source Code select_test Source Code function select_test ( tests , name ) result ( pos ) !> Name identifying the test suite character ( len =* ), intent ( in ) :: name !> Available unit tests type ( unittest_type ) :: tests (:) !> Selected test suite integer :: pos integer :: it pos = 0 do it = 1 , size ( tests ) if ( name == tests ( it )% name ) then pos = it exit end if end do end function select_test","tags":"","loc":"proc/select_test.html"},{"title":"run_selected – MCTC-library","text":"public subroutine run_selected(collect, name, unit, stat) Driver for selective testing Arguments Type Intent Optional Attributes Name procedure( collect_interface ) :: collect Collect tests character(len=*), intent(in) :: name Name of the selected test integer, intent(in) :: unit Unit for IO integer, intent(inout) :: stat Number of failed tests Contents Source Code run_selected Source Code subroutine run_selected ( collect , name , unit , stat ) !> Collect tests procedure ( collect_interface ) :: collect !> Name of the selected test character ( len =* ), intent ( in ) :: name !> Unit for IO integer , intent ( in ) :: unit !> Number of failed tests integer , intent ( inout ) :: stat type ( unittest_type ), allocatable :: testsuite (:) integer :: ii call collect ( testsuite ) ii = select_test ( testsuite , name ) if ( ii > 0 . and . ii <= size ( testsuite )) then call run_unittest ( testsuite ( ii ), unit , stat ) else write ( unit , fmt ) \"Available tests:\" do ii = 1 , size ( testsuite ) write ( unit , fmt ) \"-\" , testsuite ( ii )% name end do stat = - huge ( ii ) end if end subroutine run_selected","tags":"","loc":"proc/run_selected.html"},{"title":"run_testsuite – MCTC-library","text":"public subroutine run_testsuite(collect, unit, stat) Driver for testsuite Arguments Type Intent Optional Attributes Name procedure( collect_interface ) :: collect Collect tests integer, intent(in) :: unit Unit for IO integer, intent(inout) :: stat Number of failed tests Contents Source Code run_testsuite Source Code subroutine run_testsuite ( collect , unit , stat ) !> Collect tests procedure ( collect_interface ) :: collect !> Unit for IO integer , intent ( in ) :: unit !> Number of failed tests integer , intent ( inout ) :: stat type ( unittest_type ), allocatable :: testsuite (:) integer :: ii call collect ( testsuite ) !$omp parallel do shared(testsuite, unit) reduction(+:stat) do ii = 1 , size ( testsuite ) !$omp critical(mctc_env_testsuite) write ( unit , '(1x, 3(1x, a), 1x, \"(\", i0, \"/\", i0, \")\")' ) & & \"Starting\" , testsuite ( ii )% name , \"...\" , ii , size ( testsuite ) !$omp end critical(mctc_env_testsuite) call run_unittest ( testsuite ( ii ), unit , stat ) end do end subroutine run_testsuite","tags":"","loc":"proc/run_testsuite.html"},{"title":"test_failed – MCTC-library","text":"public subroutine test_failed(error, message, more) Arguments Type Intent Optional Attributes Name type( error_type ), intent(out), allocatable :: error Error handling character(len=*), intent(in) :: message A detailed message describing the error character(len=*), intent(in), optional :: more Another line of error message Contents Source Code test_failed Source Code subroutine test_failed ( error , message , more ) !> Error handling type ( error_type ), allocatable , intent ( out ) :: error !> A detailed message describing the error character ( len =* ), intent ( in ) :: message !> Another line of error message character ( len =* ), intent ( in ), optional :: more allocate ( error ) error % stat = mctc_stat % fatal if ( present ( more )) then error % message = message // new_line ( 'a' ) // more else error % message = message end if end subroutine test_failed","tags":"","loc":"proc/test_failed.html"},{"title":"check – MCTC-library","text":"public interface check Contents Module Procedures check_stat check_logical check_float_sp check_float_dp check_int_i1 check_int_i2 check_int_i4 check_int_i8 check_bool check_string Module Procedures private subroutine check_stat(error, stat, message, more) Arguments Type Intent Optional Attributes Name type( error_type ), intent(out), allocatable :: error Error handling integer, intent(in) :: stat Status of operation character(len=*), intent(in), optional :: message A detailed message describing the error character(len=*), intent(in), optional :: more Another line of error message private subroutine check_logical(error, expression, message, more) Arguments Type Intent Optional Attributes Name type( error_type ), intent(out), allocatable :: error Error handling logical, intent(in) :: expression Result of logical operator character(len=*), intent(in), optional :: message A detailed message describing the error character(len=*), intent(in), optional :: more Another line of error message private subroutine check_float_sp(error, actual, expected, message, more, thr, rel) Arguments Type Intent Optional Attributes Name type( error_type ), intent(out), allocatable :: error Error handling real(kind=sp), intent(in) :: actual Found floating point value real(kind=sp), intent(in) :: expected Expected floating point value character(len=*), intent(in), optional :: message A detailed message describing the error character(len=*), intent(in), optional :: more Another line of error message real(kind=sp), intent(in), optional :: thr Allowed threshold for matching floating point values logical, intent(in), optional :: rel Check for relative errors instead private subroutine check_float_dp(error, actual, expected, message, more, thr, rel) Arguments Type Intent Optional Attributes Name type( error_type ), intent(out), allocatable :: error Error handling real(kind=dp), intent(in) :: actual Found floating point value real(kind=dp), intent(in) :: expected Expected floating point value character(len=*), intent(in), optional :: message A detailed message describing the error character(len=*), intent(in), optional :: more Another line of error message real(kind=dp), intent(in), optional :: thr Allowed threshold for matching floating point values logical, intent(in), optional :: rel Check for relative errors instead private subroutine check_int_i1(error, actual, expected, message, more) Arguments Type Intent Optional Attributes Name type( error_type ), intent(out), allocatable :: error Error handling integer(kind=i1), intent(in) :: actual Found integer value integer(kind=i1), intent(in) :: expected Expected integer value character(len=*), intent(in), optional :: message A detailed message describing the error character(len=*), intent(in), optional :: more Another line of error message private subroutine check_int_i2(error, actual, expected, message, more) Arguments Type Intent Optional Attributes Name type( error_type ), intent(out), allocatable :: error Error handling integer(kind=i2), intent(in) :: actual Found integer value integer(kind=i2), intent(in) :: expected Expected integer value character(len=*), intent(in), optional :: message A detailed message describing the error character(len=*), intent(in), optional :: more Another line of error message private subroutine check_int_i4(error, actual, expected, message, more) Arguments Type Intent Optional Attributes Name type( error_type ), intent(out), allocatable :: error Error handling integer(kind=i4), intent(in) :: actual Found integer value integer(kind=i4), intent(in) :: expected Expected integer value character(len=*), intent(in), optional :: message A detailed message describing the error character(len=*), intent(in), optional :: more Another line of error message private subroutine check_int_i8(error, actual, expected, message, more) Arguments Type Intent Optional Attributes Name type( error_type ), intent(out), allocatable :: error Error handling integer(kind=i8), intent(in) :: actual Found integer value integer(kind=i8), intent(in) :: expected Expected integer value character(len=*), intent(in), optional :: message A detailed message describing the error character(len=*), intent(in), optional :: more Another line of error message private subroutine check_bool(error, actual, expected, message, more) Arguments Type Intent Optional Attributes Name type( error_type ), intent(out), allocatable :: error Error handling logical, intent(in) :: actual Found boolean value logical, intent(in) :: expected Expected boolean value character(len=*), intent(in), optional :: message A detailed message describing the error character(len=*), intent(in), optional :: more Another line of error message private subroutine check_string(error, actual, expected, message, more) Arguments Type Intent Optional Attributes Name type( error_type ), intent(out), allocatable :: error Error handling character(len=*), intent(in) :: actual Found boolean value character(len=*), intent(in) :: expected Expected boolean value character(len=*), intent(in), optional :: message A detailed message describing the error character(len=*), intent(in), optional :: more Another line of error message","tags":"","loc":"interface/check.html"},{"title":"is_unix – MCTC-library","text":"public function is_unix() Try to determine if we run on Unix and probably can rely on POSIX compliance Arguments None Return Value logical Operating system seems to be Unix Contents Source Code is_unix Source Code function is_unix () !> Operating system seems to be Unix logical :: is_unix character ( len = :), allocatable :: tmp is_unix = . not . is_windows () end function is_unix","tags":"","loc":"proc/is_unix.html"},{"title":"is_windows – MCTC-library","text":"public function is_windows() Try to determine if we run on Windows and don’t have POSIX compliance around Arguments None Return Value logical Operating system seems to be Windows Contents Source Code is_windows Source Code function is_windows () !> Operating system seems to be Windows logical :: is_windows character ( len = :), allocatable :: tmp is_windows = . false . call get_variable ( 'OS' , tmp ) if ( allocated ( tmp )) then is_windows = index ( tmp , 'Windows_NT' ) > 0 end if if (. not . is_windows ) then call get_variable ( 'OSTYPE' , tmp ) if ( allocated ( tmp )) then is_windows = index ( tmp , 'win' ) > 0 . or . index ( tmp , 'msys' ) > 0 end if end if end function is_windows","tags":"","loc":"proc/is_windows.html"},{"title":"get_argument – MCTC-library","text":"public subroutine get_argument(idx, arg) Obtain the command line argument at a given index Arguments Type Intent Optional Attributes Name integer, intent(in) :: idx Index of command line argument, range [0:command_argument_count()] character(len=:), intent(out), allocatable :: arg Command line argument Contents Source Code get_argument Source Code subroutine get_argument ( idx , arg ) !> Index of command line argument, range [0:command_argument_count()] integer , intent ( in ) :: idx !> Command line argument character ( len = :), allocatable , intent ( out ) :: arg integer :: length , stat call get_command_argument ( idx , length = length , status = stat ) if ( stat /= 0 ) then return endif allocate ( character ( len = length ) :: arg , stat = stat ) if ( stat /= 0 ) then return endif if ( length > 0 ) then call get_command_argument ( idx , arg , status = stat ) if ( stat /= 0 ) then deallocate ( arg ) return end if end if end subroutine get_argument","tags":"","loc":"proc/get_argument.html"},{"title":"get_variable – MCTC-library","text":"public subroutine get_variable(var, val) Obtain the value of an environment variable Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: var Name of variable character(len=:), intent(out), allocatable :: val Value of variable Contents Source Code get_variable Source Code subroutine get_variable ( var , val ) !> Name of variable character ( len =* ), intent ( in ) :: var !> Value of variable character ( len = :), allocatable , intent ( out ) :: val integer :: length , stat call get_environment_variable ( var , length = length , status = stat ) if ( stat /= 0 ) then return endif allocate ( character ( len = length ) :: val , stat = stat ) if ( stat /= 0 ) then return endif if ( length > 0 ) then call get_environment_variable ( var , val , status = stat ) if ( stat /= 0 ) then deallocate ( val ) return end if end if end subroutine get_variable","tags":"","loc":"proc/get_variable.html"},{"title":"fatal_error – MCTC-library","text":"public subroutine fatal_error(error, message, stat) A fatal error is encountered Arguments Type Intent Optional Attributes Name type( error_type ), intent(out), allocatable :: error Instance of the error character(len=*), intent(in), optional :: message A detailed message describing the error and (optionally) offering advice integer, intent(in), optional :: stat Overwrite of the error code Contents Source Code fatal_error Source Code subroutine fatal_error ( error , message , stat ) !> Instance of the error type ( error_type ), allocatable , intent ( out ) :: error !> A detailed message describing the error and (optionally) offering advice character ( len =* ), intent ( in ), optional :: message !> Overwrite of the error code integer , intent ( in ), optional :: stat allocate ( error ) if ( present ( stat )) then error % stat = stat else error % stat = mctc_stat % fatal end if if ( present ( message )) then error % message = message else error % message = \"Fatal error\" end if end subroutine fatal_error","tags":"","loc":"proc/fatal_error.html"},{"title":"to_lcsymbol – MCTC-library","text":"public elemental function to_lcsymbol(number) result(symbol) Convert atomic number to element symbol Arguments Type Intent Optional Attributes Name integer, intent(in) :: number Atomic number Return Value character(len=2) Element symbol Contents Source Code to_lcsymbol Source Code elemental function to_lcsymbol ( number ) result ( symbol ) !> Atomic number integer , intent ( in ) :: number !> Element symbol character ( len = 2 ) :: symbol call number_to_lcsymbol ( symbol , number ) end function to_lcsymbol","tags":"","loc":"proc/to_lcsymbol.html"},{"title":"to_number – MCTC-library","text":"public elemental function to_number(symbol) result(number) Convert element symbol to atomic number Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: symbol Element symbol Return Value integer Atomic number Contents Source Code to_number Source Code elemental function to_number ( symbol ) result ( number ) !> Element symbol character ( len =* ), intent ( in ) :: symbol !> Atomic number integer :: number call symbol_to_number ( number , symbol ) end function to_number","tags":"","loc":"proc/to_number.html"},{"title":"to_symbol – MCTC-library","text":"public elemental function to_symbol(number) result(symbol) Convert atomic number to element symbol Arguments Type Intent Optional Attributes Name integer, intent(in) :: number Atomic number Return Value character(len=2) Element symbol Contents Source Code to_symbol Source Code elemental function to_symbol ( number ) result ( symbol ) !> Atomic number integer , intent ( in ) :: number !> Element symbol character ( len = 2 ) :: symbol call number_to_symbol ( symbol , number ) end function to_symbol","tags":"","loc":"proc/to_symbol.html"},{"title":"collect_identical – MCTC-library","text":"public pure subroutine collect_identical(identity, mapping) Establish a mapping between unique atom types and species Arguments Type Intent Optional Attributes Name integer, intent(in) :: identity (:) Chemical identity integer, intent(out) :: mapping (:) Mapping from unique atoms Contents Source Code collect_identical Source Code pure subroutine collect_identical ( identity , mapping ) !> Chemical identity integer , intent ( in ) :: identity (:) !> Mapping from unique atoms integer , intent ( out ) :: mapping (:) integer :: iid , iat do iid = 1 , size ( mapping ) do iat = 1 , size ( identity ) if ( identity ( iat ) == iid ) then mapping ( iid ) = iat exit end if end do end do end subroutine collect_identical","tags":"","loc":"proc/collect_identical.html"},{"title":"number_to_lcsymbol – MCTC-library","text":"public elemental subroutine number_to_lcsymbol(symbol, number) Convert atomic number to element symbol Arguments Type Intent Optional Attributes Name character(len=2), intent(out) :: symbol Element symbol integer, intent(in) :: number Atomic number Contents Source Code number_to_lcsymbol Source Code elemental subroutine number_to_lcsymbol ( symbol , number ) !> Atomic number integer , intent ( in ) :: number !> Element symbol character ( len = 2 ), intent ( out ) :: symbol if ( number <= 0 . or . number > size ( lcpse )) then symbol = '--' else symbol = lcpse ( number ) endif end subroutine number_to_lcsymbol","tags":"","loc":"proc/number_to_lcsymbol.html"},{"title":"number_to_symbol – MCTC-library","text":"public elemental subroutine number_to_symbol(symbol, number) Convert atomic number to element symbol Arguments Type Intent Optional Attributes Name character(len=2), intent(out) :: symbol Element symbol integer, intent(in) :: number Atomic number Contents Source Code number_to_symbol Source Code elemental subroutine number_to_symbol ( symbol , number ) !> Atomic number integer , intent ( in ) :: number !> Element symbol character ( len = 2 ), intent ( out ) :: symbol if ( number <= 0 . or . number > size ( pse )) then symbol = '--' else symbol = pse ( number ) endif end subroutine number_to_symbol","tags":"","loc":"proc/number_to_symbol.html"},{"title":"symbol_to_number – MCTC-library","text":"public elemental subroutine symbol_to_number(number, symbol) Convert element symbol to atomic number Arguments Type Intent Optional Attributes Name integer, intent(out) :: number Atomic number character(len=*), intent(in) :: symbol Element symbol Contents Source Code symbol_to_number Source Code elemental subroutine symbol_to_number ( number , symbol ) !> Element symbol character ( len =* ), intent ( in ) :: symbol !> Atomic number integer , intent ( out ) :: number character ( len = 2 ) :: lcsymbol integer :: i , j , k , l number = 0 lcsymbol = '  ' k = 0 do j = 1 , len_trim ( symbol ) if ( k > 2 ) exit l = iachar ( symbol ( j : j )) if ( k >= 1 . and . l == iachar ( ' ' )) exit if ( k >= 1 . and . l == 9 ) exit if ( l >= iachar ( 'A' ) . and . l <= iachar ( 'Z' )) l = l + offset if ( l >= iachar ( 'a' ) . and . l <= iachar ( 'z' )) then k = k + 1 if ( k > 2 ) exit lcsymbol ( k : k ) = achar ( l ) endif enddo do i = 1 , size ( lcpse ) if ( lcsymbol == lcpse ( i )) then number = i exit endif enddo if ( number == 0 ) then select case ( lcsymbol ) case ( 'd ' , 't ' ) number = 1 end select end if end subroutine symbol_to_number","tags":"","loc":"proc/symbol_to_number.html"},{"title":"get_identity – MCTC-library","text":"public interface get_identity Get chemical identity Contents Module Procedures get_identity_number get_identity_symbol Module Procedures private pure subroutine get_identity_number(nid, identity, number) Get chemical identity from a list of atomic numbers Arguments Type Intent Optional Attributes Name integer, intent(out) :: nid Number of unique species integer, intent(out) :: identity (:) Chemical identity integer, intent(in) :: number (:) Ordinal numbers private pure subroutine get_identity_symbol(nid, identity, symbol) Get chemical identity from a list of element symbols Arguments Type Intent Optional Attributes Name integer, intent(out) :: nid Number of unique species integer, intent(out) :: identity (:) Chemical identity character(len=symbol_length), intent(in) :: symbol (:) Element symbols","tags":"","loc":"interface/get_identity.html"},{"title":"get_filetype – MCTC-library","text":"public elemental function get_filetype(file) result(ftype) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file Name of the file Return Value integer File type from extension Contents Source Code get_filetype Source Code elemental function get_filetype ( file ) result ( ftype ) !> Name of the file character ( len =* ), intent ( in ) :: file !> File type from extension integer :: ftype integer :: iext , isep ftype = filetype % unknown iext = index ( file , '.' , back = . true .) isep = scan ( file , '\\/' , back = . true .) if ( iext > isep . and . iext > 0 ) then select case ( to_lower ( file ( iext + 1 :))) case ( 'coord' , 'tmol' ) ftype = filetype % tmol case ( 'xyz' , 'log' ) ftype = filetype % xyz case ( 'mol' ) ftype = filetype % molfile case ( 'sdf' ) ftype = filetype % sdf case ( 'poscar' , 'contcar' , 'vasp' ) ftype = filetype % vasp case ( 'pdb' ) ftype = filetype % pdb case ( 'gen' ) ftype = filetype % gen case ( 'ein' ) ftype = filetype % gaussian end select if ( ftype /= filetype % unknown ) return else iext = len ( file ) + 1 end if if ( iext > isep ) then select case ( to_lower ( file ( isep + 1 : iext - 1 ))) case ( 'coord' ) ftype = filetype % tmol case ( 'poscar' , 'contcar' ) ftype = filetype % vasp end select end if end function get_filetype","tags":"","loc":"proc/get_filetype.html"},{"title":"getline – MCTC-library","text":"public subroutine getline(unit, line, iostat, iomsg) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit Formatted IO unit character(len=:), intent(out), allocatable :: line Line to read integer, intent(out) :: iostat Status of operation character(len=:), optional allocatable :: iomsg Error message Contents Source Code getline Source Code subroutine getline ( unit , line , iostat , iomsg ) !> Formatted IO unit integer , intent ( in ) :: unit !> Line to read character ( len = :), allocatable , intent ( out ) :: line !> Status of operation integer , intent ( out ) :: iostat !> Error message character ( len = :), allocatable , optional :: iomsg integer , parameter :: bufsize = 512 character ( len = bufsize ) :: buffer character ( len = bufsize ) :: msg integer :: size integer :: stat allocate ( character ( len = 0 ) :: line ) do read ( unit , '(a)' , advance = 'no' , iostat = stat , iomsg = msg , size = size ) & & buffer if ( stat > 0 ) exit line = line // buffer (: size ) if ( stat < 0 ) then if ( is_iostat_eor ( stat )) then stat = 0 end if exit end if end do if ( stat /= 0 ) then if ( present ( iomsg )) iomsg = trim ( msg ) end if iostat = stat end subroutine getline","tags":"","loc":"proc/getline.html"},{"title":"new_structure – MCTC-library","text":"public subroutine new_structure(self, num, sym, xyz, charge, uhf, lattice, periodic, info, bond) Constructor for structure representations Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: self Instance of the structure representation integer, intent(in) :: num (:) Atomic numbers character(len=*), intent(in) :: sym (:) Element symbols real(kind=wp), intent(in) :: xyz (:,:) Cartesian coordinates real(kind=wp), intent(in), optional :: charge Total charge integer, intent(in), optional :: uhf Number of unpaired electrons real(kind=wp), intent(in), optional :: lattice (:,:) Lattice parameters logical, intent(in), optional :: periodic (:) Periodic directions type( structure_info ), intent(in), optional :: info Vendor specific structure information integer, intent(in), optional :: bond (:,:) Bond topology of the system Contents Source Code new_structure Source Code subroutine new_structure ( self , num , sym , xyz , charge , uhf , lattice , periodic , & & info , bond ) !> Instance of the structure representation type ( structure_type ), intent ( out ) :: self !> Atomic numbers integer , intent ( in ) :: num (:) !> Element symbols character ( len =* ), intent ( in ) :: sym (:) !> Cartesian coordinates real ( wp ), intent ( in ) :: xyz (:, :) !> Total charge real ( wp ), intent ( in ), optional :: charge !> Number of unpaired electrons integer , intent ( in ), optional :: uhf !> Lattice parameters real ( wp ), intent ( in ), optional :: lattice (:, :) !> Periodic directions logical , intent ( in ), optional :: periodic (:) !> Vendor specific structure information type ( structure_info ), intent ( in ), optional :: info !> Bond topology of the system integer , intent ( in ), optional :: bond (:, :) integer :: ndim , iid integer , allocatable :: map (:) ndim = min ( size ( num , 1 ), size ( xyz , 2 ), size ( sym , 1 )) self % nat = ndim allocate ( self % id ( ndim )) allocate ( self % xyz ( 3 , ndim )) if ( present ( lattice )) then self % lattice = lattice end if if ( present ( periodic )) then self % periodic = periodic else if ( present ( lattice )) then allocate ( self % periodic ( 3 )) self % periodic (:) = . true . else allocate ( self % periodic ( 1 )) self % periodic (:) = . false . end if end if call get_identity ( self % nid , self % id , sym ) allocate ( map ( self % nid )) call collect_identical ( self % id , map ) allocate ( self % num ( self % nid )) allocate ( self % sym ( self % nid )) do iid = 1 , self % nid self % num ( iid ) = num ( map ( iid )) self % sym ( iid ) = sym ( map ( iid )) end do self % xyz (:, :) = xyz (:, : ndim ) if ( present ( charge )) then self % charge = charge else self % charge = 0.0_wp end if if ( present ( uhf )) then self % uhf = uhf else self % uhf = 0 end if if ( present ( info )) then self % info = info else self % info = structure_info () end if if ( present ( bond )) then self % nbd = size ( bond , 2 ) self % bond = bond end if end subroutine new_structure","tags":"","loc":"proc/new_structure.html"},{"title":"new – MCTC-library","text":"public interface new Contents Module Procedures new_structure new_structure_num new_structure_sym Module Procedures public subroutine new_structure (self, num, sym, xyz, charge, uhf, lattice, periodic, info, bond) Constructor for structure representations Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: self Instance of the structure representation integer, intent(in) :: num (:) Atomic numbers character(len=*), intent(in) :: sym (:) Element symbols real(kind=wp), intent(in) :: xyz (:,:) Cartesian coordinates real(kind=wp), intent(in), optional :: charge Total charge integer, intent(in), optional :: uhf Number of unpaired electrons real(kind=wp), intent(in), optional :: lattice (:,:) Lattice parameters logical, intent(in), optional :: periodic (:) Periodic directions type( structure_info ), intent(in), optional :: info Vendor specific structure information integer, intent(in), optional :: bond (:,:) Bond topology of the system private subroutine new_structure_num(self, num, xyz, charge, uhf, lattice, periodic, info, bond) Simplified constructor for structure representations Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: self Instance of the structure representation integer, intent(in) :: num (:) Atomic numbers real(kind=wp), intent(in) :: xyz (:,:) Cartesian coordinates real(kind=wp), intent(in), optional :: charge Total charge integer, intent(in), optional :: uhf Number of unpaired electrons real(kind=wp), intent(in), optional :: lattice (:,:) Lattice parameters logical, intent(in), optional :: periodic (:) Periodic directions type( structure_info ), intent(in), optional :: info Vendor specific structure information integer, intent(in), optional :: bond (:,:) Bond topology of the system private subroutine new_structure_sym(self, sym, xyz, charge, uhf, lattice, periodic, info, bond) Simplified constructor for structure representations Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: self Instance of the structure representation character(len=*), intent(in) :: sym (:) Element symbols real(kind=wp), intent(in) :: xyz (:,:) Cartesian coordinates real(kind=wp), intent(in), optional :: charge Total charge integer, intent(in), optional :: uhf Number of unpaired electrons real(kind=wp), intent(in), optional :: lattice (:,:) Lattice parameters logical, intent(in), optional :: periodic (:) Periodic directions type( structure_info ), intent(in), optional :: info Vendor specific structure information integer, intent(in), optional :: bond (:,:) Bond topology of the system","tags":"","loc":"interface/new.html"},{"title":"resize – MCTC-library","text":"public interface resize Overloaded resize interface Contents Module Procedures resize_char resize_int resize_real resize_real_2d Module Procedures private pure subroutine resize_char(var, n) Reallocate list of characters Arguments Type Intent Optional Attributes Name character(len=*), intent(inout), allocatable :: var (:) Instance of the array to be resized integer, intent(in), optional :: n Dimension of the final array size private pure subroutine resize_int(var, n) Reallocate list of integers Arguments Type Intent Optional Attributes Name integer, intent(inout), allocatable :: var (:) Instance of the array to be resized integer, intent(in), optional :: n Dimension of the final array size private pure subroutine resize_real(var, n) Reallocate list of reals Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), allocatable :: var (:) Instance of the array to be resized integer, intent(in), optional :: n Dimension of the final array size private pure subroutine resize_real_2d(var, n) Reallocate list of reals Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), allocatable :: var (:,:) Instance of the array to be resized integer, intent(in), optional :: n Dimension of the final array size","tags":"","loc":"interface/resize.html"},{"title":"get_structure_reader – MCTC-library","text":"public subroutine get_structure_reader(reader, ftype) Retrieve reader for corresponding file type Arguments Type Intent Optional Attributes Name procedure( structure_reader ), intent(out), pointer :: reader Reader for the specified file type integer, intent(in) :: ftype File type to read Contents Source Code get_structure_reader Source Code subroutine get_structure_reader ( reader , ftype ) !> Reader for the specified file type procedure ( structure_reader ), pointer , intent ( out ) :: reader !> File type to read integer , intent ( in ) :: ftype nullify ( reader ) select case ( ftype ) case ( filetype % xyz ) reader => read_xyz case ( filetype % molfile ) reader => read_molfile case ( filetype % pdb ) reader => read_pdb case ( filetype % gen ) reader => read_genformat case ( filetype % sdf ) reader => read_sdf case ( filetype % vasp ) reader => read_vasp case ( filetype % tmol ) reader => read_coord case ( filetype % gaussian ) reader => read_gaussian_external end select end subroutine get_structure_reader","tags":"","loc":"proc/get_structure_reader.html"},{"title":"read_structure – MCTC-library","text":"public interface read_structure Contents Module Procedures read_structure_from_file read_structure_from_unit Module Procedures private subroutine read_structure_from_file(self, file, error, format) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: self Instance of the molecular structure data character(len=*), intent(in) :: file Name of the file to read type( error_type ), intent(out), allocatable :: error Error handling integer, intent(in), optional :: format File type format hint private subroutine read_structure_from_unit(self, unit, ftype, error) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: self Instance of the molecular structure data integer, intent(in) :: unit File handle integer, intent(in) :: ftype File type to read type( error_type ), intent(out), allocatable :: error Error handling","tags":"","loc":"interface/read_structure.html"},{"title":"write_structure – MCTC-library","text":"public interface write_structure Contents Module Procedures write_structure_to_file write_structure_to_unit Module Procedures private subroutine write_structure_to_file(self, file, error, format) Arguments Type Intent Optional Attributes Name class( structure_type ), intent(in) :: self Instance of the molecular structure data character(len=*), intent(in) :: file Name of the file to read type( error_type ), intent(out), allocatable :: error Error handling integer, intent(in), optional :: format File type format hint private subroutine write_structure_to_unit(self, unit, ftype, error) Arguments Type Intent Optional Attributes Name class( structure_type ), intent(in) :: self Instance of the molecular structure data integer, intent(in) :: unit File handle integer, intent(in) :: ftype File type to read type( error_type ), intent(out), allocatable :: error Error handling","tags":"","loc":"interface/write_structure.html"},{"title":"crossprod – MCTC-library","text":"public pure function crossprod(a, b) result(c) Implements the cross/vector product between two 3D vectors Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (3) First vector real(kind=wp), intent(in) :: b (3) Second vector Return Value real(kind=wp)\n  (3) Orthogonal vector Contents Source Code crossprod Source Code pure function crossprod ( a , b ) result ( c ) !> First vector real ( wp ), intent ( in ) :: a ( 3 ) !> Second vector real ( wp ), intent ( in ) :: b ( 3 ) !> Orthogonal vector real ( wp ) :: c ( 3 ) c ( 1 ) = a ( 2 ) * b ( 3 ) - b ( 2 ) * a ( 3 ) c ( 2 ) = a ( 3 ) * b ( 1 ) - b ( 3 ) * a ( 1 ) c ( 3 ) = a ( 1 ) * b ( 2 ) - b ( 1 ) * a ( 2 ) end function crossprod","tags":"","loc":"proc/crossprod.html"},{"title":"matdet_3x3 – MCTC-library","text":"public pure function matdet_3x3(a) result(det) Determinat of 3×3 matrix Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (3,3) Matrix Return Value real(kind=wp) Determinant Contents Source Code matdet_3x3 Source Code pure function matdet_3x3 ( a ) result ( det ) !> Matrix real ( wp ), intent ( in ) :: a ( 3 , 3 ) !> Determinant real ( wp ) :: det det = a ( 1 , 1 ) * a ( 2 , 2 ) * a ( 3 , 3 ) & & - a ( 1 , 1 ) * a ( 2 , 3 ) * a ( 3 , 2 ) & & - a ( 1 , 2 ) * a ( 2 , 1 ) * a ( 3 , 3 ) & & + a ( 1 , 2 ) * a ( 2 , 3 ) * a ( 3 , 1 ) & & + a ( 1 , 3 ) * a ( 2 , 1 ) * a ( 3 , 2 ) & & - a ( 1 , 3 ) * a ( 2 , 2 ) * a ( 3 , 1 ) end function matdet_3x3","tags":"","loc":"proc/matdet_3x3.html"},{"title":"matinv_3x3 – MCTC-library","text":"public pure function matinv_3x3(a) result(b) Performs a direct calculation of the inverse of a 3×3 matrix. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (3,3) Matrix Return Value real(kind=wp)\n  (3,3) Inverse matrix Contents Source Code matinv_3x3 Source Code pure function matinv_3x3 ( a ) result ( b ) !> Matrix real ( wp ), intent ( in ) :: a ( 3 , 3 ) !> Inverse matrix real ( wp ) :: b ( 3 , 3 ) real ( wp ) :: detinv ! Calculate the inverse determinant of the matrix detinv = 1.0_wp / matdet_3x3 ( a ) ! Calculate the inverse of the matrix b ( 1 , 1 ) = + detinv * ( a ( 2 , 2 ) * a ( 3 , 3 ) - a ( 2 , 3 ) * a ( 3 , 2 )) b ( 2 , 1 ) = - detinv * ( a ( 2 , 1 ) * a ( 3 , 3 ) - a ( 2 , 3 ) * a ( 3 , 1 )) b ( 3 , 1 ) = + detinv * ( a ( 2 , 1 ) * a ( 3 , 2 ) - a ( 2 , 2 ) * a ( 3 , 1 )) b ( 1 , 2 ) = - detinv * ( a ( 1 , 2 ) * a ( 3 , 3 ) - a ( 1 , 3 ) * a ( 3 , 2 )) b ( 2 , 2 ) = + detinv * ( a ( 1 , 1 ) * a ( 3 , 3 ) - a ( 1 , 3 ) * a ( 3 , 1 )) b ( 3 , 2 ) = - detinv * ( a ( 1 , 1 ) * a ( 3 , 2 ) - a ( 1 , 2 ) * a ( 3 , 1 )) b ( 1 , 3 ) = + detinv * ( a ( 1 , 2 ) * a ( 2 , 3 ) - a ( 1 , 3 ) * a ( 2 , 2 )) b ( 2 , 3 ) = - detinv * ( a ( 1 , 1 ) * a ( 2 , 3 ) - a ( 1 , 3 ) * a ( 2 , 1 )) b ( 3 , 3 ) = + detinv * ( a ( 1 , 1 ) * a ( 2 , 2 ) - a ( 1 , 2 ) * a ( 2 , 1 )) end function matinv_3x3","tags":"","loc":"proc/matinv_3x3.html"},{"title":"eigval_3x3 – MCTC-library","text":"public pure subroutine eigval_3x3(a, w) Calculates eigenvalues based on the trigonometric solution of A = pB + qI Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (3,3) The symmetric input matrix real(kind=wp), intent(out) :: w (3) Contains eigenvalues on exit Contents Source Code eigval_3x3 Source Code pure subroutine eigval_3x3 ( a , w ) !> The symmetric input matrix real ( wp ), intent ( in ) :: a ( 3 , 3 ) !> Contains eigenvalues on exit real ( wp ), intent ( out ) :: w ( 3 ) real ( wp ) :: q , p , r r = a ( 1 , 2 ) * a ( 1 , 2 ) + a ( 1 , 3 ) * a ( 1 , 3 ) + a ( 2 , 3 ) * a ( 2 , 3 ) q = ( a ( 1 , 1 ) + a ( 2 , 2 ) + a ( 3 , 3 )) / 3.0_wp w ( 1 ) = a ( 1 , 1 ) - q w ( 2 ) = a ( 2 , 2 ) - q w ( 3 ) = a ( 3 , 3 ) - q p = sqrt (( w ( 1 ) * w ( 1 ) + w ( 2 ) * w ( 2 ) + w ( 3 ) * w ( 3 ) + 2 * r ) / 6.0_wp ) r = ( w ( 1 ) * ( w ( 2 ) * w ( 3 ) - a ( 2 , 3 ) * a ( 2 , 3 )) & & - a ( 1 , 2 ) * ( a ( 1 , 2 ) * w ( 3 ) - a ( 2 , 3 ) * a ( 1 , 3 )) & & + a ( 1 , 3 ) * ( a ( 1 , 2 ) * a ( 2 , 3 ) - w ( 2 ) * a ( 1 , 3 ))) / ( p * p * p ) * 0.5_wp if ( r <= - 1.0_wp ) then r = 0.5_wp * twothirdpi else if ( r >= 1.0_wp ) then r = 0.0_wp else r = acos ( r ) / 3.0_wp end if w ( 3 ) = q + 2 * p * cos ( r ) w ( 1 ) = q + 2 * p * cos ( r + twothirdpi ) w ( 2 ) = 3 * q - w ( 1 ) - w ( 3 ) end subroutine eigval_3x3","tags":"","loc":"proc/eigval_3x3.html"},{"title":"eigvec_3x3 – MCTC-library","text":"public pure subroutine eigvec_3x3(a, w, q) Calculates eigenvector using an analytical method based on vector cross Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (3,3) real(kind=wp), intent(out) :: w (3) real(kind=wp), intent(out) :: q (3,3) Contents Source Code eigvec_3x3 Source Code pure subroutine eigvec_3x3 ( a , w , q ) real ( wp ), intent ( inout ) :: a ( 3 , 3 ) real ( wp ), intent ( out ) :: w ( 3 ) real ( wp ), intent ( out ) :: q ( 3 , 3 ) real ( wp ), parameter :: eps = epsilon ( 1.0_wp ) real ( wp ) norm , n1 , n2 , n3 , precon integer :: i w ( 1 ) = max ( abs ( a ( 1 , 1 )), abs ( a ( 1 , 2 ))) w ( 2 ) = max ( abs ( a ( 1 , 3 )), abs ( a ( 2 , 2 ))) w ( 3 ) = max ( abs ( a ( 2 , 3 )), abs ( a ( 3 , 3 ))) precon = max ( w ( 1 ), max ( w ( 2 ), w ( 3 ))) ! null matrix if ( precon < eps ) then w ( 1 ) = 0.0_wp w ( 2 ) = 0.0_wp w ( 3 ) = 0.0_wp q ( 1 , 1 ) = 1.0_wp q ( 2 , 2 ) = 1.0_wp q ( 3 , 3 ) = 1.0_wp q ( 1 , 2 ) = 0.0_wp q ( 1 , 3 ) = 0.0_wp q ( 2 , 3 ) = 0.0_wp q ( 2 , 1 ) = 0.0_wp q ( 3 , 1 ) = 0.0_wp q ( 3 , 2 ) = 0.0_wp return end if norm = 1.0_wp / precon a ( 1 , 1 ) = a ( 1 , 1 ) * norm a ( 1 , 2 ) = a ( 1 , 2 ) * norm a ( 2 , 2 ) = a ( 2 , 2 ) * norm a ( 1 , 3 ) = a ( 1 , 3 ) * norm a ( 2 , 3 ) = a ( 2 , 3 ) * norm a ( 3 , 3 ) = a ( 3 , 3 ) * norm ! Calculate eigenvalues call eigval_3x3 ( a , w ) ! Compute first eigenvector a ( 1 , 1 ) = a ( 1 , 1 ) - w ( 1 ) a ( 2 , 2 ) = a ( 2 , 2 ) - w ( 1 ) a ( 3 , 3 ) = a ( 3 , 3 ) - w ( 1 ) q ( 1 , 1 ) = a ( 1 , 2 ) * a ( 2 , 3 ) - a ( 1 , 3 ) * a ( 2 , 2 ) q ( 2 , 1 ) = a ( 1 , 3 ) * a ( 1 , 2 ) - a ( 1 , 1 ) * a ( 2 , 3 ) q ( 3 , 1 ) = a ( 1 , 1 ) * a ( 2 , 2 ) - a ( 1 , 2 ) * a ( 1 , 2 ) q ( 1 , 2 ) = a ( 1 , 2 ) * a ( 3 , 3 ) - a ( 1 , 3 ) * a ( 2 , 3 ) q ( 2 , 2 ) = a ( 1 , 3 ) * a ( 1 , 3 ) - a ( 1 , 1 ) * a ( 3 , 3 ) q ( 3 , 2 ) = a ( 1 , 1 ) * a ( 2 , 3 ) - a ( 1 , 2 ) * a ( 1 , 3 ) q ( 1 , 3 ) = a ( 2 , 2 ) * a ( 3 , 3 ) - a ( 2 , 3 ) * a ( 2 , 3 ) q ( 2 , 3 ) = a ( 2 , 3 ) * a ( 1 , 3 ) - a ( 1 , 2 ) * a ( 3 , 3 ) q ( 3 , 3 ) = a ( 1 , 2 ) * a ( 2 , 3 ) - a ( 2 , 2 ) * a ( 1 , 3 ) n1 = q ( 1 , 1 ) * q ( 1 , 1 ) + q ( 2 , 1 ) * q ( 2 , 1 ) + q ( 3 , 1 ) * q ( 3 , 1 ) n2 = q ( 1 , 2 ) * q ( 1 , 2 ) + q ( 2 , 2 ) * q ( 2 , 2 ) + q ( 3 , 2 ) * q ( 3 , 2 ) n3 = q ( 1 , 3 ) * q ( 1 , 3 ) + q ( 2 , 3 ) * q ( 2 , 3 ) + q ( 3 , 3 ) * q ( 3 , 3 ) norm = n1 i = 1 if ( n2 > norm ) then i = 2 norm = n1 end if if ( n3 > norm ) then i = 3 end if if ( i == 1 ) then norm = sqrt ( 1.0_wp / n1 ) q ( 1 , 1 ) = q ( 1 , 1 ) * norm q ( 2 , 1 ) = q ( 2 , 1 ) * norm q ( 3 , 1 ) = q ( 3 , 1 ) * norm else if ( i == 2 ) then norm = sqrt ( 1.0_wp / n2 ) q ( 1 , 1 ) = q ( 1 , 2 ) * norm q ( 2 , 1 ) = q ( 2 , 2 ) * norm q ( 3 , 1 ) = q ( 3 , 2 ) * norm else norm = sqrt ( 1.0_wp / n3 ) q ( 1 , 1 ) = q ( 1 , 3 ) * norm q ( 2 , 1 ) = q ( 2 , 3 ) * norm q ( 3 , 1 ) = q ( 3 , 3 ) * norm end if ! Robustly compute a right-hand orthonormal set (ev1, u, v) if ( abs ( q ( 1 , 1 )) > abs ( q ( 2 , 1 ))) then norm = sqrt ( 1.0_wp / ( q ( 1 , 1 ) * q ( 1 , 1 ) + q ( 3 , 1 ) * q ( 3 , 1 ))) q ( 1 , 2 ) = - q ( 3 , 1 ) * norm q ( 2 , 2 ) = 0.0_wp q ( 3 , 2 ) = + q ( 1 , 1 ) * norm else norm = sqrt ( 1.0_wp / ( q ( 2 , 1 ) * q ( 2 , 1 ) + q ( 3 , 1 ) * q ( 3 , 1 ))) q ( 1 , 2 ) = 0.0_wp q ( 2 , 2 ) = + q ( 3 , 1 ) * norm q ( 3 , 2 ) = - q ( 2 , 1 ) * norm end if q ( 1 , 3 ) = q ( 2 , 1 ) * q ( 3 , 2 ) - q ( 3 , 1 ) * q ( 2 , 2 ) q ( 2 , 3 ) = q ( 3 , 1 ) * q ( 1 , 2 ) - q ( 1 , 1 ) * q ( 3 , 2 ) q ( 3 , 3 ) = q ( 1 , 1 ) * q ( 2 , 2 ) - q ( 2 , 1 ) * q ( 1 , 2 ) ! Reset A a ( 1 , 1 ) = a ( 1 , 1 ) + w ( 1 ) a ( 2 , 2 ) = a ( 2 , 2 ) + w ( 1 ) a ( 3 , 3 ) = a ( 3 , 3 ) + w ( 1 ) ! A*U n1 = a ( 1 , 1 ) * q ( 1 , 2 ) + a ( 1 , 2 ) * q ( 2 , 2 ) + a ( 1 , 3 ) * q ( 3 , 2 ) n2 = a ( 1 , 2 ) * q ( 1 , 2 ) + a ( 2 , 2 ) * q ( 2 , 2 ) + a ( 2 , 3 ) * q ( 3 , 2 ) n3 = a ( 1 , 3 ) * q ( 1 , 2 ) + a ( 2 , 3 ) * q ( 2 , 2 ) + a ( 3 , 3 ) * q ( 3 , 2 ) ! A*V, note out of order computation a ( 3 , 3 ) = a ( 1 , 3 ) * q ( 1 , 3 ) + a ( 2 , 3 ) * q ( 2 , 3 ) + a ( 3 , 3 ) * q ( 3 , 3 ) a ( 1 , 3 ) = a ( 1 , 1 ) * q ( 1 , 3 ) + a ( 1 , 2 ) * q ( 2 , 3 ) + a ( 1 , 3 ) * q ( 3 , 3 ) a ( 2 , 3 ) = a ( 1 , 2 ) * q ( 1 , 3 ) + a ( 2 , 2 ) * q ( 2 , 3 ) + a ( 2 , 3 ) * q ( 3 , 3 ) ! UT*(A*U) - l2*E n1 = q ( 1 , 2 ) * n1 + q ( 2 , 2 ) * n2 + q ( 3 , 2 ) * n3 - w ( 2 ) ! UT*(A*V) n2 = q ( 1 , 2 ) * a ( 1 , 3 ) + q ( 2 , 2 ) * a ( 2 , 3 ) + q ( 3 , 2 ) * a ( 3 , 3 ) ! VT*(A*V) - l2*E n3 = q ( 1 , 3 ) * a ( 1 , 3 ) + q ( 2 , 3 ) * a ( 2 , 3 ) + q ( 3 , 3 ) * a ( 3 , 3 ) - w ( 2 ) if ( abs ( n1 ) >= abs ( n3 )) then norm = max ( abs ( n1 ), abs ( n2 )) if ( norm > eps ) then if ( abs ( n1 ) >= abs ( n2 )) then n2 = n2 / n1 n1 = sqrt ( 1.0_wp / ( 1.0_wp + n2 * n2 )) n2 = n2 * n1 else n1 = n1 / n2 n2 = sqrt ( 1.0_wp / ( 1.0_wp + n1 * n1 )) n1 = n1 * n2 end if q ( 1 , 2 ) = n2 * q ( 1 , 2 ) - n1 * q ( 1 , 3 ) q ( 2 , 2 ) = n2 * q ( 2 , 2 ) - n1 * q ( 2 , 3 ) q ( 3 , 2 ) = n2 * q ( 3 , 2 ) - n1 * q ( 3 , 3 ) end if else norm = max ( abs ( n3 ), abs ( n2 )) if ( norm > eps ) then if ( abs ( n3 ) >= abs ( n2 )) then n2 = n2 / n3 n3 = sqrt ( 1.0_wp / ( 1.0_wp + n2 * n2 )) n2 = n2 * n3 else n3 = n3 / n2 n2 = sqrt ( 1.0_wp / ( 1.0_wp + n3 * n3 )) n3 = n3 * n2 end if q ( 1 , 2 ) = n3 * q ( 1 , 2 ) - n2 * q ( 1 , 3 ) q ( 2 , 2 ) = n3 * q ( 2 , 2 ) - n2 * q ( 2 , 3 ) q ( 3 , 2 ) = n3 * q ( 3 , 2 ) - n2 * q ( 3 , 3 ) end if end if ! Calculate third eigenvector from cross product q ( 1 , 3 ) = q ( 2 , 1 ) * q ( 3 , 2 ) - q ( 3 , 1 ) * q ( 2 , 2 ) q ( 2 , 3 ) = q ( 3 , 1 ) * q ( 1 , 2 ) - q ( 1 , 1 ) * q ( 3 , 2 ) q ( 3 , 3 ) = q ( 1 , 1 ) * q ( 2 , 2 ) - q ( 2 , 1 ) * q ( 1 , 2 ) w ( 1 ) = w ( 1 ) * precon w ( 2 ) = w ( 2 ) * precon w ( 3 ) = w ( 3 ) * precon end subroutine eigvec_3x3","tags":"","loc":"proc/eigvec_3x3.html"},{"title":"resize – MCTC-library","text":"public interface resize Contents Module Procedures resize_pdb_data Module Procedures private subroutine resize_pdb_data(var, n) Arguments Type Intent Optional Attributes Name type( pdb_data ), intent(inout), allocatable :: var (:) integer, intent(in), optional :: n","tags":"","loc":"interface/resize~2.html"},{"title":"write_genformat – MCTC-library","text":"public subroutine write_genformat(mol, unit) Arguments Type Intent Optional Attributes Name class( structure_type ), intent(in) :: mol integer, intent(in) :: unit Contents Source Code write_genformat Source Code subroutine write_genformat ( mol , unit ) class ( structure_type ), intent ( in ) :: mol integer , intent ( in ) :: unit integer :: iat , izp real ( wp ), parameter :: zero3 ( 3 ) = 0.0_wp real ( wp ), allocatable :: inv_lat (:, :) real ( wp ), allocatable :: abc (:, :) write ( unit , '(i0, 1x)' , advance = 'no' ) mol % nat if (. not . any ( mol % periodic )) then write ( unit , '(\"C\")' ) ! cluster else if ( mol % info % cartesian ) then write ( unit , '(\"S\")' ) ! supercell else write ( unit , '(\"F\")' ) ! fractional endif endif do izp = 1 , mol % nid write ( unit , '(1x, a)' , advance = 'no' ) trim ( mol % sym ( izp )) enddo write ( unit , '(a)' ) if (. not . any ( mol % periodic ) . or . mol % info % cartesian ) then ! now write the cartesian coordinates do iat = 1 , mol % nat write ( unit , '(2i5, 3es24.14)' ) iat , mol % id ( iat ), mol % xyz (:, iat ) * autoaa enddo else inv_lat = matinv_3x3 ( mol % lattice ) abc = matmul ( inv_lat , mol % xyz ) ! now write the fractional coordinates do iat = 1 , mol % nat write ( unit , '(2i5, 3es24.15)' ) iat , mol % id ( iat ), abc (:, iat ) enddo endif if ( any ( mol % periodic )) then ! scaling factor for lattice parameters is always one write ( unit , '(3f20.14)' ) zero3 ! write the lattice parameters write ( unit , '(3f20.14)' ) mol % lattice (:, :) * autoaa endif end subroutine write_genformat","tags":"","loc":"proc/write_genformat.html"},{"title":"write_pdb – MCTC-library","text":"public subroutine write_pdb(mol, unit, number) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(in) :: mol integer, intent(in) :: unit integer, intent(in), optional :: number Contents Source Code write_pdb Source Code subroutine write_pdb ( mol , unit , number ) type ( structure_type ), intent ( in ) :: mol integer , intent ( in ) :: unit integer , intent ( in ), optional :: number character ( len = 6 ) :: w1 character ( len = 4 ) :: sym character ( len = 2 ) :: a_charge character ( len = 1 ) :: last_chain logical :: last_het integer :: offset , iat , jat real ( wp ) :: xyz ( 3 ) character ( len =* ), parameter :: pdb_format = & & '(a6,i5,1x,a4,a1,a3,1x,a1,i4,a1,3x,3f8.3,2f6.2,6x,a4,a2,a2)' if ( present ( number )) write ( unit , '(\"MODEL \",4x,i4)' ) number if ( allocated ( mol % pdb )) then offset = 0 last_chain = mol % pdb ( 1 )% chains last_het = mol % pdb ( 1 )% het do iat = 1 , mol % nat ! handle the terminator if ( mol % pdb ( iat )% het . neqv . last_het ) then write ( unit , '(\"TER   \",i5,6x,a3,1x,a1,i4)' ) iat + offset , & & mol % pdb ( iat - 1 )% residue , last_chain , mol % pdb ( iat )% residue_number last_het = . not . last_het offset = offset + 1 else if ( mol % pdb ( iat )% chains /= last_chain ) then write ( unit , '(\"TER   \",i5,6x,a3,1x,a1,i4)' ) iat + offset , & & mol % pdb ( iat - 1 )% residue , last_chain , mol % pdb ( iat )% residue_number offset = offset + 1 endif jat = iat + offset if ( mol % pdb ( iat )% het ) then w1 = \"HETATM\" else w1 = \"ATOM  \" endif sym = adjustr ( mol % sym ( mol % id ( iat ))( 1 : 2 )) xyz = mol % xyz (:, iat ) * autoaa if ( mol % pdb ( iat )% charge < 0 ) then write ( a_charge , '(i1,\"-\")' ) abs ( mol % pdb ( iat )% charge ) else if ( mol % pdb ( iat )% charge > 0 ) then write ( a_charge , '(i1,\"+\")' ) abs ( mol % pdb ( iat )% charge ) else a_charge = '  ' endif write ( unit , pdb_format ) & & w1 , jat , mol % pdb ( iat )% name , mol % pdb ( iat )% loc , & & mol % pdb ( iat )% residue , mol % pdb ( iat )% chains , mol % pdb ( iat )% residue_number , & & mol % pdb ( iat )% code , xyz , 1.0_wp , 0.0_wp , mol % pdb ( iat )% segid , & & sym , a_charge enddo else do iat = 1 , mol % nat w1 = \"HETATM\" sym = adjustr ( mol % sym ( mol % id ( iat ))( 1 : 2 )) xyz = mol % xyz (:, iat ) * autoaa a_charge = '  ' write ( unit , pdb_format ) & & w1 , iat , sym , \" \" , & & \"UNK\" , \"A\" , 1 , \" \" , xyz , 1.0_wp , 0.0_wp , \"    \" , & & sym , \"  \" enddo end if if ( present ( number )) then write ( unit , '(\"ENDMDL\")' ) else write ( unit , '(\"END\")' ) endif end subroutine write_pdb","tags":"","loc":"proc/write_pdb.html"},{"title":"write_molfile – MCTC-library","text":"public subroutine write_molfile(self, unit, comment_line) Arguments Type Intent Optional Attributes Name class( structure_type ), intent(in) :: self integer, intent(in) :: unit character(len=*), intent(in), optional :: comment_line Contents Source Code write_molfile Source Code subroutine write_molfile ( self , unit , comment_line ) class ( structure_type ), intent ( in ) :: self integer , intent ( in ) :: unit character ( len =* ), intent ( in ), optional :: comment_line integer , parameter :: list4 ( 4 ) = 0 integer :: iatom , ibond , iatoms ( 3 ), list12 ( 12 ) logical :: has_sdf_data integer , parameter :: charge_to_ccc ( - 3 : 3 ) = [ 7 , 6 , 5 , 0 , 3 , 2 , 1 ] character ( len = 8 ) :: date character ( len = 10 ) :: time call date_and_time ( date , time ) if ( present ( comment_line )) then write ( unit , '(a)' ) comment_line else if ( allocated ( self % comment )) then write ( unit , '(a)' ) self % comment else write ( unit , '(a)' ) end if end if write ( unit , '(2x, 3x, 5x, 3a2, a4, \"3D\")' ) & & date ( 5 : 6 ), date ( 7 : 8 ), date ( 3 : 4 ), time (: 4 ) write ( unit , '(a)' ) write ( unit , '(3i3, 3x, 2i3, 12x, i3, 1x, a5)' ) & & self % nat , self % nbd , 0 , 0 , 0 , 999 , 'V2000' has_sdf_data = allocated ( self % sdf ) do iatom = 1 , self % nat if ( has_sdf_data ) then list12 = [ self % sdf ( iatom )% isotope , 0 , 0 , 0 , 0 , self % sdf ( iatom )% valence , & & 0 , 0 , 0 , 0 , 0 , 0 ] else list12 = 0 endif write ( unit , '(3f10.4, 1x, a3, i2, 11i3)' ) & & self % xyz (:, iatom ) * autoaa , self % sym ( self % id ( iatom )), list12 enddo if ( self % nbd > 0 ) then if ( size ( self % bond , 1 ) > 2 ) then do ibond = 1 , self % nbd write ( unit , '(7i3)' ) self % bond (: 3 , ibond ), list4 end do else do ibond = 1 , self % nbd write ( unit , '(7i3)' ) self % bond (: 2 , ibond ), 1 , list4 end do end if end if if ( has_sdf_data ) then if ( sum ( self % sdf % charge ) /= nint ( self % charge )) then write ( unit , '(a, *(i3, 1x, i3, 1x, i3))' ) \"M  CHG\" , 1 , 1 , nint ( self % charge ) else do iatom = 1 , self % nat if ( self % sdf ( iatom )% charge /= 0 ) then write ( unit , '(a, *(i3, 1x, i3, 1x, i3))' ) & & \"M  CHG\" , 1 , iatom , self % sdf ( iatom )% charge end if end do end if else if ( nint ( self % charge ) /= 0 ) then write ( unit , '(a, *(i3, 1x, i3, 1x, i3))' ) \"M  CHG\" , 1 , 1 , nint ( self % charge ) end if end if write ( unit , '(a)' ) \"M  END\" end subroutine write_molfile","tags":"","loc":"proc/write_molfile.html"},{"title":"write_sdf – MCTC-library","text":"public subroutine write_sdf(self, unit, energy, gnorm) Arguments Type Intent Optional Attributes Name class( structure_type ), intent(in) :: self integer, intent(in) :: unit real(kind=wp), intent(in), optional :: energy real(kind=wp), intent(in), optional :: gnorm Contents Source Code write_sdf Source Code subroutine write_sdf ( self , unit , energy , gnorm ) class ( structure_type ), intent ( in ) :: self integer , intent ( in ) :: unit real ( wp ), intent ( in ), optional :: energy real ( wp ), intent ( in ), optional :: gnorm !type(tb_buffer) :: sd_values character ( len = :), allocatable :: line character ( len =* ), parameter :: sd_format = & & '(\"> <\", a, \">\", /, f20.12, /)' call write_molfile ( self , unit ) !   sd_values = self%info !   call sd_values%reset !   do while(sd_values%next()) !      call sd_values%getline(line) !      write(unit, '(a)') line !   enddo if ( present ( energy )) then write ( unit , sd_format ) \"total energy / Eh\" , energy endif if ( present ( gnorm )) then write ( unit , sd_format ) \"gradient norm / Eh/a0\" , gnorm endif write ( unit , '(\"\")' ) end subroutine write_sdf","tags":"","loc":"proc/write_sdf.html"},{"title":"write_coord – MCTC-library","text":"public subroutine write_coord(mol, unit) Arguments Type Intent Optional Attributes Name class( structure_type ), intent(in) :: mol integer, intent(in) :: unit Contents Source Code write_coord Source Code subroutine write_coord ( mol , unit ) class ( structure_type ), intent ( in ) :: mol integer , intent ( in ) :: unit integer :: iat write ( unit , '(a)' ) \"$coord\" do iat = 1 , mol % nat write ( unit , '(3es24.14, 6x, a)' ) mol % xyz (:, iat ), trim ( mol % sym ( mol % id ( iat ))) enddo write ( unit , '(a, 1x, i0)' ) \"$periodic\" , count ( mol % periodic ) if ( any ( mol % periodic )) then write ( unit , '(a)' ) \"$lattice bohr\" write ( unit , '(3f20.14)' ) mol % lattice endif write ( unit , '(a)' ) \"$end\" end subroutine write_coord","tags":"","loc":"proc/write_coord.html"},{"title":"write_gaussian_external – MCTC-library","text":"public subroutine write_gaussian_external(mol, unit) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(in) :: mol integer, intent(in) :: unit Contents Source Code write_gaussian_external Source Code subroutine write_gaussian_external ( mol , unit ) type ( structure_type ), intent ( in ) :: mol integer , intent ( in ) :: unit integer :: iat write ( unit , '(4i10)' ) mol % nat , 1 , nint ( mol % charge ), mol % uhf do iat = 1 , mol % nat write ( unit , '(i10,4f20.12)' ) mol % num ( mol % id ( iat )), mol % xyz (:, iat ), 0.0_wp end do end subroutine write_gaussian_external","tags":"","loc":"proc/write_gaussian_external.html"},{"title":"write_vasp – MCTC-library","text":"public subroutine write_vasp(self, unit, comment_line) Arguments Type Intent Optional Attributes Name class( structure_type ), intent(in) :: self integer, intent(in) :: unit character(len=*), intent(in), optional :: comment_line Contents Source Code write_vasp Source Code subroutine write_vasp ( self , unit , comment_line ) class ( structure_type ), intent ( in ) :: self integer , intent ( in ) :: unit character ( len =* ), intent ( in ), optional :: comment_line integer :: i , j , izp integer , allocatable :: kinds (:), species (:) real ( wp ), allocatable :: inv_lat (:, :) real ( wp ), allocatable :: abc (:, :) allocate ( species ( self % nat )) allocate ( kinds ( self % nat ), source = 1 ) j = 0 izp = 0 do i = 1 , self % nat if ( izp . eq . self % id ( i )) then kinds ( j ) = kinds ( j ) + 1 else j = j + 1 izp = self % id ( i ) species ( j ) = self % id ( i ) endif enddo ! use vasp 5.x format if ( present ( comment_line )) then write ( unit , '(a)' ) comment_line else if ( allocated ( self % comment )) then write ( unit , '(a)' ) self % comment else write ( unit , '(a)' ) end if end if ! scaling factor for lattice parameters is always one write ( unit , '(f20.14)' ) self % info % scale ! write the lattice parameters if ( allocated ( self % lattice )) then do i = 1 , 3 write ( unit , '(3f20.14)' ) self % lattice (:, i ) * autoaa / self % info % scale enddo else write ( unit , '(3f20.14)' ) spread ( 0.0_wp , 1 , 9 ) end if do i = 1 , j write ( unit , '(1x, a)' , advance = 'no' ) self % sym ( species ( i )) enddo write ( unit , '(a)' ) ! write the count of the consequtive atom types do i = 1 , j write ( unit , '(1x, i0)' , advance = 'no' ) kinds ( i ) enddo write ( unit , '(a)' ) deallocate ( kinds , species ) if ( self % info % selective ) write ( unit , '(\"Selective\")' ) ! we write cartesian coordinates if (. not . allocated ( self % lattice ) . or . self % info % cartesian ) then write ( unit , '(\"Cartesian\")' ) ! now write the cartesian coordinates do i = 1 , self % nat write ( unit , '(3f20.14)' ) self % xyz (:, i ) * autoaa / self % info % scale enddo else write ( unit , '(\"Direct\")' ) inv_lat = matinv_3x3 ( self % lattice ) abc = matmul ( inv_lat , self % xyz ) ! now write the fractional coordinates do i = 1 , self % nat write ( unit , '(3f20.14)' ) abc (:, i ) enddo endif end subroutine write_vasp","tags":"","loc":"proc/write_vasp.html"},{"title":"write_xyz – MCTC-library","text":"public subroutine write_xyz(self, unit, comment_line) Arguments Type Intent Optional Attributes Name class( structure_type ), intent(in) :: self integer, intent(in) :: unit character(len=*), intent(in), optional :: comment_line Contents Source Code write_xyz Source Code subroutine write_xyz ( self , unit , comment_line ) class ( structure_type ), intent ( in ) :: self integer , intent ( in ) :: unit character ( len =* ), intent ( in ), optional :: comment_line integer :: iat logical :: expo write ( unit , '(i0)' ) self % nat if ( present ( comment_line )) then write ( unit , '(a)' ) comment_line else if ( allocated ( self % comment )) then write ( unit , '(a)' ) self % comment else write ( unit , '(a)' ) end if end if expo = maxval ( self % xyz ) > 1.0e+5 . or . minval ( self % xyz ) < - 1.0e+5 if ( expo ) then do iat = 1 , self % nat write ( unit , '(a4, 1x, 3es24.14)' ) & & self % sym ( self % id ( iat )), self % xyz (:, iat ) * autoaa enddo else do iat = 1 , self % nat write ( unit , '(a4, 1x, 3f24.14)' ) & & self % sym ( self % id ( iat )), self % xyz (:, iat ) * autoaa enddo end if end subroutine write_xyz","tags":"","loc":"proc/write_xyz.html"},{"title":"read_genformat – MCTC-library","text":"public subroutine read_genformat(mol, unit, error) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: mol Instance of the molecular structure data integer, intent(in) :: unit File handle type( error_type ), intent(out), allocatable :: error Error handling Contents Source Code read_genformat Source Code subroutine read_genformat ( mol , unit , error ) !> Instance of the molecular structure data type ( structure_type ), intent ( out ) :: mol !> File handle integer , intent ( in ) :: unit !> Error handling type ( error_type ), allocatable , intent ( out ) :: error character ( len = :), allocatable :: line integer :: natoms , nspecies , iatom , dummy , isp , ilat , stat , istart , iend logical :: cartesian , periodic real ( wp ) :: coord ( 3 ), lattice ( 3 , 3 ) character ( len = 1 ) :: variant character ( len = symbol_length ), allocatable :: species (:), sym (:) real ( wp ), allocatable :: xyz (:, :), abc (:, :) type ( structure_info ) :: info call next_line ( unit , line , stat ) read ( line , * , iostat = stat ) natoms , variant if ( stat /= 0 . or . natoms < 1 ) then call fatal_error ( error , 'could not read number of atoms' ) return end if allocate ( species ( natoms )) allocate ( sym ( natoms )) allocate ( xyz ( 3 , natoms )) allocate ( abc ( 3 , natoms )) select case ( variant ) case ( 'c' , 'C' ) cartesian = . true . periodic = . false . case ( 's' , 'S' ) cartesian = . true . periodic = . true . case ( 'f' , 'F' ) cartesian = . false . periodic = . true . case default call fatal_error ( error , 'invalid input version' ) return endselect call next_line ( unit , line , stat ) istart = 1 iend = 1 isp = 0 do while ( iend < len_trim ( line )) istart = verify ( line ( iend :), ' ' ) - 1 + iend iend = scan ( line ( istart :), ' ' ) - 1 + istart if ( iend < istart ) iend = len_trim ( line ) isp = isp + 1 species ( isp ) = trim ( line ( istart : iend )) end do nspecies = isp if ( any ( to_number ( species (: nspecies )) == 0 )) then call fatal_error ( error , 'unknown atom type present' ) return end if do iatom = 1 , natoms call next_line ( unit , line , stat ) read ( line , * , iostat = stat ) dummy , isp , coord if ( stat /= 0 ) then call fatal_error ( error , 'could not read coordinates from file' ) return end if sym ( iatom ) = species ( isp ) if ( cartesian ) then xyz (:, iatom ) = coord * aatoau else abc (:, iatom ) = coord end if end do if ( periodic ) then call next_line ( unit , line , stat ) if ( stat /= 0 ) then call fatal_error ( error , 'missing lattice information' ) return end if do ilat = 1 , 3 call next_line ( unit , line , stat ) read ( line , * , iostat = stat ) coord if ( stat /= 0 ) then call fatal_error ( error , 'could not read lattice from file' ) return end if lattice (:, ilat ) = coord * aatoau end do if (. not . cartesian ) then xyz = matmul ( lattice , abc ) end if info = structure_info ( cartesian = cartesian ) call new ( mol , sym , xyz , lattice = lattice , info = info ) else call new ( mol , sym , xyz ) end if contains subroutine next_line ( unit , line , stat ) integer , intent ( in ) :: unit character ( len = :), allocatable , intent ( out ) :: line integer , intent ( out ) :: stat integer :: ihash stat = 0 do while ( stat == 0 ) call getline ( unit , line , stat ) ihash = index ( line , '#' ) if ( ihash > 0 ) line = line (: ihash - 1 ) if ( len_trim ( line ) > 0 ) exit end do line = trim ( adjustl ( line )) end subroutine next_line end subroutine read_genformat","tags":"","loc":"proc/read_genformat.html"},{"title":"read_pdb – MCTC-library","text":"public subroutine read_pdb(self, unit, error) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: self Instance of the molecular structure data integer, intent(in) :: unit File handle type( error_type ), intent(out), allocatable :: error Error handling Contents Source Code read_pdb Source Code subroutine read_pdb ( self , unit , error ) !> Instance of the molecular structure data type ( structure_type ), intent ( out ) :: self !> File handle integer , intent ( in ) :: unit !> Error handling type ( error_type ), allocatable , intent ( out ) :: error character ( len =* ), parameter :: pdb_format = & & '(6x,i5,1x,a4,a1,a3,1x,a1,i4,a1,3x,3f8.3,2f6.2,6x,a4,a2,a2)' integer , parameter :: p_initial_size = 1000 ! this is going to be a proteine integer :: iatom , jatom , iresidue , try , stat , atom_type real ( wp ) :: occ , temp , coords ( 3 ) real ( wp ), allocatable :: xyz (:,:) character ( len = 4 ) :: a_charge character ( len = :), allocatable :: line character ( len = symbol_length ), allocatable :: sym (:) type ( pdb_data ), allocatable :: pdb (:) allocate ( sym ( p_initial_size ), source = repeat ( ' ' , symbol_length )) allocate ( xyz ( 3 , p_initial_size ), source = 0.0_wp ) allocate ( pdb ( p_initial_size ), source = pdb_data ()) iatom = 0 iresidue = 0 stat = 0 do while ( stat == 0 ) call getline ( unit , line , stat ) if ( index ( line , 'END' ) == 1 ) exit if ( index ( line , 'ATOM' ) == 1 . or . index ( line , 'HETATM' ) == 1 ) then if ( iatom >= size ( xyz , 2 )) call resize ( xyz ) if ( iatom >= size ( sym )) call resize ( sym ) if ( iatom >= size ( pdb )) call resize ( pdb ) iatom = iatom + 1 pdb ( iatom )% het = index ( line , 'HETATM' ) == 1 read ( line , pdb_format ) & & jatom , pdb ( iatom )% name , pdb ( iatom )% loc , pdb ( iatom )% residue , & & pdb ( iatom )% chains , pdb ( iatom )% residue_number , pdb ( iatom )% code , & & coords , occ , temp , pdb ( iatom )% segid , sym ( iatom ), a_charge xyz (:, iatom ) = coords * aatoau atom_type = to_number ( sym ( iatom )) if ( atom_type == 0 ) then try = scan ( pdb ( iatom )% name , 'HCNOSPF' ) if ( try > 0 ) sym ( iatom ) = pdb ( iatom )% name ( try : try ) // ' ' pdb ( iatom )% charge = 0 else read ( a_charge ( 1 : 1 ), * , iostat = stat ) pdb ( iatom )% charge if ( stat /= 0 ) then stat = 0 pdb ( iatom )% charge = 0 else if ( a_charge ( 2 : 2 ) == '-' ) pdb ( iatom )% charge = - pdb ( iatom )% charge end if end if end if end do if ( stat /= 0 ) then call fatal_error ( error , \"could not read in coordinates, last line was: '\" // line // \"'\" ) return end if call new ( self , sym (: iatom ), xyz (:, : iatom )) self % pdb = pdb (: iatom ) self % charge = sum ( pdb (: iatom )% charge ) if (. not . all ( self % num > 0 )) then call fatal_error ( error , \"invalid atom type found\" ) return end if ! since PDB is used for biomolecules, this is a sensible check (prevents GIGO) if (. not . any ( self % num == 1 )) then call fatal_error ( error , \"You get no calculation today, please add hydrogen atoms first\" ) return end if end subroutine read_pdb","tags":"","loc":"proc/read_pdb.html"},{"title":"read_molfile – MCTC-library","text":"public subroutine read_molfile(self, unit, error) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: self Instance of the molecular structure data integer, intent(in) :: unit File handle type( error_type ), intent(out), allocatable :: error Error handling Contents Source Code read_molfile Source Code subroutine read_molfile ( self , unit , error ) !> Instance of the molecular structure data type ( structure_type ), intent ( out ) :: self !> File handle integer , intent ( in ) :: unit !> Error handling type ( error_type ), allocatable , intent ( out ) :: error character ( len = :), allocatable :: line character ( len = :), allocatable :: comment integer :: i , iatom , jatom , ibond , btype , atomtype integer :: stat , length , charge ( 2 , 15 ) integer :: number_of_atoms , number_of_bonds , number_of_atom_lists , & & chiral_flag , number_of_stext_entries , i999 integer :: list4 ( 4 ), list12 ( 12 ) real ( wp ) :: x , y , z character ( len = 2 ) :: sdf_dim character ( len = 3 ) :: symbol character ( len = 5 ) :: v2000 integer , parameter :: ccc_to_charge ( 0 : 7 ) = [ 0 , + 3 , + 2 , + 1 , 0 , - 1 , - 2 , - 3 ] logical :: two_dim character ( len = symbol_length ), allocatable :: sym (:) type ( sdf_data ), allocatable :: sdf (:) type ( structure_info ) :: info real ( wp ), allocatable :: xyz (:, :) integer , allocatable :: bond (:, :) two_dim = . false . call getline ( unit , comment , stat ) call getline ( unit , line , stat ) read ( line , '(20x, a2)' , iostat = stat ) sdf_dim if ( stat == 0 ) then two_dim = sdf_dim == '2D' . or . sdf_dim == '2d' end if call getline ( unit , line , stat ) call getline ( unit , line , stat ) read ( line , '(3i3, 3x, 2i3, 12x, i3, 1x, a5)' , iostat = stat ) & & number_of_atoms , number_of_bonds , number_of_atom_lists , & & chiral_flag , number_of_stext_entries , i999 , v2000 if ( stat /= 0 ) then call fatal_error ( error , \"Cannot read header of molfile\" ) return end if allocate ( sdf ( number_of_atoms )) allocate ( xyz ( 3 , number_of_atoms )) allocate ( sym ( number_of_atoms )) do iatom = 1 , number_of_atoms call getline ( unit , line , stat ) read ( line , '(3f10.4, 1x, a3, i2, 11i3)' , iostat = stat ) & & x , y , z , symbol , list12 if ( stat /= 0 ) then call fatal_error ( error , \"Cannot read coordinates from connection table\" ) return end if atomtype = to_number ( symbol ) if ( atomtype == 0 ) then call fatal_error ( error , \"Unknown atom type '\" // trim ( symbol ) // \"' in connection table\" ) return end if xyz (:, iatom ) = [ x , y , z ] * aatoau sym ( iatom ) = trim ( symbol ) sdf ( iatom )% isotope = list12 ( 1 ) sdf ( iatom )% charge = ccc_to_charge ( list12 ( 2 )) ! drop doublet radical sdf ( iatom )% hydrogens = list12 ( 4 ) sdf ( iatom )% valence = list12 ( 6 ) end do allocate ( bond ( 3 , number_of_bonds )) do ibond = 1 , number_of_bonds call getline ( unit , line , stat ) read ( line , '(7i3)' , iostat = stat ) & & iatom , jatom , btype , list4 if ( stat /= 0 ) then call fatal_error ( error , \"Cannot read topology from connection table\" ) return end if bond (:, ibond ) = [ ibond , jatom , btype ] end do do while ( stat == 0 ) call getline ( unit , line , stat ) if ( index ( line , 'M  END' ) == 1 ) exit if ( index ( line , 'M  CHG' ) == 1 ) then read ( line ( 7 : 9 ), * ) length read ( line ( 10 :), '(*(1x, i3, 1x, i3))' ) ( charge (:, i ), i = 1 , length ) do i = 1 , length sdf ( charge ( 1 , i ))% charge = charge ( 2 , i ) end do end if end do if ( stat /= 0 ) then call fatal_error ( error , \"Cannot read connection table\" ) return end if info = structure_info ( two_dimensional = two_dim , & & missing_hydrogen = any ( sdf % hydrogens > 1 )) call new ( self , sym , xyz , charge = real ( sum ( sdf % charge ), wp ), info = info , bond = bond ) call move_alloc ( sdf , self % sdf ) if ( len ( comment ) > 0 ) self % comment = comment end subroutine read_molfile","tags":"","loc":"proc/read_molfile.html"},{"title":"read_sdf – MCTC-library","text":"public subroutine read_sdf(self, unit, error) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: self Instance of the molecular structure data integer, intent(in) :: unit File handle type( error_type ), intent(out), allocatable :: error Error handling Contents Source Code read_sdf Source Code subroutine read_sdf ( self , unit , error ) !> Instance of the molecular structure data type ( structure_type ), intent ( out ) :: self !> File handle integer , intent ( in ) :: unit !> Error handling type ( error_type ), allocatable , intent ( out ) :: error character ( len = :), allocatable :: line integer :: stat call read_molfile ( self , unit , error ) if ( allocated ( error )) return stat = 0 do while ( stat == 0 ) call getline ( unit , line , stat ) if ( index ( line , '' ) == 1 ) exit end do if ( stat /= 0 ) then call fatal_error ( error , \"Failed while reading SDF key-value pairs\" ) return end if end subroutine read_sdf","tags":"","loc":"proc/read_sdf.html"},{"title":"read_coord – MCTC-library","text":"public subroutine read_coord(mol, unit, error) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: mol Instance of the molecular structure data integer, intent(in) :: unit File handle type( error_type ), intent(out), allocatable :: error Error handling Contents Source Code read_coord Source Code subroutine read_coord ( mol , unit , error ) !> Instance of the molecular structure data type ( structure_type ), intent ( out ) :: mol !> File handle integer , intent ( in ) :: unit !> Error handling type ( error_type ), allocatable , intent ( out ) :: error character , parameter :: flag = '$' integer , parameter :: p_initial_size = 100 integer , parameter :: p_nlv ( 3 ) = [ 1 , 4 , 9 ], p_ncp ( 3 ) = [ 1 , 3 , 6 ] logical :: has_coord , has_periodic , has_lattice , has_cell logical :: cartesian , coord_in_bohr , lattice_in_bohr , pbc ( 3 ) integer :: stat , iatom , i , j , natoms , periodic , cell_vectors real ( wp ) :: latvec ( 9 ), conv , cellpar ( 6 ), lattice ( 3 , 3 ) real ( wp ), allocatable :: coord (:, :), xyz (:, :) character ( len = :), allocatable :: line , cell_string , lattice_string character ( len = symbol_length ), allocatable :: sym (:) type ( structure_info ) :: info allocate ( sym ( p_initial_size ), source = repeat ( ' ' , symbol_length )) allocate ( coord ( 3 , p_initial_size ), source = 0.0_wp ) iatom = 0 periodic = 0 cell_vectors = 0 has_coord = . false . has_periodic = . false . has_lattice = . false . has_cell = . false . cartesian = . true . coord_in_bohr = . true . lattice_in_bohr = . true . lattice = 0.0_wp pbc = . false . stat = 0 do while ( stat == 0 ) call getline ( unit , line , stat ) if ( index ( line , flag ) == 1 ) then if ( index ( line , 'end' ) == 2 ) then exit else if (. not . has_coord . and . index ( line , 'coord' ) == 2 ) then has_coord = . true . ! $coord angs / $coord bohr / $coord frac call select_unit ( line , coord_in_bohr , cartesian ) coord_group : do while ( stat == 0 ) call getline ( unit , line , stat ) if ( index ( line , flag ) == 1 ) then backspace ( unit ) exit coord_group end if if ( iatom >= size ( coord , 2 )) call resize ( coord ) if ( iatom >= size ( sym )) call resize ( sym ) iatom = iatom + 1 read ( line , * , iostat = stat ) coord (:, iatom ), sym ( iatom ) end do coord_group else if (. not . has_periodic . and . index ( line , 'periodic' ) == 2 ) then has_periodic = . true . ! $periodic 0/1/2/3 read ( line ( 10 :), * , iostat = stat ) periodic else if (. not . has_lattice . and . index ( line , 'lattice' ) == 2 ) then has_lattice = . true . ! $lattice bohr / $lattice angs call select_unit ( line , lattice_in_bohr ) cell_vectors = 0 lattice_string = '' lattice_group : do while ( stat == 0 ) call getline ( unit , line , stat ) if ( index ( line , flag ) == 1 ) then backspace ( unit ) exit lattice_group end if cell_vectors = cell_vectors + 1 lattice_string = lattice_string // ' ' // line end do lattice_group else if (. not . has_cell . and . index ( line , 'cell' ) == 2 ) then has_cell = . true . ! $cell bohr / $cell angs call select_unit ( line , lattice_in_bohr ) call getline ( unit , cell_string , stat ) if ( debug ) print * , cell_string end if end if end do if (. not . has_coord . or . iatom == 0 ) then call fatal_error ( error , \"coordinates not present, cannot work without coordinates\" ) return end if if ( has_cell . and . has_lattice ) then call fatal_error ( error , \"both lattice and cell group are present\" ) return end if if (. not . has_periodic . and . ( has_cell . or . has_lattice )) then call fatal_error ( error , \"cell and lattice definition is present, but periodicity is not given\" ) return end if if ( periodic > 0 . and . . not .( has_cell . or . has_lattice )) then call fatal_error ( error , \"system is periodic but definition of lattice/cell is missing\" ) return end if if (. not . cartesian . and . periodic == 0 ) then call fatal_error ( error , \"fractional coordinates do not work for molecular systems\" ) return end if natoms = iatom allocate ( xyz ( 3 , natoms )) if ( any ( to_number ( sym (: natoms )) == 0 )) then call fatal_error ( error , \"unknown element present\" ) return end if if ( periodic > 0 ) pbc (: periodic ) = . true . if ( has_cell ) then read ( cell_string , * , iostat = stat ) latvec (: p_ncp ( periodic )) if ( debug ) print * , latvec (: p_ncp ( periodic )) if ( lattice_in_bohr ) then conv = 1.0_wp else conv = aatoau end if select case ( periodic ) case ( 1 ) cellpar = [ latvec ( 1 ) * conv , 1.0_wp , 1.0_wp , & & pi / 2 , pi / 2 , pi / 2 ] case ( 2 ) cellpar = [ latvec ( 1 ) * conv , latvec ( 2 ) * conv , 1.0_wp , & & pi / 2 , pi / 2 , latvec ( 3 ) * pi / 18 0.0_wp ] case ( 3 ) cellpar = [ latvec ( 1 : 3 ) * conv , latvec ( 4 : 6 ) * pi / 18 0.0_wp ] end select call cell_to_dlat ( cellpar , lattice ) end if if ( has_lattice ) then if ( cell_vectors /= periodic ) then call fatal_error ( error , \"number of cell vectors does not match periodicity\" ) return end if read ( lattice_string , * , iostat = stat ) latvec (: p_nlv ( periodic )) if ( lattice_in_bohr ) then conv = 1.0_wp else conv = aatoau end if j = 0 do i = 1 , periodic lattice (: periodic , i ) = latvec ( j + 1 : j + periodic ) * conv j = j + periodic end do end if if ( cartesian ) then if ( coord_in_bohr ) then conv = 1.0_wp else conv = aatoau end if xyz (:, :) = coord (:, : natoms ) * conv else xyz = matmul ( lattice , coord ) end if ! save data on input format info = structure_info ( cartesian = cartesian , lattice = has_lattice , & & angs_lattice = . not . lattice_in_bohr , angs_coord = . not . coord_in_bohr ) call new ( mol , sym (: natoms ), xyz , lattice = lattice , periodic = pbc , info = info ) contains subroutine select_unit ( line , in_bohr , cartesian ) character ( len =* ), intent ( in ) :: line logical , intent ( out ) :: in_bohr logical , intent ( out ), optional :: cartesian in_bohr = index ( line , ' angs' ) == 0 if ( present ( cartesian )) cartesian = index ( line , ' frac' ) == 0 end subroutine select_unit end subroutine read_coord","tags":"","loc":"proc/read_coord.html"},{"title":"read_gaussian_external – MCTC-library","text":"public subroutine read_gaussian_external(self, unit, error) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: self Instance of the molecular structure data integer, intent(in) :: unit File handle type( error_type ), intent(out), allocatable :: error Error handling Contents Source Code read_gaussian_external Source Code subroutine read_gaussian_external ( self , unit , error ) !> Instance of the molecular structure data type ( structure_type ), intent ( out ) :: self !> File handle integer , intent ( in ) :: unit !> Error handling type ( error_type ), allocatable , intent ( out ) :: error integer :: stat , n , mode , chrg , spin , iat , ii integer , allocatable :: at (:) real ( wp ), allocatable :: xyz (:,:) real ( wp ) :: coord ( 3 ), q read ( unit , '(4i10)' , iostat = stat ) n , mode , chrg , spin if ( stat . ne . 0 ) then call fatal_error ( error , \"Could not read number of atoms, check format!\" ) return end if if ( n <= 0 ) then call fatal_error ( error , \"Found no atoms, cannot work without atoms!\" ) return end if allocate ( xyz ( 3 , n )) allocate ( at ( n )) ii = 0 do while ( ii < n ) read ( unit , '(i10, 4f20.12)' , iostat = stat ) iat , coord , q if ( is_iostat_end ( stat )) exit if ( stat . ne . 0 ) then call fatal_error ( error , \"Could not read geometry from Gaussian file\" ) return end if if ( iat > 0 ) then ii = ii + 1 at ( ii ) = iat xyz (:, ii ) = coord else call fatal_error ( error , \"Invalid atomic number\" ) return end if end do call new ( self , at , xyz , charge = real ( chrg , wp ), uhf = spin ) if ( ii /= n ) then call fatal_error ( error , \"Atom number missmatch in Gaussian file\" ) return end if end subroutine read_gaussian_external","tags":"","loc":"proc/read_gaussian_external.html"},{"title":"read_vasp – MCTC-library","text":"public subroutine read_vasp(self, unit, error) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: self Instance of the molecular structure data integer, intent(in) :: unit File handle type( error_type ), intent(out), allocatable :: error Error handling Contents Source Code read_vasp Source Code subroutine read_vasp ( self , unit , error ) !> Instance of the molecular structure data type ( structure_type ), intent ( out ) :: self !> File handle integer , intent ( in ) :: unit !> Error handling type ( error_type ), allocatable , intent ( out ) :: error logical :: selective , cartesian integer :: i , j , k , nn , ntype , natoms , izp , stat integer , allocatable :: ncount (:) real ( wp ) :: ddum , latvec ( 3 ), scalar , coord ( 3 ), lattice ( 3 , 3 ) real ( wp ), allocatable :: xyz (:, :) character ( len = :), allocatable :: line , comment character ( len = 2 * symbol_length ), allocatable :: args (:), args2 (:) character ( len = symbol_length ), allocatable :: sym (:) type ( structure_info ) :: info selective = . false . ! Selective dynamics cartesian = . true . ! Cartesian or direct lattice = 0 stat = 0 ntype = 0 ! first line contains the symbols of different atom types call getline ( unit , line , stat ) if ( stat /= 0 ) then call fatal_error ( error , \"Unexpected end of input encountered\" ) return end if if ( debug ) print '(\">\", a)' , line call parse_line ( line , args , ntype ) call move_alloc ( line , comment ) ! this line contains the global scaling factor, call getline ( unit , line , stat ) if ( stat /= 0 ) then call fatal_error ( error , \"Unexpected end of input encountered\" ) return end if if ( debug ) print '(\">\", a)' , line read ( line , * , iostat = stat ) ddum if ( stat /= 0 ) then call fatal_error ( error , \"Cannot read scaling factor from input\" ) return end if ! the Ang->au conversion is included in the scaling factor if ( debug ) print '(\"->\", g0)' , ddum scalar = ddum * aatoau ! reading the lattice constants do i = 1 , 3 call getline ( unit , line , stat ) if ( stat /= 0 ) then call fatal_error ( error , \"Unexpected end of lattice vectors encountered\" ) return end if if ( debug ) print '(\"->\", a)' , line read ( line , * , iostat = stat ) latvec if ( stat /= 0 ) then call fatal_error ( error , \"Cannot read lattice vectors from input\" ) return end if lattice (:, i ) = latvec * scalar end do ! Either here are the numbers of each element, ! or (>vasp.5.1) here are the element symbols call getline ( unit , line , stat ) if ( stat /= 0 ) then call fatal_error ( error , \"Unexpected end of input encountered\" ) return end if if ( debug ) print '(\">\", a)' , line ! try to verify that first element is actually a number i = max ( verify ( line , ' ' ), 1 ) j = scan ( line ( i :), ' ' ) - 2 + i if ( j < i ) j = len_trim ( line ) ! CONTCAR files have additional Element line here since vasp.5.1 if ( verify ( line ( i : j ), '1234567890' ) /= 0 ) then call parse_line ( line , args , ntype ) call getline ( unit , line , stat ) if ( debug ) print '(\"->\", a)' , line if ( stat /= 0 ) then call fatal_error ( error , \"Unexpected end of input encountered\" ) return end if else deallocate ( comment ) end if call parse_line ( line , args2 , nn ) if ( nn /= ntype ) then call fatal_error ( error , 'Number of atom types mismatches the number of counts' ) return end if allocate ( ncount ( nn ), source = 0 ) do i = 1 , nn read ( args2 ( i ), * , iostat = stat ) ncount ( i ) izp = to_number ( args ( i )) if ( izp < 1 . or . ncount ( i ) < 1 ) then call fatal_error ( error , \"Unknown element '\" // trim ( args ( i )) // \"' encountered\" ) return end if end do natoms = sum ( ncount ) allocate ( sym ( natoms )) allocate ( xyz ( 3 , natoms )) k = 0 do i = 1 , nn do j = 1 , ncount ( i ) k = k + 1 sym ( k ) = trim ( args ( i )) end do end do call getline ( unit , line , stat ) if ( stat /= 0 ) then call fatal_error ( error , \"Could not read POSCAR\" ) return end if if ( debug ) print '(\">\", a)' , line line = adjustl ( line ) if ( line (: 1 ). eq . 's' . or . line (: 1 ). eq . 'S' ) then selective = . true . call getline ( unit , line , stat ) if ( debug ) print '(\"->\", a)' , line if ( stat /= 0 ) then call fatal_error ( error , \"Unexpected end of input encountered\" ) return end if line = adjustl ( line ) end if cartesian = ( line (: 1 ). eq . 'c' . or . line (: 1 ). eq . 'C' . or . & & line (: 1 ). eq . 'k' . or . line (: 1 ). eq . 'K' ) do i = 1 , natoms call getline ( unit , line , stat ) if ( stat /= 0 ) then call fatal_error ( error , \"Unexpected end of geometry encountered\" ) return end if if ( debug ) print '(\"-->\", a)' , line read ( line , * , iostat = stat ) coord if ( stat /= 0 ) then call fatal_error ( error , \"Cannot read geometry from input\" ) return end if if ( cartesian ) then xyz (:, i ) = coord * scalar else xyz (:, i ) = matmul ( lattice , coord ) end if end do ! save information about this POSCAR for later info = structure_info ( scale = ddum , selective = selective , cartesian = cartesian ) call new ( self , sym , xyz , lattice = lattice , info = info ) if ( allocated ( comment )) self % comment = comment end subroutine read_vasp","tags":"","loc":"proc/read_vasp.html"},{"title":"read_xyz – MCTC-library","text":"public subroutine read_xyz(self, unit, error) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: self Instance of the molecular structure data integer, intent(in) :: unit File handle type( error_type ), intent(out), allocatable :: error Error handling Contents Source Code read_xyz Source Code subroutine read_xyz ( self , unit , error ) !> Instance of the molecular structure data type ( structure_type ), intent ( out ) :: self !> File handle integer , intent ( in ) :: unit !> Error handling type ( error_type ), allocatable , intent ( out ) :: error integer :: ii , n , iat , stat real ( wp ) :: x , y , z , conv real ( wp ), allocatable :: xyz (:, :) character ( len = symbol_length ) :: chdum character ( len = symbol_length ), allocatable :: sym (:) character ( len = :), allocatable :: line , comment conv = aatoau read ( unit , * , iostat = stat ) n if ( stat /= 0 ) then call fatal_error ( error , \"Could not read number of atoms, check format!\" ) return end if if ( n . lt . 1 ) then call fatal_error ( error , \"Found no atoms, cannot work without atoms!\" ) return end if allocate ( sym ( n )) allocate ( xyz ( 3 , n )) ! next record is a comment call getline ( unit , comment , stat ) if ( stat /= 0 ) then call fatal_error ( error , \"Unexpected end of file\" ) return end if ii = 0 do while ( ii < n ) call getline ( unit , line , stat ) if ( is_iostat_end ( stat )) exit if ( stat /= 0 ) then call fatal_error ( error , \"Could not read geometry from xyz file\" ) return end if read ( line , * , iostat = stat ) chdum , x , y , z if ( stat /= 0 ) then call fatal_error ( error , \"Could not parse coordinates from xyz file\" ) return end if iat = to_number ( chdum ) if ( iat <= 0 ) then read ( chdum , * , iostat = stat ) iat if ( stat == 0 ) then chdum = to_symbol ( iat ) else iat = 0 end if end if if ( iat > 0 ) then ii = ii + 1 sym ( ii ) = trim ( chdum ) xyz (:, ii ) = [ x , y , z ] * conv else call fatal_error ( error , \"Unknown element symbol: '\" // trim ( chdum ) // \"'\" ) return end if end do if ( ii /= n ) then call fatal_error ( error , \"Atom number missmatch in xyz file\" ) return end if call new ( self , sym , xyz ) if ( len ( comment ) > 0 ) self % comment = comment end subroutine read_xyz","tags":"","loc":"proc/read_xyz.html"},{"title":"get_arguments – MCTC-library","text":"subroutine get_arguments(input, input_format, output, output_format, normalize, template, template_format, error) Arguments Type Intent Optional Attributes Name character(len=:), allocatable :: input Input file name integer, intent(out), allocatable :: input_format Input file format character(len=:), allocatable :: output Output file name integer, intent(out), allocatable :: output_format Output file format logical, intent(out) :: normalize Normalize element symbols character(len=:), allocatable :: template Template file name integer, intent(out), allocatable :: template_format Template file format type(error_type), intent(out), allocatable :: error Error handling Contents Source Code get_arguments Source Code subroutine get_arguments ( input , input_format , output , output_format , normalize , & & template , template_format , error ) !> Input file name character ( len = :), allocatable :: input !> Input file format integer , allocatable , intent ( out ) :: input_format !> Output file name character ( len = :), allocatable :: output !> Output file format integer , allocatable , intent ( out ) :: output_format !> Template file name character ( len = :), allocatable :: template !> Template file format integer , allocatable , intent ( out ) :: template_format !> Normalize element symbols logical , intent ( out ) :: normalize !> Error handling type ( error_type ), allocatable , intent ( out ) :: error integer :: iarg , narg character ( len = :), allocatable :: arg normalize = . false . iarg = 0 narg = command_argument_count () do while ( iarg < narg ) iarg = iarg + 1 call get_argument ( iarg , arg ) select case ( arg ) case ( \"--help\" ) call help ( output_unit ) stop case ( \"--version\" ) call version ( output_unit ) stop case default if (. not . allocated ( input )) then call move_alloc ( arg , input ) cycle end if if (. not . allocated ( output )) then call move_alloc ( arg , output ) cycle end if call fatal_error ( error , \"Too many positional arguments present\" ) exit case ( \"-i\" , \"--input\" ) iarg = iarg + 1 call get_argument ( iarg , arg ) if (. not . allocated ( arg )) then call fatal_error ( error , \"Missing argument for input format\" ) exit end if input_format = get_filetype ( \".\" // arg ) case ( \"-o\" , \"--output\" ) iarg = iarg + 1 call get_argument ( iarg , arg ) if (. not . allocated ( arg )) then call fatal_error ( error , \"Missing argument for output format\" ) exit end if output_format = get_filetype ( \".\" // arg ) case ( \"--normalize\" ) normalize = . true . case ( \"--template\" ) iarg = iarg + 1 call get_argument ( iarg , template ) if (. not . allocated ( template )) then call fatal_error ( error , \"Missing argument for template file\" ) exit end if case ( \"--template-format\" ) iarg = iarg + 1 call get_argument ( iarg , arg ) if (. not . allocated ( arg )) then call fatal_error ( error , \"Missing argument for template format\" ) exit end if template_format = get_filetype ( \".\" // arg ) end select end do if (. not .( allocated ( input ). and .( allocated ( output )))) then if (. not . allocated ( error )) then call help ( output_unit ) error stop end if end if end subroutine get_arguments","tags":"","loc":"proc/get_arguments.html"},{"title":"help – MCTC-library","text":"subroutine help(unit) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit Contents Source Code help Source Code subroutine help ( unit ) integer , intent ( in ) :: unit write ( unit , '(a, *(1x, a))' ) & \"Usage: \" // prog_name // \" [options] <input> <output>\" write ( unit , '(a)' ) & \"\" , & \"Read structure from input file and writes it to output file.\" , & \"The format is determined by the file extension or the format hint\" , & \"\" write ( unit , '(2x, a, t25, a)' ) & \"-i, --input <format>\" , \"Hint for the format of the input file\" , & \"-o, --output <format>\" , \"Hint for the format of the output file\" , & \"--normalize\" , \"Normalize all element symbols to capitalized format\" , & \"--template <file>\" , \"File to use as template to fill in meta data\" , & \"\" , \"(useful to add back SDF or PDB annotions)\" , & \"--template-format <format>\" , \"\" , \"\" , \"Hint for the format of the template file\" , & \"--version\" , \"Print program version and exit\" , & \"--help\" , \"Show this help message\" write ( unit , '(a)' ) end subroutine help","tags":"","loc":"proc/help.html"},{"title":"version – MCTC-library","text":"subroutine version(unit) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit Contents Source Code version Source Code subroutine version ( unit ) integer , intent ( in ) :: unit character ( len = :), allocatable :: version_string call get_mctc_version ( string = version_string ) write ( unit , '(a, *(1x, a))' ) & & prog_name , \"version\" , version_string end subroutine version","tags":"","loc":"proc/version.html"},{"title":"mctc_env – MCTC-library","text":"Public API reexport of environment library Uses mctc_env_accuracy mctc_env_error mctc_env_system Contents None","tags":"","loc":"module/mctc_env.html"},{"title":"mctc_io – MCTC-library","text":"Input and output module of the tool chain library. This module exports the basic structure_type as well as routines\n to read it from a file or formatted unit ( read_structure ) or write\n it to a formatted unit ( write_structure ). Both read_structure and write_structure take format hints from\n the filetype enumerator. File names can be translated to the respective\n enumerator by using the get_filetype function. This can be useful in\n case the caller routine wants to open the formatted unit itself or uses\n a non-standard file extension. Uses mctc_io_filetype mctc_io_read mctc_io_structure mctc_io_symbols mctc_io_write Contents None","tags":"","loc":"module/mctc_io.html"},{"title":"mctc_version – MCTC-library","text":"Contents Variables mctc_version_compact mctc_version_string Subroutines get_mctc_version Variables Type Visibility Attributes Name Initial integer, public, parameter :: mctc_version_compact (3) = [0, 2, 1] Numeric representation of the mctc-lib version character(len=*), public, parameter :: mctc_version_string = \"0.2.1\" String representation of the mctc-lib version Subroutines public subroutine get_mctc_version (major, minor, patch, string) Getter function to retrieve mctc-lib version Arguments Type Intent Optional Attributes Name integer, intent(out), optional :: major Major version number of the mctc-lib version integer, intent(out), optional :: minor Minor version number of the mctc-lib version integer, intent(out), optional :: patch Patch version number of the mctc-lib version character(len=:), intent(out), optional allocatable :: string String representation of the mctc-lib version","tags":"","loc":"module/mctc_version.html"},{"title":"mctc_env_testing – MCTC-library","text":"Provides a light-weight testing framework for usage in projects depending on\n the tool chain library. Testsuites are defined by a collect_interface returning a set of unittest_type objects. To create a new test use the new_unittest constructor, which requires a test identifier and a procedure with a test_interface compatible signature. The error status is communicated\n by the allocation status of an error_type . The necessary boilerplate code to setup the test entry point is just program tester use , intrinsic :: iso_fortran_env , only : error_unit use mctc_env_testing , only : run_testsuite , new_testsuite , testsuite_type use test_suite1 , only : collect_suite1 use test_suite2 , only : collect_suite2 implicit none integer :: stat , ii type ( testsuite_type ), allocatable :: testsuites (:) character ( len =* ), parameter :: fmt = '(\"#\", *(1x, a))' stat = 0 testsuites = [ & & new_testsuite ( \"suite1\" , collect_suite1 ), & & new_testsuite ( \"suite2\" , collect_suite2 ) & & ] do ii = 1 , size ( testsuites ) write ( error_unit , fmt ) \"Testing:\" , testsuites ( ii )% name call run_testsuite ( testsuites ( ii )% collect , error_unit , stat ) end do if ( stat > 0 ) then write ( error_unit , '(i0, 1x, a)' ) stat , \"test(s) failed!\" error stop end if end program tester Every test is defined in a separate module using a collect function, which\n is exported and added to the testsuites array in the test runner.\n All test have a simple interface with just an allocatable error_type as\n output to provide the test results. module test_suite1 use mctc_env_testing , only : new_unittest , unittest_type , error_type , check implicit none private public :: collect_suite1 contains !> Collect all exported unit tests subroutine collect_suite1 ( testsuite ) !> Collection of tests type ( unittest_type ), allocatable , intent ( out ) :: testsuite (:) testsuite = [ & & new_unittest ( \"valid\" , test_valid ), & & new_unittest ( \"invalid\" , test_invalid , should_fail = . true .) & & ] end subroutine collect_suite1 subroutine test_valid ( error ) type ( error_type ), allocatable , intent ( out ) :: error ! ... end subroutine test_valid subroutine test_invalid ( error ) type ( error_type ), allocatable , intent ( out ) :: error ! ... end subroutine test_invalid end module test_suite1 For an example setup checkout the test/ directory in this project. Uses mctc_env_error mctc_env_accuracy Contents Interfaces check Abstract Interfaces collect_interface test_interface Derived Types testsuite_type unittest_type Functions new_testsuite new_unittest select_suite select_test Subroutines run_selected run_testsuite test_failed Interfaces public interface check private subroutine check_stat(error, stat, message, more) Arguments Type Intent Optional Attributes Name type( error_type ), intent(out), allocatable :: error Error handling integer, intent(in) :: stat Status of operation character(len=*), intent(in), optional :: message A detailed message describing the error character(len=*), intent(in), optional :: more Another line of error message private subroutine check_logical(error, expression, message, more) Arguments Type Intent Optional Attributes Name type( error_type ), intent(out), allocatable :: error Error handling logical, intent(in) :: expression Result of logical operator character(len=*), intent(in), optional :: message A detailed message describing the error character(len=*), intent(in), optional :: more Another line of error message private subroutine check_float_sp(error, actual, expected, message, more, thr, rel) Arguments Type Intent Optional Attributes Name type( error_type ), intent(out), allocatable :: error Error handling real(kind=sp), intent(in) :: actual Found floating point value real(kind=sp), intent(in) :: expected Expected floating point value character(len=*), intent(in), optional :: message A detailed message describing the error character(len=*), intent(in), optional :: more Another line of error message real(kind=sp), intent(in), optional :: thr Allowed threshold for matching floating point values logical, intent(in), optional :: rel Check for relative errors instead private subroutine check_float_dp(error, actual, expected, message, more, thr, rel) Arguments Type Intent Optional Attributes Name type( error_type ), intent(out), allocatable :: error Error handling real(kind=dp), intent(in) :: actual Found floating point value real(kind=dp), intent(in) :: expected Expected floating point value character(len=*), intent(in), optional :: message A detailed message describing the error character(len=*), intent(in), optional :: more Another line of error message real(kind=dp), intent(in), optional :: thr Allowed threshold for matching floating point values logical, intent(in), optional :: rel Check for relative errors instead private subroutine check_int_i1(error, actual, expected, message, more) Arguments Type Intent Optional Attributes Name type( error_type ), intent(out), allocatable :: error Error handling integer(kind=i1), intent(in) :: actual Found integer value integer(kind=i1), intent(in) :: expected Expected integer value character(len=*), intent(in), optional :: message A detailed message describing the error character(len=*), intent(in), optional :: more Another line of error message private subroutine check_int_i2(error, actual, expected, message, more) Arguments Type Intent Optional Attributes Name type( error_type ), intent(out), allocatable :: error Error handling integer(kind=i2), intent(in) :: actual Found integer value integer(kind=i2), intent(in) :: expected Expected integer value character(len=*), intent(in), optional :: message A detailed message describing the error character(len=*), intent(in), optional :: more Another line of error message private subroutine check_int_i4(error, actual, expected, message, more) Arguments Type Intent Optional Attributes Name type( error_type ), intent(out), allocatable :: error Error handling integer(kind=i4), intent(in) :: actual Found integer value integer(kind=i4), intent(in) :: expected Expected integer value character(len=*), intent(in), optional :: message A detailed message describing the error character(len=*), intent(in), optional :: more Another line of error message private subroutine check_int_i8(error, actual, expected, message, more) Arguments Type Intent Optional Attributes Name type( error_type ), intent(out), allocatable :: error Error handling integer(kind=i8), intent(in) :: actual Found integer value integer(kind=i8), intent(in) :: expected Expected integer value character(len=*), intent(in), optional :: message A detailed message describing the error character(len=*), intent(in), optional :: more Another line of error message private subroutine check_bool(error, actual, expected, message, more) Arguments Type Intent Optional Attributes Name type( error_type ), intent(out), allocatable :: error Error handling logical, intent(in) :: actual Found boolean value logical, intent(in) :: expected Expected boolean value character(len=*), intent(in), optional :: message A detailed message describing the error character(len=*), intent(in), optional :: more Another line of error message private subroutine check_string(error, actual, expected, message, more) Arguments Type Intent Optional Attributes Name type( error_type ), intent(out), allocatable :: error Error handling character(len=*), intent(in) :: actual Found boolean value character(len=*), intent(in) :: expected Expected boolean value character(len=*), intent(in), optional :: message A detailed message describing the error character(len=*), intent(in), optional :: more Another line of error message Abstract Interfaces abstract interface public subroutine collect_interface(testsuite) Collect all tests Arguments Type Intent Optional Attributes Name type( unittest_type ), intent(out), allocatable :: testsuite (:) Collection of tests abstract interface public subroutine test_interface(error) Entry point for tests Arguments Type Intent Optional Attributes Name type( error_type ), intent(out), allocatable :: error Error handling Derived Types type, public :: testsuite_type Collection of unit tests Components Type Visibility Attributes Name Initial procedure( collect_interface ), public, pointer, nopass :: collect => null() Entry point of the test character(len=:), public, allocatable :: name Name of the testsuite type, public :: unittest_type Declaration of a unit test Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: name Name of the test logical, public :: should_fail = .false. Whether test is supposed to fail procedure( test_interface ), public, pointer, nopass :: test => null() Entry point of the test Functions public function new_testsuite (name, collect) result(self) Register a new testsuite Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Name of the testsuite procedure( collect_interface ) :: collect Entry point to collect tests Return Value type( testsuite_type ) Newly registered testsuite public function new_unittest (name, test, should_fail) result(self) Register a new unit test Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Name of the test procedure( test_interface ) :: test Entry point for the test logical, intent(in), optional :: should_fail Whether test is supposed to error or not Return Value type( unittest_type ) Newly registered test public function select_suite (suites, name) result(pos) Select a test suite from all available suites Arguments Type Intent Optional Attributes Name type( testsuite_type ) :: suites (:) Available test suites character(len=*), intent(in) :: name Name identifying the test suite Return Value integer Selected test suite public function select_test (tests, name) result(pos) Select a unit test from all available tests Arguments Type Intent Optional Attributes Name type( unittest_type ) :: tests (:) Available unit tests character(len=*), intent(in) :: name Name identifying the test suite Return Value integer Selected test suite Subroutines public subroutine run_selected (collect, name, unit, stat) Driver for selective testing Arguments Type Intent Optional Attributes Name procedure( collect_interface ) :: collect Collect tests character(len=*), intent(in) :: name Name of the selected test integer, intent(in) :: unit Unit for IO integer, intent(inout) :: stat Number of failed tests public subroutine run_testsuite (collect, unit, stat) Driver for testsuite Arguments Type Intent Optional Attributes Name procedure( collect_interface ) :: collect Collect tests integer, intent(in) :: unit Unit for IO integer, intent(inout) :: stat Number of failed tests public subroutine test_failed (error, message, more) Arguments Type Intent Optional Attributes Name type( error_type ), intent(out), allocatable :: error Error handling character(len=*), intent(in) :: message A detailed message describing the error character(len=*), intent(in), optional :: more Another line of error message","tags":"","loc":"module/mctc_env_testing.html"},{"title":"mctc_env_system – MCTC-library","text":"Module collecting commands to conveniently interface with system commands Contents Functions is_unix is_windows Subroutines get_argument get_variable Functions public function is_unix () Try to determine if we run on Unix and probably can rely on POSIX compliance Arguments None Return Value logical Operating system seems to be Unix public function is_windows () Try to determine if we run on Windows and don’t have POSIX compliance around Arguments None Return Value logical Operating system seems to be Windows Subroutines public subroutine get_argument (idx, arg) Obtain the command line argument at a given index Arguments Type Intent Optional Attributes Name integer, intent(in) :: idx Index of command line argument, range [0:command_argument_count()] character(len=:), intent(out), allocatable :: arg Command line argument public subroutine get_variable (var, val) Obtain the value of an environment variable Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: var Name of variable character(len=:), intent(out), allocatable :: val Value of variable","tags":"","loc":"module/mctc_env_system.html"},{"title":"mctc_env_error – MCTC-library","text":"Central registry for error codes Contents Variables mctc_stat Derived Types error_type Subroutines fatal_error Variables Type Visibility Attributes Name Initial type(enum_stat), public, parameter :: mctc_stat = enum_stat() Actual enumerator for return states Derived Types type, public :: error_type Error message Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: message Payload of the error integer, public :: stat Error code Subroutines public subroutine fatal_error (error, message, stat) A fatal error is encountered Arguments Type Intent Optional Attributes Name type( error_type ), intent(out), allocatable :: error Instance of the error character(len=*), intent(in), optional :: message A detailed message describing the error and (optionally) offering advice integer, intent(in), optional :: stat Overwrite of the error code","tags":"","loc":"module/mctc_env_error.html"},{"title":"mctc_env_accuracy – MCTC-library","text":"Numerical storage size parameters for real and integer values Contents Variables dp i1 i2 i4 i8 sp wp Variables Type Visibility Attributes Name Initial integer, public, parameter :: dp = selected_real_kind(15) Double precision real numbers integer, public, parameter :: i1 = selected_int_kind(2) Char length for integers integer, public, parameter :: i2 = selected_int_kind(4) Short length for integers integer, public, parameter :: i4 = selected_int_kind(9) Length of default integers integer, public, parameter :: i8 = selected_int_kind(18) Long length for integers integer, public, parameter :: sp = selected_real_kind(6) Single precision real numbers integer, public, parameter :: wp = dp Wanted precision","tags":"","loc":"module/mctc_env_accuracy.html"},{"title":"mctc_io_symbols – MCTC-library","text":"Handle conversion between element symbols and atomic numbers Uses mctc_io_resize Contents Variables symbol_length Interfaces get_identity Functions to_lcsymbol to_number to_symbol Subroutines collect_identical number_to_lcsymbol number_to_symbol symbol_to_number Variables Type Visibility Attributes Name Initial integer, public, parameter :: symbol_length = 4 Maximum allowed length of element symbols Interfaces public interface get_identity Get chemical identity private pure subroutine get_identity_number(nid, identity, number) Get chemical identity from a list of atomic numbers Arguments Type Intent Optional Attributes Name integer, intent(out) :: nid Number of unique species integer, intent(out) :: identity (:) Chemical identity integer, intent(in) :: number (:) Ordinal numbers private pure subroutine get_identity_symbol(nid, identity, symbol) Get chemical identity from a list of element symbols Arguments Type Intent Optional Attributes Name integer, intent(out) :: nid Number of unique species integer, intent(out) :: identity (:) Chemical identity character(len=symbol_length), intent(in) :: symbol (:) Element symbols Functions public elemental function to_lcsymbol (number) result(symbol) Convert atomic number to element symbol Arguments Type Intent Optional Attributes Name integer, intent(in) :: number Atomic number Return Value character(len=2) Element symbol public elemental function to_number (symbol) result(number) Convert element symbol to atomic number Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: symbol Element symbol Return Value integer Atomic number public elemental function to_symbol (number) result(symbol) Convert atomic number to element symbol Arguments Type Intent Optional Attributes Name integer, intent(in) :: number Atomic number Return Value character(len=2) Element symbol Subroutines public pure subroutine collect_identical (identity, mapping) Establish a mapping between unique atom types and species Arguments Type Intent Optional Attributes Name integer, intent(in) :: identity (:) Chemical identity integer, intent(out) :: mapping (:) Mapping from unique atoms public elemental subroutine number_to_lcsymbol (symbol, number) Convert atomic number to element symbol Arguments Type Intent Optional Attributes Name character(len=2), intent(out) :: symbol Element symbol integer, intent(in) :: number Atomic number public elemental subroutine number_to_symbol (symbol, number) Convert atomic number to element symbol Arguments Type Intent Optional Attributes Name character(len=2), intent(out) :: symbol Element symbol integer, intent(in) :: number Atomic number public elemental subroutine symbol_to_number (number, symbol) Convert element symbol to atomic number Arguments Type Intent Optional Attributes Name integer, intent(out) :: number Atomic number character(len=*), intent(in) :: symbol Element symbol","tags":"","loc":"module/mctc_io_symbols.html"},{"title":"mctc_io_filetype – MCTC-library","text":"File type support Contents Variables filetype Functions get_filetype Variables Type Visibility Attributes Name Initial type(enum_filetype), public, parameter :: filetype = enum_filetype() File type enumerator Functions public elemental function get_filetype (file) result(ftype) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file Name of the file Return Value integer File type from extension","tags":"","loc":"module/mctc_io_filetype.html"},{"title":"mctc_io_convert – MCTC-library","text":"Conversion factors Uses mctc_env_accuracy mctc_io_constants Contents Variables aatoau autoaa autoc autoeV autogmol autokcal autokg autokj autonm autorcm caltoj ctoau evtoau gmoltoau gmoltokg jtocal kcaltoau kgtoau kgtogmol kjtoau nmtoau rcmtoau Variables Type Visibility Attributes Name Initial real(kind=wp), public, parameter :: aatoau = 1.0_wp/autoaa Conversion factor from Ångström to bohr real(kind=wp), public, parameter :: autoaa = bohr*1e10_wp Conversion factor from bohr to Ångström real(kind=wp), public, parameter :: autoc = codata%e Coulomb to atomic charge units real(kind=wp), public, parameter :: autoeV = hartree/codata%e Conversion factor from hartree to electron volts real(kind=wp), public, parameter :: autogmol = codata%me*codata%na*1e+3_wp Molecular mass per mole (g/mol) to electron mass (a.u.) real(kind=wp), public, parameter :: autokcal = autokJ*Jtocal Conversion from hartree to kcal/mol real(kind=wp), public, parameter :: autokg = codata%me Conversion from electron mass (a.u.) to kg real(kind=wp), public, parameter :: autokj = hartree*codata%na*1e-3_wp Conversion from hartree to kJ/mol real(kind=wp), public, parameter :: autonm = codata%h*codata%c/hartree*1e+9_wp Conversion from hartree to nanometers (wavelength) real(kind=wp), public, parameter :: autorcm = hartree/(codata%h*codata%c)*1e-2_wp Conversion from hartree to reciprocal centimeters real(kind=wp), public, parameter :: caltoj = 4.184_wp Coversion factor between calorine and joule real(kind=wp), public, parameter :: ctoau = 1.0_wp/autoc Atomic charge units to Coulomb real(kind=wp), public, parameter :: evtoau = 1.0_wp/autoev Conversion factor from electron volts to hartree real(kind=wp), public, parameter :: gmoltoau = 1.0_wp/autogmol Electron mass (a.u.) to molecular mass per mole (g/mol) real(kind=wp), public, parameter :: gmoltokg = gmoltoau*autokg Molecular mass per mole (g/mol) to kg real(kind=wp), public, parameter :: jtocal = 1.0_wp/caltoj Coversion factor between joule and calorine real(kind=wp), public, parameter :: kcaltoau = 1.0_wp/autokcal Conversion from kcal/mol to hartree real(kind=wp), public, parameter :: kgtoau = 1.0_wp/autokg Conversion from kg to electron mass (a.u.) real(kind=wp), public, parameter :: kgtogmol = 1.0_wp/gmoltokg kg to molecular mass per mole (g/mol) real(kind=wp), public, parameter :: kjtoau = 1.0_wp/autokj Conversion from kJ/mol to hartree real(kind=wp), public, parameter :: nmtoau = 1.0_wp/autonm Conversion from nanometers (wavelength) to hartree real(kind=wp), public, parameter :: rcmtoau = 1.0_wp/autorcm Conversion from reciprocal centimeters to hartree","tags":"","loc":"module/mctc_io_convert.html"},{"title":"mctc_io_utils – MCTC-library","text":"Contents Subroutines getline Subroutines public subroutine getline (unit, line, iostat, iomsg) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit Formatted IO unit character(len=:), intent(out), allocatable :: line Line to read integer, intent(out) :: iostat Status of operation character(len=:), optional allocatable :: iomsg Error message","tags":"","loc":"module/mctc_io_utils.html"},{"title":"mctc_io_structure – MCTC-library","text":"Basic structure representation of the system of interest Uses mctc_env_accuracy mctc_io_symbols mctc_io_structure_info Contents Interfaces new Derived Types structure_type Subroutines new_structure Interfaces public interface new public subroutine new_structure (self, num, sym, xyz, charge, uhf, lattice, periodic, info, bond) Constructor for structure representations Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: self Instance of the structure representation integer, intent(in) :: num (:) Atomic numbers character(len=*), intent(in) :: sym (:) Element symbols real(kind=wp), intent(in) :: xyz (:,:) Cartesian coordinates real(kind=wp), intent(in), optional :: charge Total charge integer, intent(in), optional :: uhf Number of unpaired electrons real(kind=wp), intent(in), optional :: lattice (:,:) Lattice parameters logical, intent(in), optional :: periodic (:) Periodic directions type( structure_info ), intent(in), optional :: info Vendor specific structure information integer, intent(in), optional :: bond (:,:) Bond topology of the system private subroutine new_structure_num(self, num, xyz, charge, uhf, lattice, periodic, info, bond) Simplified constructor for structure representations Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: self Instance of the structure representation integer, intent(in) :: num (:) Atomic numbers real(kind=wp), intent(in) :: xyz (:,:) Cartesian coordinates real(kind=wp), intent(in), optional :: charge Total charge integer, intent(in), optional :: uhf Number of unpaired electrons real(kind=wp), intent(in), optional :: lattice (:,:) Lattice parameters logical, intent(in), optional :: periodic (:) Periodic directions type( structure_info ), intent(in), optional :: info Vendor specific structure information integer, intent(in), optional :: bond (:,:) Bond topology of the system private subroutine new_structure_sym(self, sym, xyz, charge, uhf, lattice, periodic, info, bond) Simplified constructor for structure representations Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: self Instance of the structure representation character(len=*), intent(in) :: sym (:) Element symbols real(kind=wp), intent(in) :: xyz (:,:) Cartesian coordinates real(kind=wp), intent(in), optional :: charge Total charge integer, intent(in), optional :: uhf Number of unpaired electrons real(kind=wp), intent(in), optional :: lattice (:,:) Lattice parameters logical, intent(in), optional :: periodic (:) Periodic directions type( structure_info ), intent(in), optional :: info Vendor specific structure information integer, intent(in), optional :: bond (:,:) Bond topology of the system Derived Types type, public :: structure_type Structure representation Components Type Visibility Attributes Name Initial integer, public, allocatable :: bond (:,:) Bond indices real(kind=wp), public :: charge = 0.0_wp Total charge character(len=:), public, allocatable :: comment Comment, name or identifier for this structure integer, public, allocatable :: id (:) Species identifier type( structure_info ), public :: info = structure_info() Vendor specific structure annotations real(kind=wp), public, allocatable :: lattice (:,:) Lattice parameters integer, public :: nat = 0 Number of atoms integer, public :: nbd = 0 Number of bonds integer, public :: nid = 0 Number of unique species integer, public, allocatable :: num (:) Atomic number for each species type( pdb_data ), public, allocatable :: pdb (:) PDB atomic data annotations logical, public, allocatable :: periodic (:) Periodic directions type( sdf_data ), public, allocatable :: sdf (:) SDF atomic data annotations character(len=symbol_length), public, allocatable :: sym (:) Element symbol for each species integer, public :: uhf = 0 Number of unpaired electrons real(kind=wp), public, allocatable :: xyz (:,:) Cartesian coordinates, in Bohr Subroutines public subroutine new_structure (self, num, sym, xyz, charge, uhf, lattice, periodic, info, bond) Constructor for structure representations Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: self Instance of the structure representation integer, intent(in) :: num (:) Atomic numbers character(len=*), intent(in) :: sym (:) Element symbols real(kind=wp), intent(in) :: xyz (:,:) Cartesian coordinates real(kind=wp), intent(in), optional :: charge Total charge integer, intent(in), optional :: uhf Number of unpaired electrons real(kind=wp), intent(in), optional :: lattice (:,:) Lattice parameters logical, intent(in), optional :: periodic (:) Periodic directions type( structure_info ), intent(in), optional :: info Vendor specific structure information integer, intent(in), optional :: bond (:,:) Bond topology of the system","tags":"","loc":"module/mctc_io_structure.html"},{"title":"mctc_io_constants – MCTC-library","text":"Numerical constants Uses mctc_env_accuracy Contents Variables codata pi Variables Type Visibility Attributes Name Initial type(enum_codata), public, parameter :: codata = enum_codata() Actual collection of natural constants real(kind=wp), public, parameter :: pi = 3.1415926535897932384626433832795029_wp Ratio between a circles diameter and its circumfence","tags":"","loc":"module/mctc_io_constants.html"},{"title":"mctc_io_resize – MCTC-library","text":"Reallocation implementation for resizing arrays Uses mctc_env_accuracy Contents Interfaces resize Interfaces public interface resize Overloaded resize interface private pure subroutine resize_char(var, n) Reallocate list of characters Arguments Type Intent Optional Attributes Name character(len=*), intent(inout), allocatable :: var (:) Instance of the array to be resized integer, intent(in), optional :: n Dimension of the final array size private pure subroutine resize_int(var, n) Reallocate list of integers Arguments Type Intent Optional Attributes Name integer, intent(inout), allocatable :: var (:) Instance of the array to be resized integer, intent(in), optional :: n Dimension of the final array size private pure subroutine resize_real(var, n) Reallocate list of reals Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), allocatable :: var (:) Instance of the array to be resized integer, intent(in), optional :: n Dimension of the final array size private pure subroutine resize_real_2d(var, n) Reallocate list of reals Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), allocatable :: var (:,:) Instance of the array to be resized integer, intent(in), optional :: n Dimension of the final array size","tags":"","loc":"module/mctc_io_resize.html"},{"title":"mctc_io_read – MCTC-library","text":"Uses mctc_env_error mctc_io_filetype mctc_io_read_ctfile mctc_io_read_gaussian mctc_io_read_genformat mctc_io_read_pdb mctc_io_read_turbomole mctc_io_read_vasp mctc_io_read_xyz mctc_io_structure Contents Interfaces read_structure Abstract Interfaces structure_reader Subroutines get_structure_reader Interfaces public interface read_structure private subroutine read_structure_from_file(self, file, error, format) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: self Instance of the molecular structure data character(len=*), intent(in) :: file Name of the file to read type( error_type ), intent(out), allocatable :: error Error handling integer, intent(in), optional :: format File type format hint private subroutine read_structure_from_unit(self, unit, ftype, error) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: self Instance of the molecular structure data integer, intent(in) :: unit File handle integer, intent(in) :: ftype File type to read type( error_type ), intent(out), allocatable :: error Error handling Abstract Interfaces abstract interface public subroutine structure_reader(self, unit, error) Read molecular structure data from formatted unit Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: self Instance of the molecular structure data integer, intent(in) :: unit File handle type( error_type ), intent(out), allocatable :: error Error handling Subroutines public subroutine get_structure_reader (reader, ftype) Retrieve reader for corresponding file type Arguments Type Intent Optional Attributes Name procedure( structure_reader ), intent(out), pointer :: reader Reader for the specified file type integer, intent(in) :: ftype File type to read","tags":"","loc":"module/mctc_io_read.html"},{"title":"mctc_io_write – MCTC-library","text":"Uses mctc_env_error mctc_io_filetype mctc_io_write_ctfile mctc_io_write_gaussian mctc_io_write_genformat mctc_io_write_pdb mctc_io_write_turbomole mctc_io_write_vasp mctc_io_write_xyz mctc_io_structure Contents Interfaces write_structure Interfaces public interface write_structure private subroutine write_structure_to_file(self, file, error, format) Arguments Type Intent Optional Attributes Name class( structure_type ), intent(in) :: self Instance of the molecular structure data character(len=*), intent(in) :: file Name of the file to read type( error_type ), intent(out), allocatable :: error Error handling integer, intent(in), optional :: format File type format hint private subroutine write_structure_to_unit(self, unit, ftype, error) Arguments Type Intent Optional Attributes Name class( structure_type ), intent(in) :: self Instance of the molecular structure data integer, intent(in) :: unit File handle integer, intent(in) :: ftype File type to read type( error_type ), intent(out), allocatable :: error Error handling","tags":"","loc":"module/mctc_io_write.html"},{"title":"mctc_io_math – MCTC-library","text":"Simple algebraic functions Uses mctc_env_accuracy mctc_io_constants Contents Functions crossprod matdet_3x3 matinv_3x3 Subroutines eigval_3x3 eigvec_3x3 Functions public pure function crossprod (a, b) result(c) Implements the cross/vector product between two 3D vectors Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (3) First vector real(kind=wp), intent(in) :: b (3) Second vector Return Value real(kind=wp)\n  (3) Orthogonal vector public pure function matdet_3x3 (a) result(det) Determinat of 3×3 matrix Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (3,3) Matrix Return Value real(kind=wp) Determinant public pure function matinv_3x3 (a) result(b) Performs a direct calculation of the inverse of a 3×3 matrix. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (3,3) Matrix Return Value real(kind=wp)\n  (3,3) Inverse matrix Subroutines public pure subroutine eigval_3x3 (a, w) Calculates eigenvalues based on the trigonometric solution of A = pB + qI Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (3,3) The symmetric input matrix real(kind=wp), intent(out) :: w (3) Contains eigenvalues on exit public pure subroutine eigvec_3x3 (a, w, q) Calculates eigenvector using an analytical method based on vector cross Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (3,3) real(kind=wp), intent(out) :: w (3) real(kind=wp), intent(out) :: q (3,3)","tags":"","loc":"module/mctc_io_math.html"},{"title":"mctc_io_structure_info – MCTC-library","text":"Uses mctc_env_accuracy Contents Interfaces resize Derived Types pdb_data sdf_data structure_info Interfaces public interface resize private subroutine resize_pdb_data(var, n) Arguments Type Intent Optional Attributes Name type( pdb_data ), intent(inout), allocatable :: var (:) integer, intent(in), optional :: n Derived Types type, public :: pdb_data Atomic pdb data type. Read more… Components Type Visibility Attributes Name Initial character(len=1), public :: chains = ' ' integer, public :: charge = 0 character(len=1), public :: code = ' ' logical, public :: het = .false. character(len=1), public :: loc = ' ' character(len=4), public :: name = ' ' character(len=3), public :: residue = ' ' integer, public :: residue_number = 0 character(len=4), public :: segid = ' ' type, public :: sdf_data SDF atomic data. Read more… Components Type Visibility Attributes Name Initial integer, public :: charge = 0 c field integer, public :: hydrogens = 0 h field integer, public :: isotope = 0 d field integer, public :: valence = 0 v field type, public :: structure_info structure input info Read more… Components Type Visibility Attributes Name Initial logical, public :: angs_coord = .false. Unit of the atomic coordinates should be in Angstrom if possible logical, public :: angs_lattice = .false. Unit of the lattice vectors should be in Angstrom if possible logical, public :: cartesian = .true. Periodic coordinates should use preferrably cartesian coordinates logical, public :: lattice = .true. Lattice information should use preferrably lattice vectors logical, public :: missing_hydrogen = .false. SDF hydrogen query present or PDB without hydrogen atoms found real(kind=wp), public :: scale = 1.0_wp Vasp coordinate scaling information logical, public :: selective = .false. Vasp selective dynamics keyword is present logical, public :: two_dimensional = .false. SDF 2D structure present","tags":"","loc":"module/mctc_io_structure_info.html"},{"title":"mctc_io_write_genformat – MCTC-library","text":"Uses mctc_env_accuracy mctc_io_convert mctc_io_math mctc_io_symbols mctc_io_structure Contents Subroutines write_genformat Subroutines public subroutine write_genformat (mol, unit) Arguments Type Intent Optional Attributes Name class( structure_type ), intent(in) :: mol integer, intent(in) :: unit","tags":"","loc":"module/mctc_io_write_genformat.html"},{"title":"mctc_io_write_pdb – MCTC-library","text":"Uses mctc_env_accuracy mctc_io_convert mctc_io_structure Contents Subroutines write_pdb Subroutines public subroutine write_pdb (mol, unit, number) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(in) :: mol integer, intent(in) :: unit integer, intent(in), optional :: number","tags":"","loc":"module/mctc_io_write_pdb.html"},{"title":"mctc_io_write_ctfile – MCTC-library","text":"Uses mctc_env_accuracy mctc_io_convert mctc_io_structure Contents Subroutines write_molfile write_sdf Subroutines public subroutine write_molfile (self, unit, comment_line) Arguments Type Intent Optional Attributes Name class( structure_type ), intent(in) :: self integer, intent(in) :: unit character(len=*), intent(in), optional :: comment_line public subroutine write_sdf (self, unit, energy, gnorm) Arguments Type Intent Optional Attributes Name class( structure_type ), intent(in) :: self integer, intent(in) :: unit real(kind=wp), intent(in), optional :: energy real(kind=wp), intent(in), optional :: gnorm","tags":"","loc":"module/mctc_io_write_ctfile.html"},{"title":"mctc_io_write_turbomole – MCTC-library","text":"Uses mctc_env_accuracy mctc_io_structure Contents Subroutines write_coord Subroutines public subroutine write_coord (mol, unit) Arguments Type Intent Optional Attributes Name class( structure_type ), intent(in) :: mol integer, intent(in) :: unit","tags":"","loc":"module/mctc_io_write_turbomole.html"},{"title":"mctc_io_write_gaussian – MCTC-library","text":"Uses mctc_env_accuracy mctc_io_structure Contents Subroutines write_gaussian_external Subroutines public subroutine write_gaussian_external (mol, unit) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(in) :: mol integer, intent(in) :: unit","tags":"","loc":"module/mctc_io_write_gaussian.html"},{"title":"mctc_io_write_vasp – MCTC-library","text":"Uses mctc_env_accuracy mctc_io_convert mctc_io_math mctc_io_structure Contents Subroutines write_vasp Subroutines public subroutine write_vasp (self, unit, comment_line) Arguments Type Intent Optional Attributes Name class( structure_type ), intent(in) :: self integer, intent(in) :: unit character(len=*), intent(in), optional :: comment_line","tags":"","loc":"module/mctc_io_write_vasp.html"},{"title":"mctc_io_write_xyz – MCTC-library","text":"Uses mctc_io_convert mctc_io_structure Contents Subroutines write_xyz Subroutines public subroutine write_xyz (self, unit, comment_line) Arguments Type Intent Optional Attributes Name class( structure_type ), intent(in) :: self integer, intent(in) :: unit character(len=*), intent(in), optional :: comment_line","tags":"","loc":"module/mctc_io_write_xyz.html"},{"title":"mctc_io_read_genformat – MCTC-library","text":"Uses mctc_env_accuracy mctc_env_error mctc_io_convert mctc_io_structure mctc_io_structure_info mctc_io_symbols mctc_io_utils Contents Subroutines read_genformat Subroutines public subroutine read_genformat (mol, unit, error) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: mol Instance of the molecular structure data integer, intent(in) :: unit File handle type( error_type ), intent(out), allocatable :: error Error handling","tags":"","loc":"module/mctc_io_read_genformat.html"},{"title":"mctc_io_read_pdb – MCTC-library","text":"Uses mctc_env_accuracy mctc_env_error mctc_io_convert mctc_io_resize mctc_io_symbols mctc_io_structure mctc_io_structure_info mctc_io_utils Contents Subroutines read_pdb Subroutines public subroutine read_pdb (self, unit, error) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: self Instance of the molecular structure data integer, intent(in) :: unit File handle type( error_type ), intent(out), allocatable :: error Error handling","tags":"","loc":"module/mctc_io_read_pdb.html"},{"title":"mctc_io_read_ctfile – MCTC-library","text":"Uses mctc_env_accuracy mctc_env_error mctc_io_convert mctc_io_structure mctc_io_structure_info mctc_io_symbols mctc_io_utils Contents Subroutines read_molfile read_sdf Subroutines public subroutine read_molfile (self, unit, error) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: self Instance of the molecular structure data integer, intent(in) :: unit File handle type( error_type ), intent(out), allocatable :: error Error handling public subroutine read_sdf (self, unit, error) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: self Instance of the molecular structure data integer, intent(in) :: unit File handle type( error_type ), intent(out), allocatable :: error Error handling","tags":"","loc":"module/mctc_io_read_ctfile.html"},{"title":"mctc_io_read_turbomole – MCTC-library","text":"Uses mctc_env_accuracy mctc_env_error mctc_io_constants mctc_io_convert mctc_io_resize mctc_io_structure mctc_io_structure_info mctc_io_symbols mctc_io_utils Contents Subroutines read_coord Subroutines public subroutine read_coord (mol, unit, error) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: mol Instance of the molecular structure data integer, intent(in) :: unit File handle type( error_type ), intent(out), allocatable :: error Error handling","tags":"","loc":"module/mctc_io_read_turbomole.html"},{"title":"mctc_io_read_gaussian – MCTC-library","text":"Uses mctc_env_accuracy mctc_env_error mctc_io_structure Contents Subroutines read_gaussian_external Subroutines public subroutine read_gaussian_external (self, unit, error) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: self Instance of the molecular structure data integer, intent(in) :: unit File handle type( error_type ), intent(out), allocatable :: error Error handling","tags":"","loc":"module/mctc_io_read_gaussian.html"},{"title":"mctc_io_read_vasp – MCTC-library","text":"Uses mctc_env_accuracy mctc_env_error mctc_io_convert mctc_io_resize mctc_io_structure mctc_io_structure_info mctc_io_symbols mctc_io_utils Contents Subroutines read_vasp Subroutines public subroutine read_vasp (self, unit, error) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: self Instance of the molecular structure data integer, intent(in) :: unit File handle type( error_type ), intent(out), allocatable :: error Error handling","tags":"","loc":"module/mctc_io_read_vasp.html"},{"title":"mctc_io_read_xyz – MCTC-library","text":"Uses mctc_env_accuracy mctc_env_error mctc_io_convert mctc_io_structure mctc_io_symbols mctc_io_utils Contents Subroutines read_xyz Subroutines public subroutine read_xyz (self, unit, error) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: self Instance of the molecular structure data integer, intent(in) :: unit File handle type( error_type ), intent(out), allocatable :: error Error handling","tags":"","loc":"module/mctc_io_read_xyz.html"},{"title":"main – MCTC-library","text":"Uses iso_fortran_env mctc_env mctc_io mctc_version Example application using tool chain library. This program uses the read_structure and write_structure procedures\n to implement a structure converter.\n Usually, the input structure can be inferred by the name of the input file.\n To allow formats with non-standard extensions (because most geometry formats\n are not really standardized) additional hints can be passed by the command\n line to determine the read/write formats. To add support for piping standard input and standard output reading and\n writing from units is combined with the additional format hints. Additional filters or modifications can also be implemented in an intermediary\n step, this program implements an element symbol normalization. Other filters\n like folding back to central cells or removing lattice vector could be added\n in a similar manner. Contents Variables error input input_format mol mol_template normalize output output_format prog_name template template_format Subroutines get_arguments help version Source Code main Variables Type Attributes Name Initial type(error_type), allocatable :: error character(len=:), allocatable :: input integer, allocatable :: input_format type( structure_type ) :: mol type( structure_type ), allocatable :: mol_template logical :: normalize character(len=:), allocatable :: output integer, allocatable :: output_format character(len=*), parameter :: prog_name = \"mctc-convert\" character(len=:), allocatable :: template integer, allocatable :: template_format Subroutines subroutine get_arguments (input, input_format, output, output_format, normalize, template, template_format, error) Arguments Type Intent Optional Attributes Name character(len=:), allocatable :: input Input file name integer, intent(out), allocatable :: input_format Input file format character(len=:), allocatable :: output Output file name integer, intent(out), allocatable :: output_format Output file format logical, intent(out) :: normalize Normalize element symbols character(len=:), allocatable :: template Template file name integer, intent(out), allocatable :: template_format Template file format type(error_type), intent(out), allocatable :: error Error handling subroutine help (unit) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit subroutine version (unit) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit Source Code program main use , intrinsic :: iso_fortran_env , only : output_unit , error_unit , input_unit use mctc_env , only : error_type , fatal_error , get_argument , wp use mctc_io , only : structure_type , read_structure , write_structure , & & filetype , get_filetype , to_symbol use mctc_version , only : get_mctc_version implicit none character ( len =* ), parameter :: prog_name = \"mctc-convert\" character ( len = :), allocatable :: input , output , template integer , allocatable :: input_format , output_format , template_format type ( structure_type ) :: mol type ( structure_type ), allocatable :: mol_template type ( error_type ), allocatable :: error logical :: normalize call get_arguments ( input , input_format , output , output_format , normalize , & & template , template_format , error ) if ( allocated ( error )) then write ( error_unit , '(a)' ) error % message error stop end if if ( allocated ( template )) then allocate ( mol_template ) if ( template == \"-\" ) then if (. not . allocated ( template_format )) then template_format = merge ( output_format , filetype % xyz , allocated ( output_format )) end if call read_structure ( mol_template , input_unit , template_format , error ) else call read_structure ( mol_template , template , error , template_format ) end if if ( allocated ( error )) then write ( error_unit , '(a)' ) error % message error stop end if end if if ( input == \"-\" ) then if (. not . allocated ( input_format )) input_format = filetype % xyz call read_structure ( mol , input_unit , input_format , error ) else call read_structure ( mol , input , error , input_format ) end if if ( allocated ( error )) then write ( error_unit , '(a)' ) error % message error stop end if if ( allocated ( mol_template )) then if ( mol % nat /= mol_template % nat ) then write ( error_unit , '(*(a, 1x))' ) & \"Number of atoms missmatch in\" , template , \"and\" , input error stop end if ! move_alloc can also move non-allocated objects call move_alloc ( mol_template % lattice , mol % lattice ) call move_alloc ( mol_template % periodic , mol % periodic ) call move_alloc ( mol_template % bond , mol % bond ) call move_alloc ( mol_template % comment , mol % comment ) call move_alloc ( mol_template % pdb , mol % pdb ) call move_alloc ( mol_template % sdf , mol % sdf ) end if if ( normalize ) then mol % sym = to_symbol ( mol % num ) end if if ( output == \"-\" ) then if (. not . allocated ( output_format )) output_format = filetype % xyz call write_structure ( mol , output_unit , output_format , error ) else call write_structure ( mol , output , error , output_format ) end if if ( allocated ( error )) then write ( error_unit , '(a)' ) error % message error stop end if contains subroutine help ( unit ) integer , intent ( in ) :: unit write ( unit , '(a, *(1x, a))' ) & \"Usage: \" // prog_name // \" [options] <input> <output>\" write ( unit , '(a)' ) & \"\" , & \"Read structure from input file and writes it to output file.\" , & \"The format is determined by the file extension or the format hint\" , & \"\" write ( unit , '(2x, a, t25, a)' ) & \"-i, --input <format>\" , \"Hint for the format of the input file\" , & \"-o, --output <format>\" , \"Hint for the format of the output file\" , & \"--normalize\" , \"Normalize all element symbols to capitalized format\" , & \"--template <file>\" , \"File to use as template to fill in meta data\" , & \"\" , \"(useful to add back SDF or PDB annotions)\" , & \"--template-format <format>\" , \"\" , \"\" , \"Hint for the format of the template file\" , & \"--version\" , \"Print program version and exit\" , & \"--help\" , \"Show this help message\" write ( unit , '(a)' ) end subroutine help subroutine version ( unit ) integer , intent ( in ) :: unit character ( len = :), allocatable :: version_string call get_mctc_version ( string = version_string ) write ( unit , '(a, *(1x, a))' ) & & prog_name , \"version\" , version_string end subroutine version subroutine get_arguments ( input , input_format , output , output_format , normalize , & & template , template_format , error ) !> Input file name character ( len = :), allocatable :: input !> Input file format integer , allocatable , intent ( out ) :: input_format !> Output file name character ( len = :), allocatable :: output !> Output file format integer , allocatable , intent ( out ) :: output_format !> Template file name character ( len = :), allocatable :: template !> Template file format integer , allocatable , intent ( out ) :: template_format !> Normalize element symbols logical , intent ( out ) :: normalize !> Error handling type ( error_type ), allocatable , intent ( out ) :: error integer :: iarg , narg character ( len = :), allocatable :: arg normalize = . false . iarg = 0 narg = command_argument_count () do while ( iarg < narg ) iarg = iarg + 1 call get_argument ( iarg , arg ) select case ( arg ) case ( \"--help\" ) call help ( output_unit ) stop case ( \"--version\" ) call version ( output_unit ) stop case default if (. not . allocated ( input )) then call move_alloc ( arg , input ) cycle end if if (. not . allocated ( output )) then call move_alloc ( arg , output ) cycle end if call fatal_error ( error , \"Too many positional arguments present\" ) exit case ( \"-i\" , \"--input\" ) iarg = iarg + 1 call get_argument ( iarg , arg ) if (. not . allocated ( arg )) then call fatal_error ( error , \"Missing argument for input format\" ) exit end if input_format = get_filetype ( \".\" // arg ) case ( \"-o\" , \"--output\" ) iarg = iarg + 1 call get_argument ( iarg , arg ) if (. not . allocated ( arg )) then call fatal_error ( error , \"Missing argument for output format\" ) exit end if output_format = get_filetype ( \".\" // arg ) case ( \"--normalize\" ) normalize = . true . case ( \"--template\" ) iarg = iarg + 1 call get_argument ( iarg , template ) if (. not . allocated ( template )) then call fatal_error ( error , \"Missing argument for template file\" ) exit end if case ( \"--template-format\" ) iarg = iarg + 1 call get_argument ( iarg , arg ) if (. not . allocated ( arg )) then call fatal_error ( error , \"Missing argument for template format\" ) exit end if template_format = get_filetype ( \".\" // arg ) end select end do if (. not .( allocated ( input ). and .( allocated ( output )))) then if (. not . allocated ( error )) then call help ( output_unit ) error stop end if end if end subroutine get_arguments end program main","tags":"","loc":"program/main.html"},{"title":"Formats – MCTC-library","text":"This library supports reading and writing of the following formats: xyz with extensions Turbomole’s coord connection table files: molfile, structure data format Vasp’s POSCAR format a subset of PDB format DFTB+ general format Gaussian external format","tags":"","loc":"page//index.html"},{"title":"Connection table format – MCTC-library","text":"Specification Note Reference The molfile is identified by the extension mol and the structure data format\nis identified by sdf . Example Caffeine molecule in mol format: 11262021073D\n\n 24  0  0     0  0            999 V2000\n    1.0732    0.0488   -0.0757 C   0  0  0  0  0  0  0  0  0  0  0  0\n    2.5137    0.0126   -0.0758 N   0  0  0  0  0  0  0  0  0  0  0  0\n    3.3520    1.0959   -0.0753 C   0  0  0  0  0  0  0  0  0  0  0  0\n    4.6190    0.7303   -0.0755 N   0  0  0  0  0  0  0  0  0  0  0  0\n    4.5791   -0.6314   -0.0753 C   0  0  0  0  0  0  0  0  0  0  0  0\n    3.3013   -1.1026   -0.0752 C   0  0  0  0  0  0  0  0  0  0  0  0\n    2.9807   -2.4869   -0.0738 C   0  0  0  0  0  0  0  0  0  0  0  0\n    1.8253   -2.9004   -0.0758 O   0  0  0  0  0  0  0  0  0  0  0  0\n    4.1144   -3.3043   -0.0694 N   0  0  0  0  0  0  0  0  0  0  0  0\n    5.4517   -2.8562   -0.0723 C   0  0  0  0  0  0  0  0  0  0  0  0\n    6.3893   -3.6597   -0.0723 O   0  0  0  0  0  0  0  0  0  0  0  0\n    5.6624   -1.4768   -0.0749 N   0  0  0  0  0  0  0  0  0  0  0  0\n    7.0095   -0.9365   -0.0752 C   0  0  0  0  0  0  0  0  0  0  0  0\n    3.9206   -4.7409   -0.0616 C   0  0  0  0  0  0  0  0  0  0  0  0\n    0.7340    1.0879   -0.0750 H   0  0  0  0  0  0  0  0  0  0  0  0\n    0.7124   -0.4570    0.8233 H   0  0  0  0  0  0  0  0  0  0  0  0\n    0.7124   -0.4558   -0.9755 H   0  0  0  0  0  0  0  0  0  0  0  0\n    2.9930    2.1176   -0.0748 H   0  0  0  0  0  0  0  0  0  0  0  0\n    7.7653   -1.7263   -0.0759 H   0  0  0  0  0  0  0  0  0  0  0  0\n    7.1486   -0.3218    0.8197 H   0  0  0  0  0  0  0  0  0  0  0  0\n    7.1480   -0.3208   -0.9695 H   0  0  0  0  0  0  0  0  0  0  0  0\n    2.8650   -5.0232   -0.0583 H   0  0  0  0  0  0  0  0  0  0  0  0\n    4.4023   -5.1592    0.8284 H   0  0  0  0  0  0  0  0  0  0  0  0\n    4.4002   -5.1693   -0.9478 H   0  0  0  0  0  0  0  0  0  0  0  0\nM  END Extensions No extension implemented to the original format. Missing Features The following features are currently not supported: Not all modifiers are supported for the connection table SDF key-value pair annotations are dropped Note Feel free to contribute support for missing features\n      or bring missing features to our attention by opening an issue.","tags":"","loc":"page/./format-ctfile.html"},{"title":"Gaussian external format – MCTC-library","text":"Specification Note Reference The first line of the input is read as four integers of width 10, (4i10) ,\ncontaining the number of atoms in the first integer.\nA run mode specific integer is given in the second entry.\nThe third integer contains the total charge and the fourth integer the spin as\nnumber of unpaired electrons.\nThe total charge and the systems spin are stored in the structure_type . The structure is specified by atomic numbers, cartesian coordinates in atomic units\n(Bohr) and a scalar quantity, usually partial charges using the fixed format (i10,4f20.12) .\nThe element is identified by its atomic number,\nwhich is converted to its capitalized element symbol internally.\nOnly positive, non-zero integers are allowed as atomic numbers. The expected file extension is ein . Examples Caffeine molecule in Gaussian external format: 24         1         0         0\n         6      2.027996941030      0.092313100971     -0.143108928077      0.000000000000\n         7      4.750109032883      0.023734954927     -0.143241208877      0.000000000000\n         6      6.334341685252      2.070988200950     -0.142353037792      0.000000000000\n         7      8.728605263543      1.380028892063     -0.142655393906      0.000000000000\n         6      8.653186310426     -1.193248402810     -0.142315243278      0.000000000000\n         6      6.238570386230     -2.083535979669     -0.142182962479      0.000000000000\n         6      5.632667631585     -4.699502178348     -0.139405065684      0.000000000000\n         8      3.449316339873     -5.480922657010     -0.143184517105      0.000000000000\n         7      7.775087464402     -6.244277357876     -0.131071375299      0.000000000000\n         6     10.302293246446     -5.397396780594     -0.136721655174      0.000000000000\n         8     12.074100072866     -6.915734697428     -0.136664963403      0.000000000000\n         7     10.700382864677     -2.790784724183     -0.141483763966      0.000000000000\n         6     13.245975677887     -1.769690333624     -0.142182962479      0.000000000000\n         6      7.408915313425     -8.959057313972     -0.116369309269      0.000000000000\n         1      1.387020877193      2.055757011721     -0.141786120079      0.000000000000\n         1      1.346221699097     -0.863566855309      1.555905663964      0.000000000000\n         1      1.346240596354     -0.861336978970     -1.843408533601      0.000000000000\n         1      5.655967949599      4.001720959646     -0.141313688652      0.000000000000\n         1     14.674305959118     -3.262309083535     -0.143449078705      0.000000000000\n         1     13.508968805056     -0.608151528241      1.548989267863      0.000000000000\n         1     13.507797175115     -0.606148418987     -1.832145768365      0.000000000000\n         1      5.414083058620     -9.492394601323     -0.110227700709      0.000000000000\n         1      8.319196188304     -9.749472887017      1.565392087032      0.000000000000\n         1      8.315114380769     -9.768540219438     -1.791082028670      0.000000000000 Extensions No extension implemented to the original format. Missing Features The following features are currently not supported: the requested run-mode is dropped while reading. scalar atomic quantities are not preserved and dropped. Note Feel free to contribute support for missing features\n      or bring missing features to our attention by opening an issue.","tags":"","loc":"page/./format-ein.html"},{"title":"DFTB+ general format – MCTC-library","text":"Specification Note Reference The general (gen) format is used for DFTB+ as geometry input format.\nIt is based on the xyz format . The first line contains the number of atoms and the specific kind of provided\ngeometry.\nAvailable types are cluster ( C ), supercell ( S ), fractional ( F ),\nand helical ( H ), the letter defining the format is case-insensitive. The second line gives the element symbols for each group of atoms separated by\nspaces, the groups are indexed starting from 1 and references in the specification\nof the atomic coordinates by this index rather than their element symbol. The following lines are specified as two integers and three reals separated by\nspaces. The first integer is currently ignored. The second integer references\nthe the element symbol in the second line.\nThe atomic coordinates are given in Ångström for cluster, supercell and helical,\nwhile they are given as fraction of the lattice vector for fractional input types. For supercell and fractional input the next lines contains three reals containing\nthe origin of the stucture, followed by three lines of each three reals for the\nlattice vectors. Lines starting with the # are comments and are ignored while parsing. The format is identified by the extension gen . Example Caffeine molecule in genFormat: 24 C\n C N O H\n    1    1    1.07317000000000E+00    4.88500000000000E-02   -7.57300000000000E-02\n    2    2    2.51365000000000E+00    1.25600000000000E-02   -7.58000000000000E-02\n    3    1    3.35199000000000E+00    1.09592000000000E+00   -7.53300000000000E-02\n    4    2    4.61898000000000E+00    7.30280000000000E-01   -7.54900000000000E-02\n    5    1    4.57907000000000E+00   -6.31440000000000E-01   -7.53100000000000E-02\n    6    1    3.30131000000000E+00   -1.10256000000000E+00   -7.52400000000000E-02\n    7    1    2.98068000000000E+00   -2.48687000000000E+00   -7.37700000000000E-02\n    8    3    1.82530000000000E+00   -2.90038000000000E+00   -7.57700000000000E-02\n    9    2    4.11440000000000E+00   -3.30433000000000E+00   -6.93600000000000E-02\n   10    1    5.45174000000000E+00   -2.85618000000000E+00   -7.23500000000000E-02\n   11    3    6.38934000000000E+00   -3.65965000000000E+00   -7.23200000000000E-02\n   12    2    5.66240000000000E+00   -1.47682000000000E+00   -7.48700000000000E-02\n   13    1    7.00947000000000E+00   -9.36480000000000E-01   -7.52400000000000E-02\n   14    1    3.92063000000000E+00   -4.74093000000000E+00   -6.15800000000000E-02\n   15    4    7.33980000000000E-01    1.08786000000000E+00   -7.50300000000000E-02\n   16    4    7.12390000000000E-01   -4.56980000000000E-01    8.23350000000000E-01\n   17    4    7.12400000000000E-01   -4.55800000000000E-01   -9.75490000000000E-01\n   18    4    2.99301000000000E+00    2.11762000000000E+00   -7.47800000000000E-02\n   19    4    7.76531000000000E+00   -1.72634000000000E+00   -7.59100000000000E-02\n   20    4    7.14864000000000E+00   -3.21820000000000E-01    8.19690000000000E-01\n   21    4    7.14802000000000E+00   -3.20760000000000E-01   -9.69530000000000E-01\n   22    4    2.86501000000000E+00   -5.02316000000000E+00   -5.83300000000000E-02\n   23    4    4.40233000000000E+00   -5.15920000000000E+00    8.28370000000000E-01\n   24    4    4.40017000000000E+00   -5.16929000000000E+00   -9.47800000000000E-01 Ammonia molecular crystal: 16 S\n H N\n    1    1    2.19855889440000E+00    1.76390058240000E+00    8.80145481600000E-01\n    2    1    1.76390058240000E+00    8.80145481600000E-01    2.19855889440000E+00\n    3    1    8.80145481600000E-01    2.19855889440000E+00    1.76390058240000E+00\n    4    1    4.84115108400000E+00    1.61941554720000E+00    4.93981400880000E+00\n    5    1    4.35630903840000E+00    2.49981169680000E+00    3.63248012160000E+00\n    6    1    3.51957925440000E+00    1.15357413600000E+00    4.08403345680000E+00\n    7    1    4.08403345680000E+00    3.51957925440000E+00    1.15357413600000E+00\n    8    1    4.93981400880000E+00    4.84115108400000E+00    1.61941554720000E+00\n    9    1    3.63248012160000E+00    4.35630903840000E+00    2.49981169680000E+00\n   10    1    2.49981169680000E+00    3.63248012160000E+00    4.35630903840000E+00\n   11    1    1.15357413600000E+00    4.08403345680000E+00    3.51957925440000E+00\n   12    1    1.61941554720000E+00    4.93981400880000E+00    4.84115108400000E+00\n   13    2    1.37461317840000E+00    1.37461317840000E+00    1.37461317840000E+00\n   14    2    3.99815460000000E+00    1.99105592400000E+00    4.46364507600000E+00\n   15    2    4.46364507600000E+00    3.99815460000000E+00    1.99105592400000E+00\n   16    2    1.99105592400000E+00    4.46364507600000E+00    3.99815460000000E+00\n    0.00000000000000    0.00000000000000    0.00000000000000\n    5.01336000000000    0.00000000000000    0.00000000000000\n    0.00000000000000    5.01336000000000    0.00000000000000\n    0.00000000000000    0.00000000000000    5.01336000000000 Extensions No extension implemented to the original format. Missing Features The following features are currently not supported: Helical boundary conditions Note Feel free to contribute support for missing features\n      or bring missing features to our attention by opening an issue.","tags":"","loc":"page/./format-gen.html"},{"title":"Protein data bank (PDB) format – MCTC-library","text":"Specification Note Reference The extension identifying this format is pdb . Example 4QXX protein with explicit hydrogen: HEADER    PROTEIN FIBRIL                          22-JUL-14   4QXX              \nTITLE     STRUCTURE OF THE AMYLOID FORMING PEPTIDE GNLVS (RESIDUES 26-30) FROM  \nTITLE    2 THE EOSINOPHIL MAJOR BASIC PROTEIN (EMBP)                            \nDBREF  4QXX Z    1     5  UNP    P13727   PRG2_HUMAN     131    135             \nSEQRES   1 Z    5  GLY ASN LEU VAL SER                                          \nFORMUL   2  HOH   *2(H2 O)                                                      \nCRYST1    4.755   16.816   35.759  90.00  90.00  90.00 P 2 21 21     4          \nORIGX1      1.000000  0.000000  0.000000        0.00000                         \nORIGX2      0.000000  1.000000  0.000000        0.00000                         \nORIGX3      0.000000  0.000000  1.000000        0.00000                         \nSCALE1      0.210305  0.000000  0.000000        0.00000                         \nSCALE2      0.000000  0.059467  0.000000        0.00000                         \nSCALE3      0.000000  0.000000  0.027965        0.00000                         \nATOM      1  N   GLY Z   1      -0.821  -2.072  16.609  1.00  9.93           N\nANISOU    1  N   GLY Z   1     1184   1952    638    314   -191   -326       N\nATOM      2  CA  GLY Z   1      -1.705  -2.345  15.487  1.00  7.38           C\nANISOU    2  CA  GLY Z   1      957   1374    472    279   -124   -261       C\nATOM      3  C   GLY Z   1      -0.968  -3.008  14.344  1.00  4.89           C\nANISOU    3  C   GLY Z   1      899    614    343    211    112   -106       C\nATOM      4  O   GLY Z   1       0.258  -2.982  14.292  1.00  5.05           O\nANISOU    4  O   GLY Z   1      839    595    485    -11     -7   -180       O\nATOM      5  HA2 GLY Z   1      -2.130  -1.405  15.135  1.00  0.00           H\nATOM      6  HA3 GLY Z   1      -2.511  -2.999  15.819  1.00  0.00           H\nATOM      7  H1  GLY Z   1      -1.364  -1.742  17.394  1.00  0.00           H\nATOM      8  H2  GLY Z   1      -0.150  -1.365  16.344  1.00  0.00           H\nATOM      9  H3  GLY Z   1      -0.334  -2.918  16.868  1.00  0.00           H\nATOM     10  N   ASN Z   2      -1.721  -3.603  13.425  1.00  3.53           N\nANISOU   10  N   ASN Z   2      747    329    264   -226    117    -67       N\nATOM     11  CA  ASN Z   2      -1.141  -4.323  12.291  1.00  1.85           C\nANISOU   11  CA  ASN Z   2      313    164    225     76    -23     77       C\nATOM     12  C   ASN Z   2      -1.748  -3.900  10.968  1.00  3.00           C\nANISOU   12  C   ASN Z   2      610    293    238    197     -2    -42       C\nATOM     13  O   ASN Z   2      -2.955  -3.683  10.873  1.00  3.99           O\nANISOU   13  O   ASN Z   2      599    514    402    199    191    -60       O\nATOM     14  CB  ASN Z   2      -1.353  -5.827  12.446  1.00  5.03           C\nANISOU   14  CB  ASN Z   2     1173    368    369    170    -47     37       C\nATOM     15  CG  ASN Z   2      -0.679  -6.391  13.683  1.00  5.08           C\nANISOU   15  CG  ASN Z   2      727    718    484    228   -243     90       C\nATOM     16  OD1 ASN Z   2       0.519  -6.202  13.896  1.00  6.10           O\nANISOU   16  OD1 ASN Z   2      828    960    531    477    -61    100       O\nATOM     17  ND2 ASN Z   2      -1.448  -7.087  14.506  1.00  8.41           N\nANISOU   17  ND2 ASN Z   2     1513   1193    488     40    102    279       N\nATOM     18  H   ASN Z   2      -2.726  -3.557  13.512  1.00  0.00           H\nATOM     19  HA  ASN Z   2      -0.070  -4.123  12.263  1.00  0.00           H\nATOM     20  HB2 ASN Z   2      -0.945  -6.328  11.568  1.00  0.00           H\nATOM     21  HB3 ASN Z   2      -2.423  -6.029  12.503  1.00  0.00           H\nATOM     22 HD21 ASN Z   2      -2.427  -7.218  14.293  1.00  0.00           H\nATOM     23 HD22 ASN Z   2      -1.056  -7.487  15.346  1.00  0.00           H\nATOM     24  N   LEU Z   3      -0.907  -3.803   9.944  1.00  3.47           N\nANISOU   24  N   LEU Z   3      701    405    213   -242     25    -26       N\nATOM     25  CA  LEU Z   3      -1.388  -3.576   8.586  1.00  3.48           C\nANISOU   25  CA  LEU Z   3      728    324    271     79    180     -5       C\nATOM     26  C   LEU Z   3      -0.783  -4.660   7.709  1.00  3.29           C\nANISOU   26  C   LEU Z   3      684    261    306    -17    150    -80       C\nATOM     27  O   LEU Z   3       0.437  -4.788   7.643  1.00  3.80           O\nANISOU   27  O   LEU Z   3      590    437    415    141    178   -122       O\nATOM     28  CB  LEU Z   3      -0.977  -2.185   8.081  1.00  3.88           C\nANISOU   28  CB  LEU Z   3      899    293    282    171    125     42       C\nATOM     29  CG  LEU Z   3      -1.524  -1.669   6.736  1.00  8.66           C\nANISOU   29  CG  LEU Z   3     2091    598    600     63    -94     66       C\nATOM     30  CD1 LEU Z   3      -1.225  -0.191   6.570  1.00  9.89           C\nANISOU   30  CD1 LEU Z   3     2263    792    703    132   -163    143       C\nATOM     31  CD2 LEU Z   3      -0.962  -2.409   5.541  1.00 13.56           C\nANISOU   31  CD2 LEU Z   3     3203   1048    901   -640   -305     94       C\nATOM     32  H   LEU Z   3       0.086  -3.888  10.109  1.00  0.00           H\nATOM     33  HA  LEU Z   3      -2.475  -3.661   8.568  1.00  0.00           H\nATOM     34  HB2 LEU Z   3      -1.284  -1.469   8.843  1.00  0.00           H\nATOM     35  HB3 LEU Z   3       0.111  -2.162   8.026  1.00  0.00           H\nATOM     36  HG  LEU Z   3      -2.606  -1.798   6.737  1.00  0.00           H\nATOM     37 HD11 LEU Z   3      -1.623   0.359   7.423  1.00  0.00           H\nATOM     38 HD12 LEU Z   3      -1.691   0.173   5.654  1.00  0.00           H\nATOM     39 HD13 LEU Z   3      -0.147  -0.043   6.513  1.00  0.00           H\nATOM     40 HD21 LEU Z   3      -1.168  -3.475   5.643  1.00  0.00           H\nATOM     41 HD22 LEU Z   3      -1.429  -2.035   4.630  1.00  0.00           H\nATOM     42 HD23 LEU Z   3       0.115  -2.250   5.489  1.00  0.00           H\nATOM     43  N   VAL Z   4      -1.635  -5.424   7.029  1.00  3.17           N\nANISOU   43  N   VAL Z   4      604    266    333   -100    104   -123       N\nATOM     44  CA  VAL Z   4      -1.165  -6.460   6.119  1.00  3.61           C\nANISOU   44  CA  VAL Z   4      607    353    411    205   -241   -157       C\nATOM     45  C   VAL Z   4      -1.791  -6.230   4.755  1.00  5.31           C\nANISOU   45  C   VAL Z   4      543    915    562    395    -15    -39       C\nATOM     46  O   VAL Z   4      -3.014  -6.209   4.620  1.00  7.31           O\nANISOU   46  O   VAL Z   4      577   1569    630     45     -5   -227       O\nATOM     47  CB  VAL Z   4      -1.567  -7.872   6.593  1.00  5.31           C\nANISOU   47  CB  VAL Z   4     1024    336    657     64     39   -167       C\nATOM     48  CG1 VAL Z   4      -1.012  -8.934   5.633  1.00  6.73           C\nANISOU   48  CG1 VAL Z   4     1131    549    879    220    104   -300       C\nATOM     49  CG2 VAL Z   4      -1.083  -8.120   8.018  1.00  5.48           C\nANISOU   49  CG2 VAL Z   4      819    632    630     15     15     42       C\nATOM     50  H   VAL Z   4      -2.628  -5.282   7.146  1.00  0.00           H\nATOM     51  HA  VAL Z   4      -0.080  -6.402   6.034  1.00  0.00           H\nATOM     52  HB  VAL Z   4      -2.655  -7.939   6.585  1.00  0.00           H\nATOM     53 HG11 VAL Z   4      -1.303  -9.926   5.980  1.00  0.00           H\nATOM     54 HG12 VAL Z   4      -1.414  -8.766   4.634  1.00  0.00           H\nATOM     55 HG13 VAL Z   4       0.075  -8.864   5.603  1.00  0.00           H\nATOM     56 HG21 VAL Z   4      -1.377  -9.121   8.333  1.00  0.00           H\nATOM     57 HG22 VAL Z   4       0.003  -8.032   8.053  1.00  0.00           H\nATOM     58 HG23 VAL Z   4      -1.529  -7.383   8.686  1.00  0.00           H\nATOM     59  N   SER Z   5      -0.966  -6.052   3.736  1.00  7.53           N\nANISOU   59  N   SER Z   5      810   1357    693    337     48    302       N\nATOM     60  CA  SER Z   5      -1.526  -5.888   2.407  1.00 11.48           C\nANISOU   60  CA  SER Z   5     1654   1766    943    560   -145    241       C\nATOM     61  C   SER Z   5      -1.207  -7.085   1.529  1.00 16.35           C\nANISOU   61  C   SER Z   5     3066   2118   1029    758   -523   -208       C\nATOM     62  O   SER Z   5      -0.437  -7.976   1.902  1.00 14.00           O\nANISOU   62  O   SER Z   5     2584   1676   1060    878   -402   -452       O\nATOM     63  CB  SER Z   5      -1.031  -4.596   1.767  1.00 13.36           C\nANISOU   63  CB  SER Z   5     1565   2151   1361    818    -30    608       C\nATOM     64  OG  SER Z   5       0.361  -4.652   1.540  1.00 15.80           O\nANISOU   64  OG  SER Z   5     1604   2812   1587    822     25    763       O\nATOM     65  OXT SER Z   5      -1.737  -7.178   0.429  1.00 17.09           O\nANISOU   65  OXT SER Z   5     2807   2495   1192    648   -712   -430       O\nATOM     66  H   SER Z   5       0.033  -6.031   3.880  1.00  0.00           H\nATOM     67  HA  SER Z   5      -2.610  -5.822   2.504  1.00  0.00           H\nATOM     68  HB2 SER Z   5      -1.543  -4.449   0.816  1.00  0.00           H\nATOM     69  HB3 SER Z   5      -1.254  -3.759   2.428  1.00  0.00           H\nATOM     70  HG  SER Z   5       0.653  -3.831   1.137  1.00  0.00           H\nTER      71      SER Z   5\nHETATM   72  O   HOH Z 101       0.935  -5.175  16.502  1.00 18.83           O\nANISOU   72  O   HOH Z 101     3066   2772   1315  -1227   -232    339       O\nHETATM   73  H1  HOH Z 101       0.794  -5.522  15.621  1.00  0.00           H\nHETATM   74  H2  HOH Z 101       1.669  -4.561  16.489  1.00  0.00           H\nHETATM   75  O  AHOH Z 102       0.691  -8.408  17.879  0.91 56.55           O\nANISOU   75  O  AHOH Z 102     9673   9234   2579      0      5   1219       O\nHETATM   76  O  BHOH Z 102      -0.788  -9.006  16.641  0.09 38.95           O\nANISOU   76  O  BHOH Z 102     6801   4266   3734   2095  -1531    549       O\nHETATM   77  H1 AHOH Z 102       1.392  -8.125  18.466  0.91  0.00           H\nHETATM   78  H1 BHOH Z 102      -1.351  -9.776  16.563  0.09  0.00           H\nHETATM   79  H2 AHOH Z 102       0.993  -8.356  16.972  0.91  0.00           H\nHETATM   80  H2 BHOH Z 102      -0.927  -8.594  17.494  0.09  0.00           H\nCONECT   73   72\nCONECT   74   72\nCONECT   72   73   74\nCONECT   78   76\nCONECT   77   75\nCONECT   80   76\nCONECT   79   75\nCONECT   75   77   79\nCONECT   76   78   80\nEND Extensions No extension implemented to the original format. Missing Features The following features are currently not supported: Support for multiple file PDB input is not available Fractional side occupation is currently not supported\n  all optional sides count as full atoms Cell information is not preserved, PDB input is always handled molecular Note Feel free to contribute support for missing features\n      or bring missing features to our attention by opening an issue.","tags":"","loc":"page/./format-pdb.html"},{"title":"Turbomole's coordinate data group – MCTC-library","text":"Specification Note Reference The Turbomole format mainly builds around the control file.\nThe control file contains several data groups which are delimited by\ntheir identifier, groups are either present in the control file or\nreferences from the control file.\nThis format is defined by the geometry related information from the control file, mainly the: coord data group lattice data group cell data group periodic data group eht data group For simplicity file references are not allowed and all data groups should be\nin the same file. The data groups are not required to be in any particular order. A group is started by a $ symbol and accept modifiers. It is terminated by\nanother group or the end group which stops the scanning for further groups: $group1 [modifier]...\n[entries]...\n$group2 [modifier]...\n[entries]...\n$end The coord data group contains the cartesian coordinates of all atoms and\ntheir element symbols at the end of each line.\nAtomic coordinates can either be specified in Bohr, by default or with the bohr modifier on the coord data group, in Ångström with the modifer angs or\nas fractions of the lattice vectors with the modifier frac .\nFractional coordinates can only be present for periodicities greater than zero. The periodicity of the system is specified as modifier to the periodic data\ngroup, the group itself is empty. The lattice parameters can either be specified in the lattice or the cell data group, which requre different amounts of entries depending on the systems\nperiodicity. Both data groups are either given in atomic units (Bohr) or in\nÅngström with the angs modifier. For 3D periodic systems three lines with each three reals are required in the lattice data group. For a 2D periodic system two lines with each two reals\nare required and the aperiodic direction is the z-axis.\nFinally, for 1D periodic systems one real is required, giving the translation\nvector in the x-direction.\nThe periodic directions are fixed in this format. Similarly, the cell data groups allows for six, three, and one entries for\n3D, 2D, and 1D periodic systems, respectively. The cell parameters are given\nas the length of the lattice vectors and their angles, with the angles given\nin degrees. Charge and spin can be given in the eht data group with $eht charge=<int> unpaired=<int> The format is identified by coord or tmol extension or by using coord as basename. Example Caffeine molecule in Turbomole’s coord format $coord\n    2.02799694102955E+00    9.23131009712288E-02   -1.43108928076789E-01      C\n    4.75010903288289E+00    2.37349549273006E-02   -1.43241208876543E-01      N\n    6.33434168525178E+00    2.07098820094962E+00   -1.42353037792480E-01      C\n    8.72860526354322E+00    1.38002889206282E+00   -1.42655393906204E-01      N\n    8.65318631042630E+00   -1.19324840281009E+00   -1.42315243278265E-01      C\n    6.23857038622984E+00   -2.08353597966915E+00   -1.42182962478511E-01      C\n    5.63266763158490E+00   -4.69950217834841E+00   -1.39405065683676E-01      C\n    3.44931633987275E+00   -5.48092265700988E+00   -1.43184517105220E-01      O\n    7.77508746440172E+00   -6.24427735787637E+00   -1.31071375299170E-01      N\n    1.03022932464460E+01   -5.39739678059374E+00   -1.36721655174379E-01      C\n    1.20741000728661E+01   -6.91573469742800E+00   -1.36664963403056E-01      O\n    1.07003828646773E+01   -2.79078472418281E+00   -1.41483763965525E-01      N\n    1.32459756778874E+01   -1.76969033362408E+00   -1.42182962478511E-01      C\n    7.40891531342536E+00   -8.95905731397191E+00   -1.16369309269361E-01      C\n    1.38702087719268E+00    2.05575701172080E+00   -1.41786120079249E-01      H\n    1.34622169909711E+00   -8.63566855308744E-01    1.55590566396441E+00      H\n    1.34624059635422E+00   -8.61336978970033E-01   -1.84340853360131E+00      H\n    5.65596794959872E+00    4.00172095964572E+00   -1.41313688651556E-01      H\n    1.46743059591176E+01   -3.26230908353472E+00   -1.43449078704728E-01      H\n    1.35089688050556E+01   -6.08151528240755E-01    1.54898926786298E+00      H\n    1.35077971751149E+01   -6.06148418987336E-01   -1.83214576836511E+00      H\n    5.41408305861986E+00   -9.49239460132319E+00   -1.10227700709351E-01      H\n    8.31919618830440E+00   -9.74947288701666E+00    1.56539208703248E+00      H\n    8.31511438076913E+00   -9.76854021943835E+00   -1.79108202867002E+00      H\n$end Ammonia molecular crystal: $coord\n    4.15467326939489E+00    3.33328828180759E+00    1.66323354579962E+00      H\n    3.33328828180759E+00    1.66323354579962E+00    4.15467326939489E+00      H\n    1.66323354579962E+00    4.15467326939489E+00    3.33328828180759E+00      H\n    9.14844767316819E+00    3.06025119596830E+00    9.33489353886275E+00      H\n    8.23222919393441E+00    4.72395843553239E+00    6.86439107965696E+00      H\n    6.65103940814062E+00    2.17993870408119E+00    7.71770302696940E+00      H\n    7.71770302696940E+00    6.65103940814062E+00    2.17993870408119E+00      H\n    9.33489353886275E+00    9.14844767316819E+00    3.06025119596830E+00      H\n    6.86439107965696E+00    8.23222919393441E+00    4.72395843553239E+00      H\n    4.72395843553239E+00    6.86439107965696E+00    8.23222919393441E+00      H\n    2.17993870408119E+00    7.71770302696940E+00    6.65103940814062E+00      H\n    3.06025119596830E+00    9.33489353886275E+00    9.14844767316819E+00      H\n    2.59764186558897E+00    2.59764186558897E+00    2.59764186558897E+00      N\n    7.55541554326270E+00    3.76254957116838E+00    8.43506486387956E+00      N\n    8.43506486387956E+00    7.55541554326270E+00    3.76254957116838E+00      N\n    3.76254957116838E+00    8.43506486387956E+00    7.55541554326270E+00      N\n$periodic 3\n$lattice\n    9.47387528935762    0.00000000000000    0.00000000000000\n    0.00000000000000    9.47387528935762    0.00000000000000\n    0.00000000000000    0.00000000000000    9.47387528935762\n$end Extensions The original format does only allow for the periodic or eht group to\nappear in the control file, to make the format self-contained, all groups\nmust appear in the same file. Missing Features The following features are currently not supported: Preserving information about frozen atoms from coord data group Reading charge and spin from the eht data group Note Feel free to contribute support for missing features\n      or bring missing features to our attention by opening an issue.","tags":"","loc":"page/./format-tmol.html"},{"title":"Vasp's POSCAR format – MCTC-library","text":"Note Reference The format is identified by the extension vasp , poscar or contcar .\nAlternatively, the basenames poscar and contcar identify the format as well. Examples Ammonia molecular crystal in pre Vasp 5 POSCAR format: H  N \n 1.0000000000000000\n     5.0133599999999996    0.0000000000000000    0.0000000000000000\n     0.0000000000000000    5.0133599999999996    0.0000000000000000\n     0.0000000000000000    0.0000000000000000    5.0133599999999996\n  12   4\nCartesian\n  2.1985588943999996  1.7639005823999998  0.8801454815999999\n  1.7639005823999998  0.8801454815999999  2.1985588943999996\n  0.8801454815999999  2.1985588943999996  1.7639005823999998\n  4.8411510839999998  1.6194155471999998  4.9398140088000000\n  4.3563090384000001  2.4998116967999997  3.6324801215999996\n  3.5195792543999995  1.1535741359999998  4.0840334567999994\n  4.0840334567999994  3.5195792543999995  1.1535741359999998\n  4.9398140088000000  4.8411510839999998  1.6194155471999998\n  3.6324801215999996  4.3563090384000001  2.4998116967999997\n  2.4998116967999997  3.6324801215999996  4.3563090384000001\n  1.1535741359999998  4.0840334567999994  3.5195792543999995\n  1.6194155471999998  4.9398140088000000  4.8411510839999998\n  1.3746131783999997  1.3746131783999997  1.3746131783999997\n  3.9981545999999994  1.9910559239999999  4.4636450759999997\n  4.4636450759999997  3.9981545999999994  1.9910559239999999\n  1.9910559239999999  4.4636450759999997  3.9981545999999994 Carbondioxide in POSCAR format: 4CO2\n    1.00000000000000\n    5.68032000000000    0.00000000000000    0.00000000000000\n    0.00000000000000    5.68032000000000    0.00000000000000\n    0.00000000000000    0.00000000000000    5.68032000000000\n C    O   \n 4 8\nCartesian\n    0.94412598720000    0.94378516800000    0.95435056320000\n    3.71799665280000    0.95565703680000    3.73168622400000\n    3.71595173760000    3.71492928000000    0.96923300160000\n    0.95298728640000    3.72208648320000    3.72969811200000\n    1.62139054080000    1.61906160960000    1.63138790400000\n    0.26566856640000    0.26941757760000    0.27765404160000\n    4.39145539200000    1.63462568640000    3.05459208000000\n    3.04408348800000    0.27646117440000    4.40804192640000\n    4.39105776960000    3.04164095040000    0.28810583040000\n    3.03999365760000    4.38793359360000    1.64973533760000\n    0.27413224320000    4.40037349440000    3.05737543680000\n    1.63121749440000    3.04345865280000    4.40230480320000 Extensions No extension implemented to the original format. Missing Features The implementation of this format is (to our knowledge) feature-complete. Note Feel free to bring missing features to our attention by opening an issue.","tags":"","loc":"page/./format-vasp.html"},{"title":"xyz format – MCTC-library","text":"Specification Note Reference Simple format to store cartesian coordinates and element symbols.\nThe first line contains the number of atoms in the geometry.\nThe second line is a comment line and ignored, some program store additional\ninformation here.\nThe following lines contain a short character identifier and three reals.\nThe first entry is interpreted as element symbol and defines the atomic species.\nThe atomic coordinates are given in Ångström. A scalar quantity can be added to each atom with one real as well as a vector\nquantity by three reals, allowing additional four reals per atomic entry. The format is identified by the file extension xyz or log . Examples Caffeine molecule in xyz format 24\n\nC            1.07317000000000        0.04885000000000       -0.07573000000000\nN            2.51365000000000        0.01256000000000       -0.07580000000000\nC            3.35199000000000        1.09592000000000       -0.07533000000000\nN            4.61898000000000        0.73028000000000       -0.07549000000000\nC            4.57907000000000       -0.63144000000000       -0.07531000000000\nC            3.30131000000000       -1.10256000000000       -0.07524000000000\nC            2.98068000000000       -2.48687000000000       -0.07377000000000\nO            1.82530000000000       -2.90038000000000       -0.07577000000000\nN            4.11440000000000       -3.30433000000000       -0.06936000000000\nC            5.45174000000000       -2.85618000000000       -0.07235000000000\nO            6.38934000000000       -3.65965000000000       -0.07232000000000\nN            5.66240000000000       -1.47682000000000       -0.07487000000000\nC            7.00947000000000       -0.93648000000000       -0.07524000000000\nC            3.92063000000000       -4.74093000000000       -0.06158000000000\nH            0.73398000000000        1.08786000000000       -0.07503000000000\nH            0.71239000000000       -0.45698000000000        0.82335000000000\nH            0.71240000000000       -0.45580000000000       -0.97549000000000\nH            2.99301000000000        2.11762000000000       -0.07478000000000\nH            7.76531000000000       -1.72634000000000       -0.07591000000000\nH            7.14864000000000       -0.32182000000000        0.81969000000000\nH            7.14802000000000       -0.32076000000000       -0.96953000000000\nH            2.86501000000000       -5.02316000000000       -0.05833000000000\nH            4.40233000000000       -5.15920000000000        0.82837000000000\nH            4.40017000000000       -5.16929000000000       -0.94780000000000 Extensions The reader supports the following extensions: Atomic numbers are allowed instead of element symbols.\n  They are automatically converted to capitalized element symbols Missing Features The following features are currently not supported: Scalar atomic quantities are not preserved and dropped. Vector atomic quantities are not preserved and dropped. Note Feel free to contribute support for missing features\n      or bring missing features to our attention by opening an issue.","tags":"","loc":"page/./format-xyz.html"}]}